(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            m._isValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = getParsingFlags(from);
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            locales[name] = locales[name] || new Locale();
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function isFunction (sth) {
        // https://github.com/moment/moment/issues/2325
        return typeof sth === 'function' &&
            Object.prototype.toString.call(sth) === '[object Function]';
    }


    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (firstTime) {
                warn(msg + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            getParsingFlags(config).iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    config._f = isoDates[i][0];
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    // match[6] should be 'T' or space
                    config._f += (match[6] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var week1Jan = 6 + firstDayOfWeek - firstDayOfWeekOfYear, janX = createUTCDate(year, 0, 1 + week1Jan), d = janX.getUTCDay(), dayOfYear;
        if (d < firstDayOfWeek) {
            d += 7;
        }

        weekday = weekday != null ? 1 * weekday : firstDayOfWeek;

        dayOfYear = 1 + week1Jan + 7 * (week - 1) - d + weekday;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (getParsingFlags(config).bigHour === true &&
                config._a[HOUR] <= 12 &&
                config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else if (isDate(input)) {
            config._d = input;
        } else {
            configFromInput(config);
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        input = input ? local__createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (typeof this._isDSTShifted !== 'undefined') {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(formats && formats[format] || this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function moment_format__format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }
        return create__createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function toNow (withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        this._weekdaysParse = this._weekdaysParse || [];

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = moment_format__format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.to           = to;
    momentPrototype__proto.toNow        = toNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toObject     = toObject;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment_moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment_moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var duration_get__months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days         = iso_string__abs(this._days);
        var months       = iso_string__abs(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = duration_get__months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports

    ;

    //! moment.js
    //! version : 2.10.6
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com

    utils_hooks__hooks.version = '2.10.6';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment_moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment_moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment__default = utils_hooks__hooks;

    //! moment.js locale configuration
    //! locale : afrikaans (af)
    //! author : Werner Mollentze : https://github.com/wernerm

    var af = _moment__default.defineLocale('af', {
        months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
        weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
        weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
        meridiemParse: /vm|nm/i,
        isPM : function (input) {
            return /^nm$/i.test(input);
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower ? 'vm' : 'VM';
            } else {
                return isLower ? 'nm' : 'NM';
            }
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Vandag om] LT',
            nextDay : '[Mre om] LT',
            nextWeek : 'dddd [om] LT',
            lastDay : '[Gister om] LT',
            lastWeek : '[Laas] dddd [om] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'oor %s',
            past : '%s gelede',
            s : '\'n paar sekondes',
            m : '\'n minuut',
            mm : '%d minute',
            h : '\'n uur',
            hh : '%d ure',
            d : '\'n dag',
            dd : '%d dae',
            M : '\'n maand',
            MM : '%d maande',
            y : '\'n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
        },
        week : {
            dow : 1, // Maandag is die eerste dag van die week.
            doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
        }
    });

    //! moment.js locale configuration
    //! locale : Moroccan Arabic (ar-ma)
    //! author : ElFadili Yassine : https://github.com/ElFadiliY
    //! author : Abdel Said : https://github.com/abdelsaid

    var ar_ma = _moment__default.defineLocale('ar-ma', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Arabic Saudi Arabia (ar-sa)
    //! author : Suhail Alkowaileet : https://github.com/xsoh

    var ar_sa__symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, ar_sa__numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ar_sa = _moment__default.defineLocale('ar-sa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return ar_sa__numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ar_sa__symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale  : Tunisian Arabic (ar-tn)

    var ar_tn = _moment__default.defineLocale('ar-tn', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s',
            past: ' %s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! Locale: Arabic (ar)
    //! Author: Abdel Said: https://github.com/abdelsaid
    //! Changes in months, weekdays: Ahmed Elkhatib
    //! Native plural forms: forabi https://github.com/forabi

    var ar__symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, ar__numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    }, pluralForm = function (n) {
        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    }, plurals = {
        s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
        y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
    }, pluralize = function (u) {
        return function (number, withoutSuffix, string, isFuture) {
            var f = pluralForm(number),
                str = plurals[u][pluralForm(number)];
            if (f === 2) {
                str = str[withoutSuffix ? 0 : 1];
            }
            return str.replace(/%d/i, number);
        };
    }, ar__months = [
        '  ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        '  ',
        '  ',
        '  '
    ];

    var ar = _moment__default.defineLocale('ar', {
        months : ar__months,
        monthsShort : ar__months,
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'D/\u200FM/\u200FYYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        meridiemParse: /|/,
        isPM : function (input) {
            return '' === input;
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay: '[  ] LT',
            nextDay: '[  ] LT',
            nextWeek: 'dddd [ ] LT',
            lastDay: '[  ] LT',
            lastWeek: 'dddd [ ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : pluralize('s'),
            m : pluralize('m'),
            mm : pluralize('m'),
            h : pluralize('h'),
            hh : pluralize('h'),
            d : pluralize('d'),
            dd : pluralize('d'),
            M : pluralize('M'),
            MM : pluralize('M'),
            y : pluralize('y'),
            yy : pluralize('y')
        },
        preparse: function (string) {
            return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
                return ar__numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ar__symbolMap[match];
            }).replace(/,/g, '');
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : azerbaijani (az)
    //! author : topchiyev : https://github.com/topchiyev

    var az__suffixes = {
        1: '-inci',
        5: '-inci',
        8: '-inci',
        70: '-inci',
        80: '-inci',
        2: '-nci',
        7: '-nci',
        20: '-nci',
        50: '-nci',
        3: '-nc',
        4: '-nc',
        100: '-nc',
        6: '-nc',
        9: '-uncu',
        10: '-uncu',
        30: '-uncu',
        60: '-nc',
        90: '-nc'
    };

    var az = _moment__default.defineLocale('az', {
        months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
        monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
        weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
        weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
        weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[sabah saat] LT',
            nextWeek : '[gln hft] dddd [saat] LT',
            lastDay : '[dnn] LT',
            lastWeek : '[ken hft] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s vvl',
            s : 'birne saniyy',
            m : 'bir dqiq',
            mm : '%d dqiq',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir il',
            yy : '%d il'
        },
        meridiemParse: /gec|shr|gndz|axam/,
        isPM : function (input) {
            return /^(gndz|axam)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return 'gec';
            } else if (hour < 12) {
                return 'shr';
            } else if (hour < 17) {
                return 'gndz';
            } else {
                return 'axam';
            }
        },
        ordinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '-nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (az__suffixes[a] || az__suffixes[b] || az__suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : belarusian (be)
    //! author : Dmitry Demidov : https://github.com/demidov91
    //! author: Praleska: http://praleska.pro/
    //! Author : Menelion Elensle : https://github.com/Oire

    function be__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function be__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': withoutSuffix ? '__' : '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + be__plural(format[key], +number);
        }
    }
    function be__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function be__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_')
        },
        nounCase = (/\[ ?[] ?(?:|)? ?\] ?dddd/).test(format) ?
            'accusative' :
            'nominative';
        return weekdays[nounCase][m.day()];
    }

    var be = _moment__default.defineLocale('be', {
        months : be__monthsCaseReplace,
        monthsShort : '___________'.split('_'),
        weekdays : be__weekdaysCaseReplace,
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function () {
                return '[] dddd [] LT';
            },
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                    return '[ ] dddd [] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : be__relativeTimeWithPlural,
            mm : be__relativeTimeWithPlural,
            h : be__relativeTimeWithPlural,
            hh : be__relativeTimeWithPlural,
            d : '',
            dd : be__relativeTimeWithPlural,
            M : '',
            MM : be__relativeTimeWithPlural,
            y : '',
            yy : be__relativeTimeWithPlural
        },
        meridiemParse: /|||/,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : bulgarian (bg)
    //! author : Krasen Borisov : https://github.com/kraz

    var bg = _moment__default.defineLocale('bg', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[ ] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bengali (bn)
    //! author : Kaushik Gandhi : https://github.com/kaushikgandhi

    var bn__symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    bn__numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bn = _moment__default.defineLocale('bn', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return bn__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return bn__symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        isPM: function (input) {
            return /^(||)$/.test(input);
        },
        //Bengali is a vast language its spoken
        //in different forms in various parts of the world.
        //I have just generalized with most common one used
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : tibetan (bo)
    //! author : Thupten N. Chakrishar : https://github.com/vajradog

    var bo__symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    bo__numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var bo = _moment__default.defineLocale('bo', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm',
            LTS : 'A h:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm',
            LLLL : 'dddd, D MMMM YYYY, A h:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[], LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return bo__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return bo__symbolMap[match];
            });
        },
        meridiemParse: /||||/,
        isPM: function (input) {
            return /^(||)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : breton (br)
    //! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou

    function relativeTimeWithMutation(number, withoutSuffix, key) {
        var format = {
            'mm': 'munutenn',
            'MM': 'miz',
            'dd': 'devezh'
        };
        return number + ' ' + mutation(format[key], number);
    }
    function specialMutationForYears(number) {
        switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
            return number + ' bloaz';
        default:
            return number + ' vloaz';
        }
    }
    function lastNumber(number) {
        if (number > 9) {
            return lastNumber(number % 10);
        }
        return number;
    }
    function mutation(text, number) {
        if (number === 2) {
            return softMutation(text);
        }
        return text;
    }
    function softMutation(text) {
        var mutationTable = {
            'm': 'v',
            'b': 'v',
            'd': 'z'
        };
        if (mutationTable[text.charAt(0)] === undefined) {
            return text;
        }
        return mutationTable[text.charAt(0)] + text.substring(1);
    }

    var br = _moment__default.defineLocale('br', {
        months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
        monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
        weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
        weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
        weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
        longDateFormat : {
            LT : 'h[e]mm A',
            LTS : 'h[e]mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D [a viz] MMMM YYYY',
            LLL : 'D [a viz] MMMM YYYY h[e]mm A',
            LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
        },
        calendar : {
            sameDay : '[Hiziv da] LT',
            nextDay : '[Warc\'hoazh da] LT',
            nextWeek : 'dddd [da] LT',
            lastDay : '[Dec\'h da] LT',
            lastWeek : 'dddd [paset da] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'a-benn %s',
            past : '%s \'zo',
            s : 'un nebeud segondenno',
            m : 'ur vunutenn',
            mm : relativeTimeWithMutation,
            h : 'un eur',
            hh : '%d eur',
            d : 'un devezh',
            dd : relativeTimeWithMutation,
            M : 'ur miz',
            MM : relativeTimeWithMutation,
            y : 'ur bloaz',
            yy : specialMutationForYears
        },
        ordinalParse: /\d{1,2}(a|vet)/,
        ordinal : function (number) {
            var output = (number === 1) ? 'a' : 'vet';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : bosnian (bs)
    //! author : Nedim Cholich : https://github.com/frontyard
    //! based on (hr) translation by Bojan Markovi

    function bs__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var bs = _moment__default.defineLocale('bs', {
        months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : bs__translate,
            mm     : bs__translate,
            h      : bs__translate,
            hh     : bs__translate,
            d      : 'dan',
            dd     : bs__translate,
            M      : 'mjesec',
            MM     : bs__translate,
            y      : 'godinu',
            yy     : bs__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : catalan (ca)
    //! author : Juan G. Hurtado : https://github.com/juanghurtado

    var ca = _moment__default.defineLocale('ca', {
        months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
        monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
        weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
        weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
        weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'LT:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextDay : function () {
                return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastDay : function () {
                return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'fa %s',
            s : 'uns segons',
            m : 'un minut',
            mm : '%d minuts',
            h : 'una hora',
            hh : '%d hores',
            d : 'un dia',
            dd : '%d dies',
            M : 'un mes',
            MM : '%d mesos',
            y : 'un any',
            yy : '%d anys'
        },
        ordinalParse: /\d{1,2}(r|n|t||a)/,
        ordinal : function (number, period) {
            var output = (number === 1) ? 'r' :
                (number === 2) ? 'n' :
                (number === 3) ? 'r' :
                (number === 4) ? 't' : '';
            if (period === 'w' || period === 'W') {
                output = 'a';
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : czech (cs)
    //! author : petrbela : https://github.com/petrbela

    var cs__months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
        cs__monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
    function cs__plural(n) {
        return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
    }
    function cs__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'minuty' : 'minut');
            } else {
                return result + 'minutami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'hodiny' : 'hodin');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'dny' : 'dn');
            } else {
                return result + 'dny';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'msce' : 'msc');
            } else {
                return result + 'msci';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (cs__plural(number) ? 'roky' : 'let');
            } else {
                return result + 'lety';
            }
            break;
        }
    }

    var cs = _moment__default.defineLocale('cs', {
        months : cs__months,
        monthsShort : cs__monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (ervenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(cs__months, cs__monthsShort)),
        weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
        weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
        weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes v] LT',
            nextDay: '[ztra v] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v nedli v] LT';
                case 1:
                case 2:
                    return '[v] dddd [v] LT';
                case 3:
                    return '[ve stedu v] LT';
                case 4:
                    return '[ve tvrtek v] LT';
                case 5:
                    return '[v ptek v] LT';
                case 6:
                    return '[v sobotu v] LT';
                }
            },
            lastDay: '[vera v] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minulou nedli v] LT';
                case 1:
                case 2:
                    return '[minul] dddd [v] LT';
                case 3:
                    return '[minulou stedu v] LT';
                case 4:
                case 5:
                    return '[minul] dddd [v] LT';
                case 6:
                    return '[minulou sobotu v] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'ped %s',
            s : cs__translate,
            m : cs__translate,
            mm : cs__translate,
            h : cs__translate,
            hh : cs__translate,
            d : cs__translate,
            dd : cs__translate,
            M : cs__translate,
            MM : cs__translate,
            y : cs__translate,
            yy : cs__translate
        },
        ordinalParse : /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : chuvash (cv)
    //! author : Anatoly Mironov : https://github.com/mirontoli

    var cv = _moment__default.defineLocale('cv', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'YYYY [] MMMM [] D[-]',
            LLL : 'YYYY [] MMMM [] D[-], HH:mm',
            LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
        },
        calendar : {
            sameDay: '[] LT []',
            nextDay: '[] LT []',
            lastDay: '[] LT []',
            nextWeek: '[] dddd LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime : {
            future : function (output) {
                var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
                return output + affix;
            },
            past : '%s ',
            s : '- ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-/,
        ordinal : '%d-',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Welsh (cy)
    //! author : Robert Allen

    var cy = _moment__default.defineLocale('cy', {
        months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
        monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
        weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
        weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
        weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
        // time formats are the same as en-gb
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[Heddiw am] LT',
            nextDay: '[Yfory am] LT',
            nextWeek: 'dddd [am] LT',
            lastDay: '[Ddoe am] LT',
            lastWeek: 'dddd [diwethaf am] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: 'mewn %s',
            past: '%s yn l',
            s: 'ychydig eiliadau',
            m: 'munud',
            mm: '%d munud',
            h: 'awr',
            hh: '%d awr',
            d: 'diwrnod',
            dd: '%d diwrnod',
            M: 'mis',
            MM: '%d mis',
            y: 'blwyddyn',
            yy: '%d flynedd'
        },
        ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
        // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
        ordinal: function (number) {
            var b = number,
                output = '',
                lookup = [
                    '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
                    'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
                ];
            if (b > 20) {
                if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
                    output = 'fed'; // not 30ain, 70ain or 90ain
                } else {
                    output = 'ain';
                }
            } else if (b > 0) {
                output = lookup[b];
            }
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : danish (da)
    //! author : Ulrik Nielsen : https://github.com/mrbase

    var da = _moment__default.defineLocale('da', {
        months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[I dag kl.] LT',
            nextDay : '[I morgen kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[I gr kl.] LT',
            lastWeek : '[sidste] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : '%s siden',
            s : 'f sekunder',
            m : 'et minut',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dage',
            M : 'en mned',
            MM : '%d mneder',
            y : 'et r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : austrian german (de-at)
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elensle: https://github.com/Oire
    //! author : Martin Groller : https://github.com/MadMG

    function de_at__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de_at = _moment__default.defineLocale('de-at', {
        months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[Morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[Gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : de_at__processRelativeTime,
            mm : '%d Minuten',
            h : de_at__processRelativeTime,
            hh : '%d Stunden',
            d : de_at__processRelativeTime,
            dd : de_at__processRelativeTime,
            M : de_at__processRelativeTime,
            MM : de_at__processRelativeTime,
            y : de_at__processRelativeTime,
            yy : de_at__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : german (de)
    //! author : lluchs : https://github.com/lluchs
    //! author: Menelion Elensle: https://github.com/Oire

    function de__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eine Minute', 'einer Minute'],
            'h': ['eine Stunde', 'einer Stunde'],
            'd': ['ein Tag', 'einem Tag'],
            'dd': [number + ' Tage', number + ' Tagen'],
            'M': ['ein Monat', 'einem Monat'],
            'MM': [number + ' Monate', number + ' Monaten'],
            'y': ['ein Jahr', 'einem Jahr'],
            'yy': [number + ' Jahre', number + ' Jahren']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }

    var de = _moment__default.defineLocale('de', {
        months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
        weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
        weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
        longDateFormat : {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY HH:mm',
            LLLL : 'dddd, D. MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Heute um] LT [Uhr]',
            sameElse: 'L',
            nextDay: '[Morgen um] LT [Uhr]',
            nextWeek: 'dddd [um] LT [Uhr]',
            lastDay: '[Gestern um] LT [Uhr]',
            lastWeek: '[letzten] dddd [um] LT [Uhr]'
        },
        relativeTime : {
            future : 'in %s',
            past : 'vor %s',
            s : 'ein paar Sekunden',
            m : de__processRelativeTime,
            mm : '%d Minuten',
            h : de__processRelativeTime,
            hh : '%d Stunden',
            d : de__processRelativeTime,
            dd : de__processRelativeTime,
            M : de__processRelativeTime,
            MM : de__processRelativeTime,
            y : de__processRelativeTime,
            yy : de__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : modern greek (el)
    //! author : Aggelos Karalias : https://github.com/mehiel

    var el = _moment__default.defineLocale('el', {
        monthsNominativeEl : '___________'.split('_'),
        monthsGenitiveEl : '___________'.split('_'),
        months : function (momentToFormat, format) {
            if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
                return this._monthsGenitiveEl[momentToFormat.month()];
            } else {
                return this._monthsNominativeEl[momentToFormat.month()];
            }
        },
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '' : '';
            } else {
                return isLower ? '' : '';
            }
        },
        isPM : function (input) {
            return ((input + '').toLowerCase()[0] === '');
        },
        meridiemParse : /[]\.??\.?/i,
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendarEl : {
            sameDay : '[ {}] LT',
            nextDay : '[ {}] LT',
            nextWeek : 'dddd [{}] LT',
            lastDay : '[ {}] LT',
            lastWeek : function () {
                switch (this.day()) {
                    case 6:
                        return '[ ] dddd [{}] LT';
                    default:
                        return '[ ] dddd [{}] LT';
                }
            },
            sameElse : 'L'
        },
        calendar : function (key, mom) {
            var output = this._calendarEl[key],
                hours = mom && mom.hours();
            if (typeof output === 'function') {
                output = output.apply(mom);
            }
            return output.replace('{}', (hours % 12 === 1 ? '' : ''));
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : australian english (en-au)

    var en_au = _moment__default.defineLocale('en-au', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : canadian english (en-ca)
    //! author : Jonathan Abourbih : https://github.com/jonbca

    var en_ca = _moment__default.defineLocale('en-ca', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM, YYYY',
            LLL : 'D MMMM, YYYY h:mm A',
            LLLL : 'dddd, D MMMM, YYYY h:mm A'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    //! moment.js locale configuration
    //! locale : great britain english (en-gb)
    //! author : Chris Gedrim : https://github.com/chrisgedrim

    var en_gb = _moment__default.defineLocale('en-gb', {
        months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },
        ordinalParse: /\d{1,2}(st|nd|rd|th)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : esperanto (eo)
    //! author : Colin Dean : https://github.com/colindean
    //! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
    //!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!

    var eo = _moment__default.defineLocale('eo', {
        months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
        weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
        weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D[-an de] MMMM, YYYY',
            LLL : 'D[-an de] MMMM, YYYY HH:mm',
            LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
        },
        meridiemParse: /[ap]\.t\.m/i,
        isPM: function (input) {
            return input.charAt(0).toLowerCase() === 'p';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'p.t.m.' : 'P.T.M.';
            } else {
                return isLower ? 'a.t.m.' : 'A.T.M.';
            }
        },
        calendar : {
            sameDay : '[Hodia je] LT',
            nextDay : '[Morga je] LT',
            nextWeek : 'dddd [je] LT',
            lastDay : '[Hiera je] LT',
            lastWeek : '[pasinta] dddd [je] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'je %s',
            past : 'anta %s',
            s : 'sekundoj',
            m : 'minuto',
            mm : '%d minutoj',
            h : 'horo',
            hh : '%d horoj',
            d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
            dd : '%d tagoj',
            M : 'monato',
            MM : '%d monatoj',
            y : 'jaro',
            yy : '%d jaroj'
        },
        ordinalParse: /\d{1,2}a/,
        ordinal : '%da',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : spanish (es)
    //! author : Julio Napur : https://github.com/julionc

    var monthsShortDot = 'Ene._Feb._Mar._Abr._May._Jun._Jul._Ago._Sep._Oct._Nov._Dic.'.split('_'),
        es__monthsShort = 'Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic'.split('_');

    var es = _moment__default.defineLocale('es', {
        months : 'Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembre'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return es__monthsShort[m.month()];
            } else {
                return monthsShortDot[m.month()];
            }
        },
        weekdays : 'Domingo_Lunes_Martes_Mircoles_Jueves_Viernes_Sbado'.split('_'),
        weekdaysShort : 'Dom._Lun._Mar._Mi._Jue._Vie._Sb.'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_Mi_Ju_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY H:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastDay : function () {
                return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            lastWeek : function () {
                return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'en %s',
            past : 'hace %s',
            s : 'unos segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'una hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ao',
            yy : '%d aos'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : estonian (et)
    //! author : Henry Kehlmann : https://github.com/madhenry
    //! improvements : Illimar Tambek : https://github.com/ragulka

    function et__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
            'm' : ['he minuti', 'ks minut'],
            'mm': [number + ' minuti', number + ' minutit'],
            'h' : ['he tunni', 'tund aega', 'ks tund'],
            'hh': [number + ' tunni', number + ' tundi'],
            'd' : ['he peva', 'ks pev'],
            'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
            'MM': [number + ' kuu', number + ' kuud'],
            'y' : ['he aasta', 'aasta', 'ks aasta'],
            'yy': [number + ' aasta', number + ' aastat']
        };
        if (withoutSuffix) {
            return format[key][2] ? format[key][2] : format[key][1];
        }
        return isFuture ? format[key][0] : format[key][1];
    }

    var et = _moment__default.defineLocale('et', {
        months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
        monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
        weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
        weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
        weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
        longDateFormat : {
            LT   : 'H:mm',
            LTS : 'H:mm:ss',
            L    : 'DD.MM.YYYY',
            LL   : 'D. MMMM YYYY',
            LLL  : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[Tna,] LT',
            nextDay  : '[Homme,] LT',
            nextWeek : '[Jrgmine] dddd LT',
            lastDay  : '[Eile,] LT',
            lastWeek : '[Eelmine] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s prast',
            past   : '%s tagasi',
            s      : et__processRelativeTime,
            m      : et__processRelativeTime,
            mm     : et__processRelativeTime,
            h      : et__processRelativeTime,
            hh     : et__processRelativeTime,
            d      : et__processRelativeTime,
            dd     : '%d peva',
            M      : et__processRelativeTime,
            MM     : et__processRelativeTime,
            y      : et__processRelativeTime,
            yy     : et__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : euskara (eu)
    //! author : Eneko Illarramendi : https://github.com/eillarra

    var eu = _moment__default.defineLocale('eu', {
        months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
        monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
        weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
        weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
        weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY[ko] MMMM[ren] D[a]',
            LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
            LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
            l : 'YYYY-M-D',
            ll : 'YYYY[ko] MMM D[a]',
            lll : 'YYYY[ko] MMM D[a] HH:mm',
            llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
        },
        calendar : {
            sameDay : '[gaur] LT[etan]',
            nextDay : '[bihar] LT[etan]',
            nextWeek : 'dddd LT[etan]',
            lastDay : '[atzo] LT[etan]',
            lastWeek : '[aurreko] dddd LT[etan]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s barru',
            past : 'duela %s',
            s : 'segundo batzuk',
            m : 'minutu bat',
            mm : '%d minutu',
            h : 'ordu bat',
            hh : '%d ordu',
            d : 'egun bat',
            dd : '%d egun',
            M : 'hilabete bat',
            MM : '%d hilabete',
            y : 'urte bat',
            yy : '%d urte'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Persian (fa)
    //! author : Ebrahim Byagowi : https://github.com/ebraminio

    var fa__symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, fa__numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var fa = _moment__default.defineLocale('fa', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        meridiemParse: /  |  /,
        isPM: function (input) {
            return /  /.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '  ';
            } else {
                return '  ';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : 'dddd [] [] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[-]/g, function (match) {
                return fa__numberMap[match];
            }).replace(//g, ',');
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return fa__symbolMap[match];
            }).replace(/,/g, '');
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12 // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : finnish (fi)
    //! author : Tarmo Aidantausta : https://github.com/bleadof

    var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
        numbersFuture = [
            'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
            numbersPast[7], numbersPast[8], numbersPast[9]
        ];
    function fi__translate(number, withoutSuffix, key, isFuture) {
        var result = '';
        switch (key) {
        case 's':
            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
        case 'm':
            return isFuture ? 'minuutin' : 'minuutti';
        case 'mm':
            result = isFuture ? 'minuutin' : 'minuuttia';
            break;
        case 'h':
            return isFuture ? 'tunnin' : 'tunti';
        case 'hh':
            result = isFuture ? 'tunnin' : 'tuntia';
            break;
        case 'd':
            return isFuture ? 'pivn' : 'piv';
        case 'dd':
            result = isFuture ? 'pivn' : 'piv';
            break;
        case 'M':
            return isFuture ? 'kuukauden' : 'kuukausi';
        case 'MM':
            result = isFuture ? 'kuukauden' : 'kuukautta';
            break;
        case 'y':
            return isFuture ? 'vuoden' : 'vuosi';
        case 'yy':
            result = isFuture ? 'vuoden' : 'vuotta';
            break;
        }
        result = verbalNumber(number, isFuture) + ' ' + result;
        return result;
    }
    function verbalNumber(number, isFuture) {
        return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
    }

    var fi = _moment__default.defineLocale('fi', {
        months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
        monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
        weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
        weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
        weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'Do MMMM[ta] YYYY',
            LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
            LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
            l : 'D.M.YYYY',
            ll : 'Do MMM YYYY',
            lll : 'Do MMM YYYY, [klo] HH.mm',
            llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
        },
        calendar : {
            sameDay : '[tnn] [klo] LT',
            nextDay : '[huomenna] [klo] LT',
            nextWeek : 'dddd [klo] LT',
            lastDay : '[eilen] [klo] LT',
            lastWeek : '[viime] dddd[na] [klo] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s pst',
            past : '%s sitten',
            s : fi__translate,
            m : fi__translate,
            mm : fi__translate,
            h : fi__translate,
            hh : fi__translate,
            d : fi__translate,
            dd : fi__translate,
            M : fi__translate,
            MM : fi__translate,
            y : fi__translate,
            yy : fi__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : faroese (fo)
    //! author : Ragnar Johannesen : https://github.com/ragnar123

    var fo = _moment__default.defineLocale('fo', {
        months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
        weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
        weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D. MMMM, YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgin kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gjr kl.] LT',
            lastWeek : '[sstu] dddd [kl] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'um %s',
            past : '%s sani',
            s : 'f sekund',
            m : 'ein minutt',
            mm : '%d minuttir',
            h : 'ein tmi',
            hh : '%d tmar',
            d : 'ein dagur',
            dd : '%d dagar',
            M : 'ein mnai',
            MM : '%d mnair',
            y : 'eitt r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : canadian french (fr-ca)
    //! author : Jonathan Abourbih : https://github.com/jonbca

    var fr_ca = _moment__default.defineLocale('fr-ca', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|e)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : 'e');
        }
    });

    //! moment.js locale configuration
    //! locale : french (fr)
    //! author : John Fischer : https://github.com/jfroffice

    var fr = _moment__default.defineLocale('fr', {
        months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
        monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
        weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
        weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
        weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Aujourd\'hui ] LT',
            nextDay: '[Demain ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[Hier ] LT',
            lastWeek: 'dddd [dernier ] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dans %s',
            past : 'il y a %s',
            s : 'quelques secondes',
            m : 'une minute',
            mm : '%d minutes',
            h : 'une heure',
            hh : '%d heures',
            d : 'un jour',
            dd : '%d jours',
            M : 'un mois',
            MM : '%d mois',
            y : 'un an',
            yy : '%d ans'
        },
        ordinalParse: /\d{1,2}(er|)/,
        ordinal : function (number) {
            return number + (number === 1 ? 'er' : '');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : frisian (fy)
    //! author : Robin van der Vliet : https://github.com/robin0van0der0v

    var fy__monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
        fy__monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');

    var fy = _moment__default.defineLocale('fy', {
        months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return fy__monthsShortWithoutDots[m.month()];
            } else {
                return fy__monthsShortWithDots[m.month()];
            }
        },
        weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
        weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
        weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[hjoed om] LT',
            nextDay: '[moarn om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[juster om] LT',
            lastWeek: '[frne] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'oer %s',
            past : '%s lyn',
            s : 'in pear sekonden',
            m : 'ien mint',
            mm : '%d minuten',
            h : 'ien oere',
            hh : '%d oeren',
            d : 'ien dei',
            dd : '%d dagen',
            M : 'ien moanne',
            MM : '%d moannen',
            y : 'ien jier',
            yy : '%d jierren'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : galician (gl)
    //! author : Juan G. Hurtado : https://github.com/juanghurtado

    var gl = _moment__default.defineLocale('gl', {
        months : 'Xaneiro_Febreiro_Marzo_Abril_Maio_Xuo_Xullo_Agosto_Setembro_Outubro_Novembro_Decembro'.split('_'),
        monthsShort : 'Xan._Feb._Mar._Abr._Mai._Xu._Xul._Ago._Set._Out._Nov._Dec.'.split('_'),
        weekdays : 'Domingo_Luns_Martes_Mrcores_Xoves_Venres_Sbado'.split('_'),
        weekdaysShort : 'Dom._Lun._Mar._Mr._Xov._Ven._Sb.'.split('_'),
        weekdaysMin : 'Do_Lu_Ma_M_Xo_Ve_S'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : function () {
                return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextDay : function () {
                return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
            },
            nextWeek : function () {
                return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            lastDay : function () {
                return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
            },
            lastWeek : function () {
                return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : function (str) {
                if (str === 'uns segundos') {
                    return 'nuns segundos';
                }
                return 'en ' + str;
            },
            past : 'hai %s',
            s : 'uns segundos',
            m : 'un minuto',
            mm : '%d minutos',
            h : 'unha hora',
            hh : '%d horas',
            d : 'un da',
            dd : '%d das',
            M : 'un mes',
            MM : '%d meses',
            y : 'un ano',
            yy : '%d anos'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Hebrew (he)
    //! author : Tomer Cohen : https://github.com/tomer
    //! author : Moshe Simantov : https://github.com/DevelopmentIL
    //! author : Tal Ater : https://github.com/TalAter

    var he = _moment__default.defineLocale('he', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D []MMMM YYYY',
            LLL : 'D []MMMM YYYY HH:mm',
            LLLL : 'dddd, D []MMMM YYYY HH:mm',
            l : 'D/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[ ]LT',
            nextDay : '[ ]LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ]LT',
            lastWeek : '[] dddd [ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            d : '',
            dd : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            M : '',
            MM : function (number) {
                if (number === 2) {
                    return '';
                }
                return number + ' ';
            },
            y : '',
            yy : function (number) {
                if (number === 2) {
                    return '';
                } else if (number % 10 === 0 && number !== 10) {
                    return number + ' ';
                }
                return number + ' ';
            }
        }
    });

    //! moment.js locale configuration
    //! locale : hindi (hi)
    //! author : Mayank Singhal : https://github.com/mayanksinghal

    var hi__symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    hi__numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var hi = _moment__default.defineLocale('hi', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return hi__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return hi__symbolMap[match];
            });
        },
        // Hindi notation for meridiems are quite fuzzy in practice. While there exists
        // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : hrvatski (hr)
    //! author : Bojan Markovi : https://github.com/bmarkovic

    function hr__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
        case 'mm':
            if (number === 1) {
                result += 'minuta';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'minute';
            } else {
                result += 'minuta';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'jedan sat' : 'jednog sata';
        case 'hh':
            if (number === 1) {
                result += 'sat';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'sata';
            } else {
                result += 'sati';
            }
            return result;
        case 'dd':
            if (number === 1) {
                result += 'dan';
            } else {
                result += 'dana';
            }
            return result;
        case 'MM':
            if (number === 1) {
                result += 'mjesec';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'mjeseca';
            } else {
                result += 'mjeseci';
            }
            return result;
        case 'yy':
            if (number === 1) {
                result += 'godina';
            } else if (number === 2 || number === 3 || number === 4) {
                result += 'godine';
            } else {
                result += 'godina';
            }
            return result;
        }
    }

    var hr = _moment__default.defineLocale('hr', {
        months : 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_'),
        monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
        weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
        weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
        weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danas u] LT',
            nextDay  : '[sutra u] LT',
            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[juer u] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                    return '[prolu] dddd [u] LT';
                case 6:
                    return '[prole] [subote] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[proli] dddd [u] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'par sekundi',
            m      : hr__translate,
            mm     : hr__translate,
            h      : hr__translate,
            hh     : hr__translate,
            d      : 'dan',
            dd     : hr__translate,
            M      : 'mjesec',
            MM     : hr__translate,
            y      : 'godinu',
            yy     : hr__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : hungarian (hu)
    //! author : Adam Brunner : https://github.com/adambrunner

    var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
    function hu__translate(number, withoutSuffix, key, isFuture) {
        var num = number,
            suffix;
        switch (key) {
        case 's':
            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
        case 'm':
            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'mm':
            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
        case 'h':
            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'hh':
            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
        case 'd':
            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'dd':
            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
        case 'M':
            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'MM':
            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
        case 'y':
            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
        case 'yy':
            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
        }
        return '';
    }
    function week(isFuture) {
        return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
    }

    var hu = _moment__default.defineLocale('hu', {
        months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
        monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
        weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
        weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
        weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'YYYY.MM.DD.',
            LL : 'YYYY. MMMM D.',
            LLL : 'YYYY. MMMM D. H:mm',
            LLLL : 'YYYY. MMMM D., dddd H:mm'
        },
        meridiemParse: /de|du/i,
        isPM: function (input) {
            return input.charAt(1).toLowerCase() === 'u';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 12) {
                return isLower === true ? 'de' : 'DE';
            } else {
                return isLower === true ? 'du' : 'DU';
            }
        },
        calendar : {
            sameDay : '[ma] LT[-kor]',
            nextDay : '[holnap] LT[-kor]',
            nextWeek : function () {
                return week.call(this, true);
            },
            lastDay : '[tegnap] LT[-kor]',
            lastWeek : function () {
                return week.call(this, false);
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s mlva',
            past : '%s',
            s : hu__translate,
            m : hu__translate,
            mm : hu__translate,
            h : hu__translate,
            hh : hu__translate,
            d : hu__translate,
            dd : hu__translate,
            M : hu__translate,
            MM : hu__translate,
            y : hu__translate,
            yy : hu__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Armenian (hy-am)
    //! author : Armendarabyan : https://github.com/armendarabyan

    function hy_am__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function hy_am__monthsShortCaseReplace(m, format) {
        var monthsShort = '___________'.split('_');
        return monthsShort[m.month()];
    }
    function hy_am__weekdaysCaseReplace(m, format) {
        var weekdays = '______'.split('_');
        return weekdays[m.day()];
    }

    var hy_am = _moment__default.defineLocale('hy-am', {
        months : hy_am__monthsCaseReplace,
        monthsShort : hy_am__monthsShortCaseReplace,
        weekdays : hy_am__weekdaysCaseReplace,
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[] LT',
            nextDay: '[] LT',
            lastDay: '[] LT',
            nextWeek: function () {
                return 'dddd [ ] LT';
            },
            lastWeek: function () {
                return '[] dddd [ ] LT';
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}|\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'DDD':
            case 'w':
            case 'W':
            case 'DDDo':
                if (number === 1) {
                    return number + '-';
                }
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bahasa Indonesia (id)
    //! author : Mohammad Satrio Utomo : https://github.com/tyok
    //! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan

    var id = _moment__default.defineLocale('id', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
        weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|siang|sore|malam/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'siang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sore' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'siang';
            } else if (hours < 19) {
                return 'sore';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Besok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kemarin pukul] LT',
            lastWeek : 'dddd [lalu pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lalu',
            s : 'beberapa detik',
            m : 'semenit',
            mm : '%d menit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : icelandic (is)
    //! author : Hinrik rn Sigursson : https://github.com/hinrik

    function is__plural(n) {
        if (n % 100 === 11) {
            return true;
        } else if (n % 10 === 1) {
            return false;
        }
        return true;
    }
    function is__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
        case 'm':
            return withoutSuffix ? 'mnta' : 'mntu';
        case 'mm':
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
            } else if (withoutSuffix) {
                return result + 'mnta';
            }
            return result + 'mntu';
        case 'hh':
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
            }
            return result + 'klukkustund';
        case 'd':
            if (withoutSuffix) {
                return 'dagur';
            }
            return isFuture ? 'dag' : 'degi';
        case 'dd':
            if (is__plural(number)) {
                if (withoutSuffix) {
                    return result + 'dagar';
                }
                return result + (isFuture ? 'daga' : 'dgum');
            } else if (withoutSuffix) {
                return result + 'dagur';
            }
            return result + (isFuture ? 'dag' : 'degi');
        case 'M':
            if (withoutSuffix) {
                return 'mnuur';
            }
            return isFuture ? 'mnu' : 'mnui';
        case 'MM':
            if (is__plural(number)) {
                if (withoutSuffix) {
                    return result + 'mnuir';
                }
                return result + (isFuture ? 'mnui' : 'mnuum');
            } else if (withoutSuffix) {
                return result + 'mnuur';
            }
            return result + (isFuture ? 'mnu' : 'mnui');
        case 'y':
            return withoutSuffix || isFuture ? 'r' : 'ri';
        case 'yy':
            if (is__plural(number)) {
                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
            }
            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
        }
    }

    var is = _moment__default.defineLocale('is', {
        months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
        weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
        weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
        weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H:mm',
            LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
        },
        calendar : {
            sameDay : '[ dag kl.] LT',
            nextDay : '[ morgun kl.] LT',
            nextWeek : 'dddd [kl.] LT',
            lastDay : '[ gr kl.] LT',
            lastWeek : '[sasta] dddd [kl.] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'eftir %s',
            past : 'fyrir %s san',
            s : is__translate,
            m : is__translate,
            mm : is__translate,
            h : 'klukkustund',
            hh : is__translate,
            d : is__translate,
            dd : is__translate,
            M : is__translate,
            MM : is__translate,
            y : is__translate,
            yy : is__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : italian (it)
    //! author : Lorenzo : https://github.com/aliem
    //! author: Mattia Larentis: https://github.com/nostalgiaz

    var it = _moment__default.defineLocale('it', {
        months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
        monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
        weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
        weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
        weekdaysMin : 'D_L_Ma_Me_G_V_S'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Oggi alle] LT',
            nextDay: '[Domani alle] LT',
            nextWeek: 'dddd [alle] LT',
            lastDay: '[Ieri alle] LT',
            lastWeek: function () {
                switch (this.day()) {
                    case 0:
                        return '[la scorsa] dddd [alle] LT';
                    default:
                        return '[lo scorso] dddd [alle] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : function (s) {
                return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
            },
            past : '%s fa',
            s : 'alcuni secondi',
            m : 'un minuto',
            mm : '%d minuti',
            h : 'un\'ora',
            hh : '%d ore',
            d : 'un giorno',
            dd : '%d giorni',
            M : 'un mese',
            MM : '%d mesi',
            y : 'un anno',
            yy : '%d anni'
        },
        ordinalParse : /\d{1,2}/,
        ordinal: '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : japanese (ja)
    //! author : LI Long : https://github.com/baryon

    var ja = _moment__default.defineLocale('ja', {
        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'Ahm',
            LTS : 'Ahms',
            L : 'YYYY/MM/DD',
            LL : 'YYYYMD',
            LLL : 'YYYYMDAhm',
            LLLL : 'YYYYMDAhm dddd'
        },
        meridiemParse: /|/i,
        isPM : function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[]dddd LT',
            lastDay : '[] LT',
            lastWeek : '[]dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            m : '1',
            mm : '%d',
            h : '1',
            hh : '%d',
            d : '1',
            dd : '%d',
            M : '1',
            MM : '%d',
            y : '1',
            yy : '%d'
        }
    });

    //! moment.js locale configuration
    //! locale : Boso Jowo (jv)
    //! author : Rony Lantip : https://github.com/lantip
    //! reference: http://jv.wikipedia.org/wiki/Basa_Jawa

    var jv = _moment__default.defineLocale('jv', {
        months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
        monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
        weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
        weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
        weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /enjing|siyang|sonten|ndalu/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'enjing') {
                return hour;
            } else if (meridiem === 'siyang') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'enjing';
            } else if (hours < 15) {
                return 'siyang';
            } else if (hours < 19) {
                return 'sonten';
            } else {
                return 'ndalu';
            }
        },
        calendar : {
            sameDay : '[Dinten puniko pukul] LT',
            nextDay : '[Mbenjang pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kala wingi pukul] LT',
            lastWeek : 'dddd [kepengker pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'wonten ing %s',
            past : '%s ingkang kepengker',
            s : 'sawetawis detik',
            m : 'setunggal menit',
            mm : '%d menit',
            h : 'setunggal jam',
            hh : '%d jam',
            d : 'sedinten',
            dd : '%d dinten',
            M : 'sewulan',
            MM : '%d wulan',
            y : 'setaun',
            yy : '%d taun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Georgian (ka)
    //! author : Irakli Janiashvili : https://github.com/irakli-janiashvili

    function ka__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        },
        nounCase = (/D[oD] *MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function ka__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_')
        },
        nounCase = (/(|)/).test(format) ?
            'accusative' :
            'nominative';
        return weekdays[nounCase][m.day()];
    }

    var ka = _moment__default.defineLocale('ka', {
        months : ka__monthsCaseReplace,
        monthsShort : '___________'.split('_'),
        weekdays : ka__weekdaysCaseReplace,
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'h:mm A',
            LTS : 'h:mm:ss A',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY h:mm A',
            LLLL : 'dddd, D MMMM YYYY h:mm A'
        },
        calendar : {
            sameDay : '[] LT[-]',
            nextDay : '[] LT[-]',
            lastDay : '[] LT[-]',
            nextWeek : '[] dddd LT[-]',
            lastWeek : '[] dddd LT-',
            sameElse : 'L'
        },
        relativeTime : {
            future : function (s) {
                return (/(|||)/).test(s) ?
                    s.replace(/$/, '') :
                    s + '';
            },
            past : function (s) {
                if ((/(||||)/).test(s)) {
                    return s.replace(/(|)$/, ' ');
                }
                if ((//).test(s)) {
                    return s.replace(/$/, ' ');
                }
            },
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        ordinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
        ordinal : function (number) {
            if (number === 0) {
                return number;
            }
            if (number === 1) {
                return number + '-';
            }
            if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
                return '-' + number;
            }
            return number + '-';
        },
        week : {
            dow : 1,
            doy : 7
        }
    });

    //! moment.js locale configuration
    //! locale : khmer (km)
    //! author : Kruy Vanna : https://github.com/kruyvanna

    var km = _moment__default.defineLocale('km', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),
        longDateFormat: {
            LT: 'HH:mm',
            LTS : 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd, D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] [] LT',
            sameElse: 'L'
        },
        relativeTime: {
            future: '%s',
            past: '%s',
            s: '',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : korean (ko)
    //!
    //! authors
    //!
    //! - Kyungwook, Park : https://github.com/kyungw00k
    //! - Jeeeyul Lee <jeeeyul@gmail.com>

    var ko = _moment__default.defineLocale('ko', {
        months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h m',
            LTS : 'A h m s',
            L : 'YYYY.MM.DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D A h m',
            LLLL : 'YYYY MMMM D dddd A h m'
        },
        calendar : {
            sameDay : ' LT',
            nextDay : ' LT',
            nextWeek : 'dddd LT',
            lastDay : ' LT',
            lastWeek : ' dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '',
            ss : '%d',
            m : '',
            mm : '%d',
            h : '',
            hh : '%d',
            d : '',
            dd : '%d',
            M : '',
            MM : '%d',
            y : '',
            yy : '%d'
        },
        ordinalParse : /\d{1,2}/,
        ordinal : '%d',
        meridiemParse : /|/,
        isPM : function (token) {
            return token === '';
        },
        meridiem : function (hour, minute, isUpper) {
            return hour < 12 ? '' : '';
        }
    });

    //! moment.js locale configuration
    //! locale : Luxembourgish (lb)
    //! author : mweimerskirch : https://github.com/mweimerskirch, David Raison : https://github.com/kwisatz

    function lb__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            'm': ['eng Minutt', 'enger Minutt'],
            'h': ['eng Stonn', 'enger Stonn'],
            'd': ['een Dag', 'engem Dag'],
            'M': ['ee Mount', 'engem Mount'],
            'y': ['ee Joer', 'engem Joer']
        };
        return withoutSuffix ? format[key][0] : format[key][1];
    }
    function processFutureTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'a ' + string;
        }
        return 'an ' + string;
    }
    function processPastTime(string) {
        var number = string.substr(0, string.indexOf(' '));
        if (eifelerRegelAppliesToNumber(number)) {
            return 'viru ' + string;
        }
        return 'virun ' + string;
    }
    /**
     * Returns true if the word before the given number loses the '-n' ending.
     * e.g. 'an 10 Deeg' but 'a 5 Deeg'
     *
     * @param number {integer}
     * @returns {boolean}
     */
    function eifelerRegelAppliesToNumber(number) {
        number = parseInt(number, 10);
        if (isNaN(number)) {
            return false;
        }
        if (number < 0) {
            // Negative Number --> always true
            return true;
        } else if (number < 10) {
            // Only 1 digit
            if (4 <= number && number <= 7) {
                return true;
            }
            return false;
        } else if (number < 100) {
            // 2 digits
            var lastDigit = number % 10, firstDigit = number / 10;
            if (lastDigit === 0) {
                return eifelerRegelAppliesToNumber(firstDigit);
            }
            return eifelerRegelAppliesToNumber(lastDigit);
        } else if (number < 10000) {
            // 3 or 4 digits --> recursively check first digit
            while (number >= 10) {
                number = number / 10;
            }
            return eifelerRegelAppliesToNumber(number);
        } else {
            // Anything larger than 4 digits: recursively check first n-3 digits
            number = number / 1000;
            return eifelerRegelAppliesToNumber(number);
        }
    }

    var lb = _moment__default.defineLocale('lb', {
        months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
        monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
        weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
        weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
        weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
        longDateFormat: {
            LT: 'H:mm [Auer]',
            LTS: 'H:mm:ss [Auer]',
            L: 'DD.MM.YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm [Auer]',
            LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
        },
        calendar: {
            sameDay: '[Haut um] LT',
            sameElse: 'L',
            nextDay: '[Muer um] LT',
            nextWeek: 'dddd [um] LT',
            lastDay: '[Gschter um] LT',
            lastWeek: function () {
                // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
                switch (this.day()) {
                    case 2:
                    case 4:
                        return '[Leschten] dddd [um] LT';
                    default:
                        return '[Leschte] dddd [um] LT';
                }
            }
        },
        relativeTime : {
            future : processFutureTime,
            past : processPastTime,
            s : 'e puer Sekonnen',
            m : lb__processRelativeTime,
            mm : '%d Minutten',
            h : lb__processRelativeTime,
            hh : '%d Stonnen',
            d : lb__processRelativeTime,
            dd : '%d Deeg',
            M : lb__processRelativeTime,
            MM : '%d Mint',
            y : lb__processRelativeTime,
            yy : '%d Joer'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal: '%d.',
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Lithuanian (lt)
    //! author : Mindaugas Mozras : https://github.com/mmozuras

    var lt__units = {
        'm' : 'minut_minuts_minut',
        'mm': 'minuts_minui_minutes',
        'h' : 'valanda_valandos_valand',
        'hh': 'valandos_valand_valandas',
        'd' : 'diena_dienos_dien',
        'dd': 'dienos_dien_dienas',
        'M' : 'mnuo_mnesio_mnes',
        'MM': 'mnesiai_mnesi_mnesius',
        'y' : 'metai_met_metus',
        'yy': 'metai_met_metus'
    },
    weekDays = 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_');
    function translateSeconds(number, withoutSuffix, key, isFuture) {
        if (withoutSuffix) {
            return 'kelios sekunds';
        } else {
            return isFuture ? 'keli sekundi' : 'kelias sekundes';
        }
    }
    function lt__monthsCaseReplace(m, format) {
        var months = {
                'nominative': 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
                'accusative': 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_')
            },
            nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
                'accusative' :
                'nominative';
        return months[nounCase][m.month()];
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
        return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
    }
    function special(number) {
        return number % 10 === 0 || (number > 10 && number < 20);
    }
    function forms(key) {
        return lt__units[key].split('_');
    }
    function lt__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        if (number === 1) {
            return result + translateSingular(number, withoutSuffix, key[0], isFuture);
        } else if (withoutSuffix) {
            return result + (special(number) ? forms(key)[1] : forms(key)[0]);
        } else {
            if (isFuture) {
                return result + forms(key)[1];
            } else {
                return result + (special(number) ? forms(key)[1] : forms(key)[2]);
            }
        }
    }
    function relativeWeekDay(moment, format) {
        var nominative = format.indexOf('dddd HH:mm') === -1,
            weekDay = weekDays[moment.day()];
        return nominative ? weekDay : weekDay.substring(0, weekDay.length - 2) + '';
    }

    var lt = _moment__default.defineLocale('lt', {
        months : lt__monthsCaseReplace,
        monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
        weekdays : relativeWeekDay,
        weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
        weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'YYYY [m.] MMMM D [d.]',
            LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
            l : 'YYYY-MM-DD',
            ll : 'YYYY [m.] MMMM D [d.]',
            lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
            llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
        },
        calendar : {
            sameDay : '[iandien] LT',
            nextDay : '[Rytoj] LT',
            nextWeek : 'dddd LT',
            lastDay : '[Vakar] LT',
            lastWeek : '[Prajus] dddd LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'po %s',
            past : 'prie %s',
            s : translateSeconds,
            m : translateSingular,
            mm : lt__translate,
            h : translateSingular,
            hh : lt__translate,
            d : translateSingular,
            dd : lt__translate,
            M : translateSingular,
            MM : lt__translate,
            y : translateSingular,
            yy : lt__translate
        },
        ordinalParse: /\d{1,2}-oji/,
        ordinal : function (number) {
            return number + '-oji';
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : latvian (lv)
    //! author : Kristaps Karlsons : https://github.com/skakri
    //! author : Jnis Elmeris : https://github.com/JanisE

    var lv__units = {
        'm': 'mintes_mintm_minte_mintes'.split('_'),
        'mm': 'mintes_mintm_minte_mintes'.split('_'),
        'h': 'stundas_stundm_stunda_stundas'.split('_'),
        'hh': 'stundas_stundm_stunda_stundas'.split('_'),
        'd': 'dienas_dienm_diena_dienas'.split('_'),
        'dd': 'dienas_dienm_diena_dienas'.split('_'),
        'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
        'y': 'gada_gadiem_gads_gadi'.split('_'),
        'yy': 'gada_gadiem_gads_gadi'.split('_')
    };
    /**
     * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
     */
    function lv__format(forms, number, withoutSuffix) {
        if (withoutSuffix) {
            // E.g. "21 minte", "3 mintes".
            return number % 10 === 1 && number !== 11 ? forms[2] : forms[3];
        } else {
            // E.g. "21 mintes" as in "pc 21 mintes".
            // E.g. "3 mintm" as in "pc 3 mintm".
            return number % 10 === 1 && number !== 11 ? forms[0] : forms[1];
        }
    }
    function lv__relativeTimeWithPlural(number, withoutSuffix, key) {
        return number + ' ' + lv__format(lv__units[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
        return lv__format(lv__units[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
        return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
    }

    var lv = _moment__default.defineLocale('lv', {
        months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
        weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
        weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY.',
            LL : 'YYYY. [gada] D. MMMM',
            LLL : 'YYYY. [gada] D. MMMM, HH:mm',
            LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
        },
        calendar : {
            sameDay : '[odien pulksten] LT',
            nextDay : '[Rt pulksten] LT',
            nextWeek : 'dddd [pulksten] LT',
            lastDay : '[Vakar pulksten] LT',
            lastWeek : '[Pagju] dddd [pulksten] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'pc %s',
            past : 'pirms %s',
            s : relativeSeconds,
            m : relativeTimeWithSingular,
            mm : lv__relativeTimeWithPlural,
            h : relativeTimeWithSingular,
            hh : lv__relativeTimeWithPlural,
            d : relativeTimeWithSingular,
            dd : lv__relativeTimeWithPlural,
            M : relativeTimeWithSingular,
            MM : lv__relativeTimeWithPlural,
            y : relativeTimeWithSingular,
            yy : lv__relativeTimeWithPlural
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Montenegrin (me)
    //! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac

    var me__translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jednog minuta'],
            mm: ['minut', 'minuta', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mjesec', 'mjeseca', 'mjeseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = me__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + me__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var me = _moment__default.defineLocale('me', {
        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
        weekdays: ['nedjelja', 'ponedjeljak', 'utorak', 'srijeda', 'etvrtak', 'petak', 'subota'],
        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sri.', 'et.', 'pet.', 'sub.'],
        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'e', 'pe', 'su'],
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sjutra u] LT',

            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedjelju] [u] LT';
                case 3:
                    return '[u] [srijedu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedjelje] [u] LT',
                    '[prolog] [ponedjeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srijede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'prije %s',
            s      : 'nekoliko sekundi',
            m      : me__translator.translate,
            mm     : me__translator.translate,
            h      : me__translator.translate,
            hh     : me__translator.translate,
            d      : 'dan',
            dd     : me__translator.translate,
            M      : 'mjesec',
            MM     : me__translator.translate,
            y      : 'godinu',
            yy     : me__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : macedonian (mk)
    //! author : Borislav Mickov : https://github.com/B0k0

    var mk = _moment__default.defineLocale('mk', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : 'e_o_____a'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'D.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ ] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 6:
                    return '[ ] dddd [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[ ] dddd [] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : ' %s',
            s : ' ',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d ',
            M : '',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}-(|||||)/,
        ordinal : function (number) {
            var lastDigit = number % 10,
                last2Digits = number % 100;
            if (number === 0) {
                return number + '-';
            } else if (last2Digits === 0) {
                return number + '-';
            } else if (last2Digits > 10 && last2Digits < 20) {
                return number + '-';
            } else if (lastDigit === 1) {
                return number + '-';
            } else if (lastDigit === 2) {
                return number + '-';
            } else if (lastDigit === 7 || lastDigit === 8) {
                return number + '-';
            } else {
                return number + '-';
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : malayalam (ml)
    //! author : Floyd Pink : https://github.com/floydpink

    var ml = _moment__default.defineLocale('ml', {
        months : '___________'.split('_'),
        monthsShort : '._._._.___._._._._._.'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm -',
            LTS : 'A h:mm:ss -',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm -',
            LLLL : 'dddd, D MMMM YYYY, A h:mm -'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        meridiemParse: /|| ||/i,
        isPM : function (input) {
            return /^( ||)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return ' ';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        }
    });

    //! moment.js locale configuration
    //! locale : Marathi (mr)
    //! author : Harshad Kale : https://github.com/kalehv

    var mr__symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    mr__numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var mr = _moment__default.defineLocale('mr', {
        months : '___________'.split('_'),
        monthsShort: '._._._._._._._._._._._.'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek: '[] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '',
            m: ' ',
            mm: '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return mr__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return mr__symbolMap[match];
            });
        },
        meridiemParse: /|||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 4 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour + 12;
            }
        },
        meridiem: function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 17) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bahasa Malaysia (ms-MY)
    //! author : Weldan Jamili : https://github.com/weldan

    var ms_my = _moment__default.defineLocale('ms-my', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Bahasa Malaysia (ms-MY)
    //! author : Weldan Jamili : https://github.com/weldan

    var locale_ms = _moment__default.defineLocale('ms', {
        months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
        monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
        weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
        weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
        weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'HH.mm.ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY [pukul] HH.mm',
            LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
        },
        meridiemParse: /pagi|tengahari|petang|malam/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === 'pagi') {
                return hour;
            } else if (meridiem === 'tengahari') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === 'petang' || meridiem === 'malam') {
                return hour + 12;
            }
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours < 11) {
                return 'pagi';
            } else if (hours < 15) {
                return 'tengahari';
            } else if (hours < 19) {
                return 'petang';
            } else {
                return 'malam';
            }
        },
        calendar : {
            sameDay : '[Hari ini pukul] LT',
            nextDay : '[Esok pukul] LT',
            nextWeek : 'dddd [pukul] LT',
            lastDay : '[Kelmarin pukul] LT',
            lastWeek : 'dddd [lepas pukul] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'dalam %s',
            past : '%s yang lepas',
            s : 'beberapa saat',
            m : 'seminit',
            mm : '%d minit',
            h : 'sejam',
            hh : '%d jam',
            d : 'sehari',
            dd : '%d hari',
            M : 'sebulan',
            MM : '%d bulan',
            y : 'setahun',
            yy : '%d tahun'
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Burmese (my)
    //! author : Squar team, mysquar.com

    var my__symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    }, my__numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var my = _moment__default.defineLocale('my', {
        months: '___________'.split('_'),
        monthsShort: '___________'.split('_'),
        weekdays: '______'.split('_'),
        weekdaysShort: '______'.split('_'),
        weekdaysMin: '______'.split('_'),

        longDateFormat: {
            LT: 'HH:mm',
            LTS: 'HH:mm:ss',
            L: 'DD/MM/YYYY',
            LL: 'D MMMM YYYY',
            LLL: 'D MMMM YYYY HH:mm',
            LLLL: 'dddd D MMMM YYYY HH:mm'
        },
        calendar: {
            sameDay: '[.] LT []',
            nextDay: '[] LT []',
            nextWeek: 'dddd LT []',
            lastDay: '[.] LT []',
            lastWeek: '[] dddd LT []',
            sameElse: 'L'
        },
        relativeTime: {
            future: ' %s ',
            past: ' %s ',
            s: '.',
            m: '',
            mm: '%d ',
            h: '',
            hh: '%d ',
            d: '',
            dd: '%d ',
            M: '',
            MM: '%d ',
            y: '',
            yy: '%d '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return my__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return my__symbolMap[match];
            });
        },
        week: {
            dow: 1, // Monday is the first day of the week.
            doy: 4 // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : norwegian bokml (nb)
    //! authors : Espen Hovlandsdal : https://github.com/rexxars
    //!           Sigurd Gartmann : https://github.com/sigurdga

    var nb = _moment__default.defineLocale('nb', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_man_tirs_ons_tors_fre_lr'.split('_'),
        weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'H.mm',
            LTS : 'H.mm.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY [kl.] H.mm',
            LLLL : 'dddd D. MMMM YYYY [kl.] H.mm'
        },
        calendar : {
            sameDay: '[i dag kl.] LT',
            nextDay: '[i morgen kl.] LT',
            nextWeek: 'dddd [kl.] LT',
            lastDay: '[i gr kl.] LT',
            lastWeek: '[forrige] dddd [kl.] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'for %s siden',
            s : 'noen sekunder',
            m : 'ett minutt',
            mm : '%d minutter',
            h : 'en time',
            hh : '%d timer',
            d : 'en dag',
            dd : '%d dager',
            M : 'en mned',
            MM : '%d mneder',
            y : 'ett r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : nepali/nepalese
    //! author : suvash : https://github.com/suvash

    var ne__symbolMap = {
        '1': '',
        '2': '',
        '3': '',
        '4': '',
        '5': '',
        '6': '',
        '7': '',
        '8': '',
        '9': '',
        '0': ''
    },
    ne__numberMap = {
        '': '1',
        '': '2',
        '': '3',
        '': '4',
        '': '5',
        '': '6',
        '': '7',
        '': '8',
        '': '9',
        '': '0'
    };

    var ne = _moment__default.defineLocale('ne', {
        months : '___________'.split('_'),
        monthsShort : '._.__.___._._._._._.'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '._._._._._._.'.split('_'),
        weekdaysMin : '._.__._._._.'.split('_'),
        longDateFormat : {
            LT : 'A h:mm ',
            LTS : 'A h:mm:ss ',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, A h:mm ',
            LLLL : 'dddd, D MMMM YYYY, A h:mm '
        },
        preparse: function (string) {
            return string.replace(/[]/g, function (match) {
                return ne__numberMap[match];
            });
        },
        postformat: function (string) {
            return string.replace(/\d/g, function (match) {
                return ne__symbolMap[match];
            });
        },
        meridiemParse: /|||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 3 ? hour : hour + 12;
            } else if (meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 3) {
                return '';
            } else if (hour < 10) {
                return '';
            } else if (hour < 15) {
                return '';
            } else if (hour < 18) {
                return '';
            } else if (hour < 20) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : '[] dddd[,] LT',
            lastDay : '[] LT',
            lastWeek : '[] dddd[,] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : dutch (nl)
    //! author : Joris Rling : https://github.com/jjupiter

    var nl__monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
        nl__monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');

    var nl = _moment__default.defineLocale('nl', {
        months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
        monthsShort : function (m, format) {
            if (/-MMM-/.test(format)) {
                return nl__monthsShortWithoutDots[m.month()];
            } else {
                return nl__monthsShortWithDots[m.month()];
            }
        },
        weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
        weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
        weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD-MM-YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[vandaag om] LT',
            nextDay: '[morgen om] LT',
            nextWeek: 'dddd [om] LT',
            lastDay: '[gisteren om] LT',
            lastWeek: '[afgelopen] dddd [om] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'over %s',
            past : '%s geleden',
            s : 'een paar seconden',
            m : 'n minuut',
            mm : '%d minuten',
            h : 'n uur',
            hh : '%d uur',
            d : 'n dag',
            dd : '%d dagen',
            M : 'n maand',
            MM : '%d maanden',
            y : 'n jaar',
            yy : '%d jaar'
        },
        ordinalParse: /\d{1,2}(ste|de)/,
        ordinal : function (number) {
            return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : norwegian nynorsk (nn)
    //! author : https://github.com/mechuwind

    var nn = _moment__default.defineLocale('nn', {
        months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
        monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
        weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
        weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
        weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[I dag klokka] LT',
            nextDay: '[I morgon klokka] LT',
            nextWeek: 'dddd [klokka] LT',
            lastDay: '[I gr klokka] LT',
            lastWeek: '[Fregande] dddd [klokka] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'for %s sidan',
            s : 'nokre sekund',
            m : 'eit minutt',
            mm : '%d minutt',
            h : 'ein time',
            hh : '%d timar',
            d : 'ein dag',
            dd : '%d dagar',
            M : 'ein mnad',
            MM : '%d mnader',
            y : 'eit r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : polish (pl)
    //! author : Rafal Hirsz : https://github.com/evoL

    var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
        monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
    function pl__plural(n) {
        return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
    }
    function pl__translate(number, withoutSuffix, key) {
        var result = number + ' ';
        switch (key) {
        case 'm':
            return withoutSuffix ? 'minuta' : 'minut';
        case 'mm':
            return result + (pl__plural(number) ? 'minuty' : 'minut');
        case 'h':
            return withoutSuffix  ? 'godzina'  : 'godzin';
        case 'hh':
            return result + (pl__plural(number) ? 'godziny' : 'godzin');
        case 'MM':
            return result + (pl__plural(number) ? 'miesice' : 'miesicy');
        case 'yy':
            return result + (pl__plural(number) ? 'lata' : 'lat');
        }
    }

    var pl = _moment__default.defineLocale('pl', {
        months : function (momentToFormat, format) {
            if (format === '') {
                // Hack: if format empty we know this is used to generate
                // RegExp by moment. Give then back both valid forms of months
                // in RegExp ready format.
                return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
            } else if (/D MMMM/.test(format)) {
                return monthsSubjective[momentToFormat.month()];
            } else {
                return monthsNominative[momentToFormat.month()];
            }
        },
        monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
        weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
        weekdaysShort : 'nie_pon_wt_r_czw_pt_sb'.split('_'),
        weekdaysMin : 'N_Pn_Wt_r_Cz_Pt_So'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Dzi o] LT',
            nextDay: '[Jutro o] LT',
            nextWeek: '[W] dddd [o] LT',
            lastDay: '[Wczoraj o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[W zesz niedziel o] LT';
                case 3:
                    return '[W zesz rod o] LT';
                case 6:
                    return '[W zesz sobot o] LT';
                default:
                    return '[W zeszy] dddd [o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : '%s temu',
            s : 'kilka sekund',
            m : pl__translate,
            mm : pl__translate,
            h : pl__translate,
            hh : pl__translate,
            d : '1 dzie',
            dd : '%d dni',
            M : 'miesic',
            MM : pl__translate,
            y : 'rok',
            yy : pl__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : brazilian portuguese (pt-br)
    //! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira

    var pt_br = _moment__default.defineLocale('pt-br', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : '%s atrs',
            s : 'poucos segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d'
    });

    //! moment.js locale configuration
    //! locale : portuguese (pt)
    //! author : Jefferson : https://github.com/jalex79

    var pt = _moment__default.defineLocale('pt', {
        months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
        weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
        weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
        weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D [de] MMMM [de] YYYY',
            LLL : 'D [de] MMMM [de] YYYY HH:mm',
            LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hoje s] LT',
            nextDay: '[Amanh s] LT',
            nextWeek: 'dddd [s] LT',
            lastDay: '[Ontem s] LT',
            lastWeek: function () {
                return (this.day() === 0 || this.day() === 6) ?
                    '[ltimo] dddd [s] LT' : // Saturday + Sunday
                    '[ltima] dddd [s] LT'; // Monday - Friday
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'em %s',
            past : 'h %s',
            s : 'segundos',
            m : 'um minuto',
            mm : '%d minutos',
            h : 'uma hora',
            hh : '%d horas',
            d : 'um dia',
            dd : '%d dias',
            M : 'um ms',
            MM : '%d meses',
            y : 'um ano',
            yy : '%d anos'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : '%d',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : romanian (ro)
    //! author : Vlad Gurdiga : https://github.com/gurdiga
    //! author : Valentin Agachi : https://github.com/avaly

    function ro__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
                'mm': 'minute',
                'hh': 'ore',
                'dd': 'zile',
                'MM': 'luni',
                'yy': 'ani'
            },
            separator = ' ';
        if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
            separator = ' de ';
        }
        return number + separator + format[key];
    }

    var ro = _moment__default.defineLocale('ro', {
        months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
        monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
        weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
        weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
        weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY H:mm',
            LLLL : 'dddd, D MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[azi la] LT',
            nextDay: '[mine la] LT',
            nextWeek: 'dddd [la] LT',
            lastDay: '[ieri la] LT',
            lastWeek: '[fosta] dddd [la] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'peste %s',
            past : '%s n urm',
            s : 'cteva secunde',
            m : 'un minut',
            mm : ro__relativeTimeWithPlural,
            h : 'o or',
            hh : ro__relativeTimeWithPlural,
            d : 'o zi',
            dd : ro__relativeTimeWithPlural,
            M : 'o lun',
            MM : ro__relativeTimeWithPlural,
            y : 'un an',
            yy : ro__relativeTimeWithPlural
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : russian (ru)
    //! author : Viktorminator : https://github.com/Viktorminator
    //! Author : Menelion Elensle : https://github.com/Oire

    function ru__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function ru__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': withoutSuffix ? '__' : '__',
            'hh': '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + ru__plural(format[key], +number);
        }
    }
    function ru__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function ru__monthsShortCaseReplace(m, format) {
        var monthsShort = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        },
        nounCase = (/D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return monthsShort[nounCase][m.month()];
    }
    function ru__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_')
        },
        nounCase = (/\[ ?[] ?(?:||)? ?\] ?dddd/).test(format) ?
            'accusative' :
            'nominative';
        return weekdays[nounCase][m.day()];
    }

    var ru = _moment__default.defineLocale('ru', {
        months : ru__monthsCaseReplace,
        monthsShort : ru__monthsShortCaseReplace,
        weekdays : ru__weekdaysCaseReplace,
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        monthsParse : [/^/i, /^/i, /^/i, /^/i, /^[|]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i],
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            lastDay: '[ ] LT',
            nextWeek: function () {
                return this.day() === 2 ? '[] dddd [] LT' : '[] dddd [] LT';
            },
            lastWeek: function (now) {
                if (now.week() !== this.week()) {
                    switch (this.day()) {
                    case 0:
                        return '[ ] dddd [] LT';
                    case 1:
                    case 2:
                    case 4:
                        return '[ ] dddd [] LT';
                    case 3:
                    case 5:
                    case 6:
                        return '[ ] dddd [] LT';
                    }
                } else {
                    if (this.day() === 2) {
                        return '[] dddd [] LT';
                    } else {
                        return '[] dddd [] LT';
                    }
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : ru__relativeTimeWithPlural,
            mm : ru__relativeTimeWithPlural,
            h : '',
            hh : ru__relativeTimeWithPlural,
            d : '',
            dd : ru__relativeTimeWithPlural,
            M : '',
            MM : ru__relativeTimeWithPlural,
            y : '',
            yy : ru__relativeTimeWithPlural
        },
        meridiemParse: /|||/i,
        isPM : function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}-(||)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
                return number + '-';
            case 'D':
                return number + '-';
            case 'w':
            case 'W':
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Sinhalese (si)
    //! author : Sampath Sitinamaluwa : https://github.com/sampathsris

    var si = _moment__default.defineLocale('si', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'a h:mm',
            LTS : 'a h:mm:ss',
            L : 'YYYY/MM/DD',
            LL : 'YYYY MMMM D',
            LLL : 'YYYY MMMM D, a h:mm',
            LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
        },
        calendar : {
            sameDay : '[] LT[]',
            nextDay : '[] LT[]',
            nextWeek : 'dddd LT[]',
            lastDay : '[] LT[]',
            lastWeek : '[] dddd LT[]',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s',
            past : '%s ',
            s : ' ',
            m : '',
            mm : ' %d',
            h : '',
            hh : ' %d',
            d : '',
            dd : ' %d',
            M : '',
            MM : ' %d',
            y : '',
            yy : ' %d'
        },
        ordinalParse: /\d{1,2} /,
        ordinal : function (number) {
            return number + ' ';
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? '..' : ' ';
            } else {
                return isLower ? '..' : ' ';
            }
        }
    });

    //! moment.js locale configuration
    //! locale : slovak (sk)
    //! author : Martin Minka : https://github.com/k2s
    //! based on work of petrbela : https://github.com/petrbela

    var sk__months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
        sk__monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
    function sk__plural(n) {
        return (n > 1) && (n < 5);
    }
    function sk__translate(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':  // a few seconds / in a few seconds / a few seconds ago
            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
        case 'm':  // a minute / in a minute / a minute ago
            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'minty' : 'mint');
            } else {
                return result + 'mintami';
            }
            break;
        case 'h':  // an hour / in an hour / an hour ago
            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
        case 'hh': // 9 hours / in 9 hours / 9 hours ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'hodiny' : 'hodn');
            } else {
                return result + 'hodinami';
            }
            break;
        case 'd':  // a day / in a day / a day ago
            return (withoutSuffix || isFuture) ? 'de' : 'dom';
        case 'dd': // 9 days / in 9 days / 9 days ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'dni' : 'dn');
            } else {
                return result + 'dami';
            }
            break;
        case 'M':  // a month / in a month / a month ago
            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
        case 'MM': // 9 months / in 9 months / 9 months ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'mesiace' : 'mesiacov');
            } else {
                return result + 'mesiacmi';
            }
            break;
        case 'y':  // a year / in a year / a year ago
            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
        case 'yy': // 9 years / in 9 years / 9 years ago
            if (withoutSuffix || isFuture) {
                return result + (sk__plural(number) ? 'roky' : 'rokov');
            } else {
                return result + 'rokmi';
            }
            break;
        }
    }

    var sk = _moment__default.defineLocale('sk', {
        months : sk__months,
        monthsShort : sk__monthsShort,
        monthsParse : (function (months, monthsShort) {
            var i, _monthsParse = [];
            for (i = 0; i < 12; i++) {
                // use custom parser to solve problem with July (ervenec)
                _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
            }
            return _monthsParse;
        }(sk__months, sk__monthsShort)),
        weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
        weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
        weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
        longDateFormat : {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay: '[dnes o] LT',
            nextDay: '[zajtra o] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[v nedeu o] LT';
                case 1:
                case 2:
                    return '[v] dddd [o] LT';
                case 3:
                    return '[v stredu o] LT';
                case 4:
                    return '[vo tvrtok o] LT';
                case 5:
                    return '[v piatok o] LT';
                case 6:
                    return '[v sobotu o] LT';
                }
            },
            lastDay: '[vera o] LT',
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[minul nedeu o] LT';
                case 1:
                case 2:
                    return '[minul] dddd [o] LT';
                case 3:
                    return '[minul stredu o] LT';
                case 4:
                case 5:
                    return '[minul] dddd [o] LT';
                case 6:
                    return '[minul sobotu o] LT';
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : 'za %s',
            past : 'pred %s',
            s : sk__translate,
            m : sk__translate,
            mm : sk__translate,
            h : sk__translate,
            hh : sk__translate,
            d : sk__translate,
            dd : sk__translate,
            M : sk__translate,
            MM : sk__translate,
            y : sk__translate,
            yy : sk__translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : slovenian (sl)
    //! author : Robert Sedovek : https://github.com/sedovsek

    function sl__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var result = number + ' ';
        switch (key) {
        case 's':
            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
        case 'm':
            return withoutSuffix ? 'ena minuta' : 'eno minuto';
        case 'mm':
            if (number === 1) {
                result += withoutSuffix ? 'minuta' : 'minuto';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
            } else {
                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
            }
            return result;
        case 'h':
            return withoutSuffix ? 'ena ura' : 'eno uro';
        case 'hh':
            if (number === 1) {
                result += withoutSuffix ? 'ura' : 'uro';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'uri' : 'urama';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'ure' : 'urami';
            } else {
                result += withoutSuffix || isFuture ? 'ur' : 'urami';
            }
            return result;
        case 'd':
            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
        case 'dd':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
            } else {
                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
            }
            return result;
        case 'M':
            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
        case 'MM':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
            } else {
                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
            }
            return result;
        case 'y':
            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
        case 'yy':
            if (number === 1) {
                result += withoutSuffix || isFuture ? 'leto' : 'letom';
            } else if (number === 2) {
                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
            } else if (number < 5) {
                result += withoutSuffix || isFuture ? 'leta' : 'leti';
            } else {
                result += withoutSuffix || isFuture ? 'let' : 'leti';
            }
            return result;
        }
    }

    var sl = _moment__default.defineLocale('sl', {
        months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
        monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
        weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
        weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
        weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
        longDateFormat : {
            LT : 'H:mm',
            LTS : 'H:mm:ss',
            L : 'DD. MM. YYYY',
            LL : 'D. MMMM YYYY',
            LLL : 'D. MMMM YYYY H:mm',
            LLLL : 'dddd, D. MMMM YYYY H:mm'
        },
        calendar : {
            sameDay  : '[danes ob] LT',
            nextDay  : '[jutri ob] LT',

            nextWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[v] [nedeljo] [ob] LT';
                case 3:
                    return '[v] [sredo] [ob] LT';
                case 6:
                    return '[v] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[v] dddd [ob] LT';
                }
            },
            lastDay  : '[veraj ob] LT',
            lastWeek : function () {
                switch (this.day()) {
                case 0:
                    return '[prejnjo] [nedeljo] [ob] LT';
                case 3:
                    return '[prejnjo] [sredo] [ob] LT';
                case 6:
                    return '[prejnjo] [soboto] [ob] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[prejnji] dddd [ob] LT';
                }
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'ez %s',
            past   : 'pred %s',
            s      : sl__processRelativeTime,
            m      : sl__processRelativeTime,
            mm     : sl__processRelativeTime,
            h      : sl__processRelativeTime,
            hh     : sl__processRelativeTime,
            d      : sl__processRelativeTime,
            dd     : sl__processRelativeTime,
            M      : sl__processRelativeTime,
            MM     : sl__processRelativeTime,
            y      : sl__processRelativeTime,
            yy     : sl__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Albanian (sq)
    //! author : Flakrim Ismani : https://github.com/flakerimi
    //! author: Menelion Elensle: https://github.com/Oire (tests)
    //! author : Oerd Cukalla : https://github.com/oerd (fixes)

    var sq = _moment__default.defineLocale('sq', {
        months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
        monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
        weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
        weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
        weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
        meridiemParse: /PD|MD/,
        isPM: function (input) {
            return input.charAt(0) === 'M';
        },
        meridiem : function (hours, minutes, isLower) {
            return hours < 12 ? 'PD' : 'MD';
        },
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[Sot n] LT',
            nextDay : '[Nesr n] LT',
            nextWeek : 'dddd [n] LT',
            lastDay : '[Dje n] LT',
            lastWeek : 'dddd [e kaluar n] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'n %s',
            past : '%s m par',
            s : 'disa sekonda',
            m : 'nj minut',
            mm : '%d minuta',
            h : 'nj or',
            hh : '%d or',
            d : 'nj dit',
            dd : '%d dit',
            M : 'nj muaj',
            MM : '%d muaj',
            y : 'nj vit',
            yy : '%d vite'
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Serbian-cyrillic (sr-cyrl)
    //! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

    var sr_cyrl__translator = {
        words: { //Different grammatical cases
            m: [' ', ' '],
            mm: ['', '', ''],
            h: [' ', ' '],
            hh: ['', '', ''],
            dd: ['', '', ''],
            MM: ['', '', ''],
            yy: ['', '', '']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = sr_cyrl__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + sr_cyrl__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr_cyrl = _moment__default.defineLocale('sr-cyrl', {
        months: ['', '', '', '', '', '', '', '', '', '', '', ''],
        monthsShort: ['.', '.', '.', '.', '', '', '', '.', '.', '.', '.', '.'],
        weekdays: ['', '', '', '', '', '', ''],
        weekdaysShort: ['.', '.', '.', '.', '.', '.', '.'],
        weekdaysMin: ['', '', '', '', '', '', ''],
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[] [] [] LT';
                case 3:
                    return '[] [] [] LT';
                case 6:
                    return '[] [] [] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[] dddd [] LT';
                }
            },
            lastDay  : '[ ] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past   : ' %s',
            s      : ' ',
            m      : sr_cyrl__translator.translate,
            mm     : sr_cyrl__translator.translate,
            h      : sr_cyrl__translator.translate,
            hh     : sr_cyrl__translator.translate,
            d      : '',
            dd     : sr_cyrl__translator.translate,
            M      : '',
            MM     : sr_cyrl__translator.translate,
            y      : '',
            yy     : sr_cyrl__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Serbian-latin (sr)
    //! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j

    var sr__translator = {
        words: { //Different grammatical cases
            m: ['jedan minut', 'jedne minute'],
            mm: ['minut', 'minute', 'minuta'],
            h: ['jedan sat', 'jednog sata'],
            hh: ['sat', 'sata', 'sati'],
            dd: ['dan', 'dana', 'dana'],
            MM: ['mesec', 'meseca', 'meseci'],
            yy: ['godina', 'godine', 'godina']
        },
        correctGrammaticalCase: function (number, wordKey) {
            return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
        },
        translate: function (number, withoutSuffix, key) {
            var wordKey = sr__translator.words[key];
            if (key.length === 1) {
                return withoutSuffix ? wordKey[0] : wordKey[1];
            } else {
                return number + ' ' + sr__translator.correctGrammaticalCase(number, wordKey);
            }
        }
    };

    var sr = _moment__default.defineLocale('sr', {
        months: ['januar', 'februar', 'mart', 'april', 'maj', 'jun', 'jul', 'avgust', 'septembar', 'oktobar', 'novembar', 'decembar'],
        monthsShort: ['jan.', 'feb.', 'mar.', 'apr.', 'maj', 'jun', 'jul', 'avg.', 'sep.', 'okt.', 'nov.', 'dec.'],
        weekdays: ['nedelja', 'ponedeljak', 'utorak', 'sreda', 'etvrtak', 'petak', 'subota'],
        weekdaysShort: ['ned.', 'pon.', 'uto.', 'sre.', 'et.', 'pet.', 'sub.'],
        weekdaysMin: ['ne', 'po', 'ut', 'sr', 'e', 'pe', 'su'],
        longDateFormat: {
            LT: 'H:mm',
            LTS : 'H:mm:ss',
            L: 'DD. MM. YYYY',
            LL: 'D. MMMM YYYY',
            LLL: 'D. MMMM YYYY H:mm',
            LLLL: 'dddd, D. MMMM YYYY H:mm'
        },
        calendar: {
            sameDay: '[danas u] LT',
            nextDay: '[sutra u] LT',
            nextWeek: function () {
                switch (this.day()) {
                case 0:
                    return '[u] [nedelju] [u] LT';
                case 3:
                    return '[u] [sredu] [u] LT';
                case 6:
                    return '[u] [subotu] [u] LT';
                case 1:
                case 2:
                case 4:
                case 5:
                    return '[u] dddd [u] LT';
                }
            },
            lastDay  : '[jue u] LT',
            lastWeek : function () {
                var lastWeekDays = [
                    '[prole] [nedelje] [u] LT',
                    '[prolog] [ponedeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];
                return lastWeekDays[this.day()];
            },
            sameElse : 'L'
        },
        relativeTime : {
            future : 'za %s',
            past   : 'pre %s',
            s      : 'nekoliko sekundi',
            m      : sr__translator.translate,
            mm     : sr__translator.translate,
            h      : sr__translator.translate,
            hh     : sr__translator.translate,
            d      : 'dan',
            dd     : sr__translator.translate,
            M      : 'mesec',
            MM     : sr__translator.translate,
            y      : 'godinu',
            yy     : sr__translator.translate
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : swedish (sv)
    //! author : Jens Alm : https://github.com/ulmus

    var sv = _moment__default.defineLocale('sv', {
        months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
        monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
        weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
        weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
        weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'YYYY-MM-DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Idag] LT',
            nextDay: '[Imorgon] LT',
            lastDay: '[Igr] LT',
            nextWeek: '[P] dddd LT',
            lastWeek: '[I] dddd[s] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'om %s',
            past : 'fr %s sedan',
            s : 'ngra sekunder',
            m : 'en minut',
            mm : '%d minuter',
            h : 'en timme',
            hh : '%d timmar',
            d : 'en dag',
            dd : '%d dagar',
            M : 'en mnad',
            MM : '%d mnader',
            y : 'ett r',
            yy : '%d r'
        },
        ordinalParse: /\d{1,2}(e|a)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (~~(number % 100 / 10) === 1) ? 'e' :
                (b === 1) ? 'a' :
                (b === 2) ? 'a' :
                (b === 3) ? 'e' : 'e';
            return number + output;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : tamil (ta)
    //! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404

    var ta = _moment__default.defineLocale('ta', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY, HH:mm',
            LLLL : 'dddd, D MMMM YYYY, HH:mm'
        },
        calendar : {
            sameDay : '[] LT',
            nextDay : '[] LT',
            nextWeek : 'dddd, LT',
            lastDay : '[] LT',
            lastWeek : '[ ] dddd, LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s ',
            past : '%s ',
            s : '  ',
            m : ' ',
            mm : '%d ',
            h : '  ',
            hh : '%d  ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number + '';
        },
        // refer http://ta.wikipedia.org/s/1er1
        meridiemParse: /|||||/,
        meridiem : function (hour, minute, isLower) {
            if (hour < 2) {
                return ' ';
            } else if (hour < 6) {
                return ' ';  // 
            } else if (hour < 10) {
                return ' '; // 
            } else if (hour < 14) {
                return ' '; // 
            } else if (hour < 18) {
                return ' '; // 
            } else if (hour < 22) {
                return ' '; // 
            } else {
                return ' ';
            }
        },
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '') {
                return hour < 2 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 10 ? hour : hour + 12;
            } else {
                return hour + 12;
            }
        },
        week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : thai (th)
    //! author : Kridsada Thanabulpong : https://github.com/sirn

    var th = _moment__default.defineLocale('th', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'), // yes, three characters difference
        weekdaysMin : '._._._._._._.'.split('_'),
        longDateFormat : {
            LT : 'H  m ',
            LTS : 'H  m  s ',
            L : 'YYYY/MM/DD',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY  H  m ',
            LLLL : 'dddd D MMMM YYYY  H  m '
        },
        meridiemParse: /|/,
        isPM: function (input) {
            return input === '';
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 12) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[ ] LT',
            nextDay : '[ ] LT',
            nextWeek : 'dddd[ ] LT',
            lastDay : '[ ] LT',
            lastWeek : '[]dddd[ ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s',
            s : '',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        }
    });

    //! moment.js locale configuration
    //! locale : Tagalog/Filipino (tl-ph)
    //! author : Dan Hagman

    var tl_ph = _moment__default.defineLocale('tl-ph', {
        months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
        monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
        weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
        weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
        weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'MM/D/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY HH:mm',
            LLLL : 'dddd, MMMM DD, YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Ngayon sa] LT',
            nextDay: '[Bukas sa] LT',
            nextWeek: 'dddd [sa] LT',
            lastDay: '[Kahapon sa] LT',
            lastWeek: 'dddd [huling linggo] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'sa loob ng %s',
            past : '%s ang nakalipas',
            s : 'ilang segundo',
            m : 'isang minuto',
            mm : '%d minuto',
            h : 'isang oras',
            hh : '%d oras',
            d : 'isang araw',
            dd : '%d araw',
            M : 'isang buwan',
            MM : '%d buwan',
            y : 'isang taon',
            yy : '%d taon'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : turkish (tr)
    //! authors : Erhan Gundogan : https://github.com/erhangundogan,
    //!           Burak Yiit Kaya: https://github.com/BYK

    var tr__suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',
        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',
        3: '\'nc',
        4: '\'nc',
        100: '\'nc',
        6: '\'nc',
        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',
        60: '\'nc',
        90: '\'nc'
    };

    var tr = _moment__default.defineLocale('tr', {
        months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
        monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
        weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
        weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
        weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd, D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay : '[bugn saat] LT',
            nextDay : '[yarn saat] LT',
            nextWeek : '[haftaya] dddd [saat] LT',
            lastDay : '[dn] LT',
            lastWeek : '[geen hafta] dddd [saat] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : '%s sonra',
            past : '%s nce',
            s : 'birka saniye',
            m : 'bir dakika',
            mm : '%d dakika',
            h : 'bir saat',
            hh : '%d saat',
            d : 'bir gn',
            dd : '%d gn',
            M : 'bir ay',
            MM : '%d ay',
            y : 'bir yl',
            yy : '%d yl'
        },
        ordinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
        ordinal : function (number) {
            if (number === 0) {  // special case for zero
                return number + '\'nc';
            }
            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;
            return number + (tr__suffixes[a] || tr__suffixes[b] || tr__suffixes[c]);
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : talossan (tzl)
    //! author : Robin van der Vliet : https://github.com/robin0van0der0v with the help of Iust Canun


    var tzl = _moment__default.defineLocale('tzl', {
        months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
        monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
        weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
        weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
        weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
        longDateFormat : {
            LT : 'HH.mm',
            LTS : 'LT.ss',
            L : 'DD.MM.YYYY',
            LL : 'D. MMMM [dallas] YYYY',
            LLL : 'D. MMMM [dallas] YYYY LT',
            LLLL : 'dddd, [li] D. MMMM [dallas] YYYY LT'
        },
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'd\'o' : 'D\'O';
            } else {
                return isLower ? 'd\'a' : 'D\'A';
            }
        },
        calendar : {
            sameDay : '[oxhi ] LT',
            nextDay : '[dem ] LT',
            nextWeek : 'dddd [] LT',
            lastDay : '[ieiri ] LT',
            lastWeek : '[sr el] dddd [lasteu ] LT',
            sameElse : 'L'
        },
        relativeTime : {
            future : 'osprei %s',
            past : 'ja%s',
            s : tzl__processRelativeTime,
            m : tzl__processRelativeTime,
            mm : tzl__processRelativeTime,
            h : tzl__processRelativeTime,
            hh : tzl__processRelativeTime,
            d : tzl__processRelativeTime,
            dd : tzl__processRelativeTime,
            M : tzl__processRelativeTime,
            MM : tzl__processRelativeTime,
            y : tzl__processRelativeTime,
            yy : tzl__processRelativeTime
        },
        ordinalParse: /\d{1,2}\./,
        ordinal : '%d.',
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    function tzl__processRelativeTime(number, withoutSuffix, key, isFuture) {
        var format = {
            's': ['viensas secunds', '\'iensas secunds'],
            'm': ['\'n mut', '\'iens mut'],
            'mm': [number + ' muts', ' ' + number + ' muts'],
            'h': ['\'n ora', '\'iensa ora'],
            'hh': [number + ' oras', ' ' + number + ' oras'],
            'd': ['\'n ziua', '\'iensa ziua'],
            'dd': [number + ' ziuas', ' ' + number + ' ziuas'],
            'M': ['\'n mes', '\'iens mes'],
            'MM': [number + ' mesen', ' ' + number + ' mesen'],
            'y': ['\'n ar', '\'iens ar'],
            'yy': [number + ' ars', ' ' + number + ' ars']
        };
        return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1].trim());
    }

    //! moment.js locale configuration
    //! locale : Morocco Central Atlas Tamazit in Latin (tzm-latn)
    //! author : Abdel Said : https://github.com/abdelsaid

    var tzm_latn = _moment__default.defineLocale('tzm-latn', {
        months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
        weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[asdkh g] LT',
            nextDay: '[aska g] LT',
            nextWeek: 'dddd [g] LT',
            lastDay: '[assant g] LT',
            lastWeek: 'dddd [g] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : 'dadkh s yan %s',
            past : 'yan %s',
            s : 'imik',
            m : 'minu',
            mm : '%d minu',
            h : 'saa',
            hh : '%d tassain',
            d : 'ass',
            dd : '%d ossan',
            M : 'ayowr',
            MM : '%d iyyirn',
            y : 'asgas',
            yy : '%d isgasn'
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : Morocco Central Atlas Tamazit (tzm)
    //! author : Abdel Said : https://github.com/abdelsaid

    var tzm = _moment__default.defineLocale('tzm', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS: 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'dddd D MMMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[ ] LT',
            nextDay: '[ ] LT',
            nextWeek: 'dddd [] LT',
            lastDay: '[ ] LT',
            lastWeek: 'dddd [] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '   %s',
            past : ' %s',
            s : '',
            m : '',
            mm : '%d ',
            h : '',
            hh : '%d ',
            d : '',
            dd : '%d o',
            M : 'o',
            MM : '%d ',
            y : '',
            yy : '%d '
        },
        week : {
            dow : 6, // Saturday is the first day of the week.
            doy : 12  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : ukrainian (uk)
    //! author : zemlanin : https://github.com/zemlanin
    //! Author : Menelion Elensle : https://github.com/Oire

    function uk__plural(word, num) {
        var forms = word.split('_');
        return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
    }
    function uk__relativeTimeWithPlural(number, withoutSuffix, key) {
        var format = {
            'mm': '__',
            'hh': '__',
            'dd': '__',
            'MM': '__',
            'yy': '__'
        };
        if (key === 'm') {
            return withoutSuffix ? '' : '';
        }
        else if (key === 'h') {
            return withoutSuffix ? '' : '';
        }
        else {
            return number + ' ' + uk__plural(format[key], +number);
        }
    }
    function uk__monthsCaseReplace(m, format) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        },
        nounCase = (/D[oD]? *MMMM?/).test(format) ?
            'accusative' :
            'nominative';
        return months[nounCase][m.month()];
    }
    function uk__weekdaysCaseReplace(m, format) {
        var weekdays = {
            'nominative': '______'.split('_'),
            'accusative': '______'.split('_'),
            'genitive': '______'.split('_')
        },
        nounCase = (/(\[[]\]) ?dddd/).test(format) ?
            'accusative' :
            ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
                'genitive' :
                'nominative');
        return weekdays[nounCase][m.day()];
    }
    function processHoursFunction(str) {
        return function () {
            return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
        };
    }

    var uk = _moment__default.defineLocale('uk', {
        months : uk__monthsCaseReplace,
        monthsShort : '___________'.split('_'),
        weekdays : uk__weekdaysCaseReplace,
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD.MM.YYYY',
            LL : 'D MMMM YYYY .',
            LLL : 'D MMMM YYYY ., HH:mm',
            LLLL : 'dddd, D MMMM YYYY ., HH:mm'
        },
        calendar : {
            sameDay: processHoursFunction('[ '),
            nextDay: processHoursFunction('[ '),
            lastDay: processHoursFunction('[ '),
            nextWeek: processHoursFunction('[] dddd ['),
            lastWeek: function () {
                switch (this.day()) {
                case 0:
                case 3:
                case 5:
                case 6:
                    return processHoursFunction('[] dddd [').call(this);
                case 1:
                case 2:
                case 4:
                    return processHoursFunction('[] dddd [').call(this);
                }
            },
            sameElse: 'L'
        },
        relativeTime : {
            future : ' %s',
            past : '%s ',
            s : ' ',
            m : uk__relativeTimeWithPlural,
            mm : uk__relativeTimeWithPlural,
            h : '',
            hh : uk__relativeTimeWithPlural,
            d : '',
            dd : uk__relativeTimeWithPlural,
            M : '',
            MM : uk__relativeTimeWithPlural,
            y : '',
            yy : uk__relativeTimeWithPlural
        },
        // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
        meridiemParse: /|||/,
        isPM: function (input) {
            return /^(|)$/.test(input);
        },
        meridiem : function (hour, minute, isLower) {
            if (hour < 4) {
                return '';
            } else if (hour < 12) {
                return '';
            } else if (hour < 17) {
                return '';
            } else {
                return '';
            }
        },
        ordinalParse: /\d{1,2}-(|)/,
        ordinal: function (number, period) {
            switch (period) {
            case 'M':
            case 'd':
            case 'DDD':
            case 'w':
            case 'W':
                return number + '-';
            case 'D':
                return number + '-';
            default:
                return number;
            }
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 1st is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : uzbek (uz)
    //! author : Sardor Muminov : https://github.com/muminoff

    var uz = _moment__default.defineLocale('uz', {
        months : '___________'.split('_'),
        monthsShort : '___________'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM YYYY',
            LLL : 'D MMMM YYYY HH:mm',
            LLLL : 'D MMMM YYYY, dddd HH:mm'
        },
        calendar : {
            sameDay : '[ ] LT []',
            nextDay : '[] LT []',
            nextWeek : 'dddd [ ] LT []',
            lastDay : '[ ] LT []',
            lastWeek : '[] dddd [ ] LT []',
            sameElse : 'L'
        },
        relativeTime : {
            future : ' %s ',
            past : '  %s ',
            s : '',
            m : ' ',
            mm : '%d ',
            h : ' ',
            hh : '%d ',
            d : ' ',
            dd : '%d ',
            M : ' ',
            MM : '%d ',
            y : ' ',
            yy : '%d '
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 7  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : vietnamese (vi)
    //! author : Bang Nguyen : https://github.com/bangnk

    var vi = _moment__default.defineLocale('vi', {
        months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
        monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
        weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
        weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
        longDateFormat : {
            LT : 'HH:mm',
            LTS : 'HH:mm:ss',
            L : 'DD/MM/YYYY',
            LL : 'D MMMM [nm] YYYY',
            LLL : 'D MMMM [nm] YYYY HH:mm',
            LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
            l : 'DD/M/YYYY',
            ll : 'D MMM YYYY',
            lll : 'D MMM YYYY HH:mm',
            llll : 'ddd, D MMM YYYY HH:mm'
        },
        calendar : {
            sameDay: '[Hm nay lc] LT',
            nextDay: '[Ngy mai lc] LT',
            nextWeek: 'dddd [tun ti lc] LT',
            lastDay: '[Hm qua lc] LT',
            lastWeek: 'dddd [tun ri lc] LT',
            sameElse: 'L'
        },
        relativeTime : {
            future : '%s ti',
            past : '%s trc',
            s : 'vi giy',
            m : 'mt pht',
            mm : '%d pht',
            h : 'mt gi',
            hh : '%d gi',
            d : 'mt ngy',
            dd : '%d ngy',
            M : 'mt thng',
            MM : '%d thng',
            y : 'mt nm',
            yy : '%d nm'
        },
        ordinalParse: /\d{1,2}/,
        ordinal : function (number) {
            return number;
        },
        week : {
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : chinese (zh-cn)
    //! author : suupic : https://github.com/suupic
    //! author : Zeno Zeng : https://github.com/zenozeng

    var zh_cn = _moment__default.defineLocale('zh-cn', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'Ahmm',
            LTS : 'Ahms',
            L : 'YYYY-MM-DD',
            LL : 'YYYYMMMD',
            LLL : 'YYYYMMMDAhmm',
            LLLL : 'YYYYMMMDddddAhmm',
            l : 'YYYY-MM-DD',
            ll : 'YYYYMMMD',
            lll : 'YYYYMMMDAhmm',
            llll : 'YYYYMMMDddddAhmm'
        },
        meridiemParse: /|||||/,
        meridiemHour: function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '' ||
                    meridiem === '') {
                return hour;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            } else {
                // ''
                return hour >= 11 ? hour : hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 600) {
                return '';
            } else if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : function () {
                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
            },
            nextDay : function () {
                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
            },
            lastDay : function () {
                return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
            },
            nextWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = _moment__default().startOf('week');
                prefix = this.unix() - startOfWeek.unix() >= 7 * 24 * 3600 ? '[]' : '[]';
                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
            },
            lastWeek : function () {
                var startOfWeek, prefix;
                startOfWeek = _moment__default().startOf('week');
                prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';
                return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
            },
            sameElse : 'LL'
        },
        ordinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd':
            case 'D':
            case 'DDD':
                return number + '';
            case 'M':
                return number + '';
            case 'w':
            case 'W':
                return number + '';
            default:
                return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            m : '1 ',
            mm : '%d ',
            h : '1 ',
            hh : '%d ',
            d : '1 ',
            dd : '%d ',
            M : '1 ',
            MM : '%d ',
            y : '1 ',
            yy : '%d '
        },
        week : {
            // GB/T 7408-1994ISO 8601:1988
            dow : 1, // Monday is the first day of the week.
            doy : 4  // The week that contains Jan 4th is the first week of the year.
        }
    });

    //! moment.js locale configuration
    //! locale : traditional chinese (zh-tw)
    //! author : Ben : https://github.com/ben-lin

    var zh_tw = _moment__default.defineLocale('zh-tw', {
        months : '___________'.split('_'),
        monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
        weekdays : '______'.split('_'),
        weekdaysShort : '______'.split('_'),
        weekdaysMin : '______'.split('_'),
        longDateFormat : {
            LT : 'Ahmm',
            LTS : 'Ahms',
            L : 'YYYYMMMD',
            LL : 'YYYYMMMD',
            LLL : 'YYYYMMMDAhmm',
            LLLL : 'YYYYMMMDddddAhmm',
            l : 'YYYYMMMD',
            ll : 'YYYYMMMD',
            lll : 'YYYYMMMDAhmm',
            llll : 'YYYYMMMDddddAhmm'
        },
        meridiemParse: /||||/,
        meridiemHour : function (hour, meridiem) {
            if (hour === 12) {
                hour = 0;
            }
            if (meridiem === '' || meridiem === '') {
                return hour;
            } else if (meridiem === '') {
                return hour >= 11 ? hour : hour + 12;
            } else if (meridiem === '' || meridiem === '') {
                return hour + 12;
            }
        },
        meridiem : function (hour, minute, isLower) {
            var hm = hour * 100 + minute;
            if (hm < 900) {
                return '';
            } else if (hm < 1130) {
                return '';
            } else if (hm < 1230) {
                return '';
            } else if (hm < 1800) {
                return '';
            } else {
                return '';
            }
        },
        calendar : {
            sameDay : '[]LT',
            nextDay : '[]LT',
            nextWeek : '[]ddddLT',
            lastDay : '[]LT',
            lastWeek : '[]ddddLT',
            sameElse : 'L'
        },
        ordinalParse: /\d{1,2}(||)/,
        ordinal : function (number, period) {
            switch (period) {
            case 'd' :
            case 'D' :
            case 'DDD' :
                return number + '';
            case 'M' :
                return number + '';
            case 'w' :
            case 'W' :
                return number + '';
            default :
                return number;
            }
        },
        relativeTime : {
            future : '%s',
            past : '%s',
            s : '',
            m : '',
            mm : '%d',
            h : '',
            hh : '%d',
            d : '',
            dd : '%d',
            M : '',
            MM : '%d',
            y : '',
            yy : '%d'
        }
    });

    var moment_with_locales = _moment__default;
    moment_with_locales.locale('en');

    return moment_with_locales;

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('af');

    test('parse', function (assert) {
        var tests = 'Januarie Jan_Februarie Feb_Maart Mar_April Apr_Mei Mei_Junie Jun_Julie Jul_Augustus Aug_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sondag, Februarie 14de 2010, 3:25:50 nm'],
                ['ddd, hA',                            'Son, 3NM'],
                ['M Mo MM MMMM MMM',                   '2 2de 02 Februarie Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14de 14'],
                ['d do dddd ddd dd',                   '0 0de Sondag Son So'],
                ['DDD DDDo DDDD',                      '45 45ste 045'],
                ['w wo ww',                            '6 6de 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'nm NM'],
                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februarie 2010'],
                ['LLL',                                '14 Februarie 2010 15:25'],
                ['LLLL',                               'Sondag, 14 Februarie 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 15:25'],
                ['llll',                               'Son, 14 Feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');
    });

    test('format month', function (assert) {
        var expected = 'Januarie Jan_Februarie Feb_Maart Mar_April Apr_Mei Mei_Junie Jun_Julie Jul_Augustus Aug_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sondag Son So_Maandag Maa Ma_Dinsdag Din Di_Woensdag Woe Wo_Donderdag Don Do_Vrydag Vry Vr_Saterdag Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '\'n paar sekondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\'n minuut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\'n minuut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minute',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\'n uur',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\'n uur',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ure',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ure',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ure',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\'n dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\'n dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dae',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\'n dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dae',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dae',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\'n maand',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\'n maand',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\'n maand',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 maande',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 maande',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 maande',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\'n maand',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 maande',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\'n jaar',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaar',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\'n jaar',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaar',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'oor \'n paar sekondes',  'prefix');
        assert.equal(moment(0).from(30000), '\'n paar sekondes gelede', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '\'n paar sekondes gelede',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'oor \'n paar sekondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'oor 5 dae', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Vandag om 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Vandag om 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Vandag om 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Mre om 02:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Vandag om 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Gister om 02:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Laas] dddd [om] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ar-ma');

    test('parse', function (assert) {
        var tests = ':_:_:_:_:_:_:_:_:_:_:_:'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(':');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      ',  14 2010, 3:25:50 pm'],
                ['ddd, hA',                            ', 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14  2010'],
                ['LLL',                                '14  2010 15:25'],
                ['LLLL',                               ' 14  2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14  2010'],
                ['lll',                                '14  2010 15:25'],
                ['llll',                               ' 14  2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ',  'prefix');
        assert.equal(moment(0).from(30000), ' ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), ' ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), ' ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '   02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '   02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '   03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '   02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '   01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '   02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ar-sa');

    test('parse', function (assert) {
        var tests = ':_:_:_:_:_:_:_:_:_:_:_:'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(':');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      '    :: '],
                ['ddd, hA',                            ' '],
                ['M Mo MM MMMM MMM',                   '    '],
                ['YYYY YY',                            ' '],
                ['D Do DD',                            '  '],
                ['d do dddd ddd dd',                   '    '],
                ['DDD DDDo DDDD',                      '  '],
                ['w wo ww',                            '  '],
                ['h hh',                               ' '],
                ['H HH',                               ' '],
                ['m mm',                               ' '],
                ['s ss',                               ' '],
                ['a A',                                ' '],
                ['[the] DDDo [day of the year]',       'the  day of the year'],
                ['LT',                                 ':'],
                ['LTS',                                '::'],
                ['L',                                  '//'],
                ['LL',                                 '  '],
                ['LLL',                                '   :'],
                ['LLLL',                               '    :'],
                ['l',                                  '//'],
                ['ll',                                 '  '],
                ['lll',                                '   :'],
                ['llll',                               '    :']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '', '31');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  ' ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  ' ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  ' ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   ' ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  ' ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  ' ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   ' ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  ' ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  ' ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  ' ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  ' ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   ' ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), ' ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   ' ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ',  'prefix');
        assert.equal(moment(0).from(30000), ' ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), ' ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), ' ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '  ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '   :',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '   :',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '   :',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '   :',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '   :',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '   :', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');

        assert.equal(moment('2003 1 6', 'gggg w d').format('YYYY-MM-DD'), '--', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 0', 'gggg w e').format('YYYY-MM-DD'), '--', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 6', 'gggg w d').format('gggg w d'), '  ', 'Saturday of week 1 of 2003 parsed should be formatted as 2003 1 6');
        assert.equal(moment('2003 1 0', 'gggg w e').format('gggg w e'), '  ', '1st day of week 1 of 2003 parsed should be formatted as 2003 1 0');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '  ', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '  ', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '  ', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '  ', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '  ', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ar-tn');

    test('parse', function (assert) {
        var tests = ':_:_:_:_:_:_:_:_:_:_:_:'.split('_'),
            i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(':');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', ',  14 2010, 3:25:50 pm'],
                ['ddd, hA', ', 3PM'],
                ['M Mo MM MMMM MMM', '2 2 02  '],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14 14'],
                ['d do dddd ddd dd', '0 0   '],
                ['DDD DDDo DDDD', '45 45 045'],
                ['w wo ww', '6 6 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45 day of the year'],
                ['LT', '15:25'],
                ['LTS', '15:25:50'],
                ['L', '14/02/2010'],
                ['LL', '14  2010'],
                ['LLL', '14  2010 15:25'],
                ['LLLL', ' 14  2010 15:25'],
                ['l', '14/2/2010'],
                ['ll', '14  2010'],
                ['lll', '14  2010 15:25'],
                ['llll', ' 14  2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 44
        }), true), '', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 45
        }), true), '', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 89
        }), true), '', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 90
        }), true), '2 ', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 44
        }), true), '44 ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 45
        }), true), '', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 89
        }), true), '', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 90
        }), true), '2 ', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 5
        }), true), '5 ', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 21
        }), true), '21 ', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 22
        }), true), '', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 35
        }), true), '', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 36
        }), true), '2 ', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 1
        }), true), '', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 5
        }), true), '5 ', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 25
        }), true), '25 ', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 26
        }), true), '', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 30
        }), true), '', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 43
        }), true), '', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 46
        }), true), '2 ', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 74
        }), true), '2 ', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 76
        }), true), '3 ', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 1
        }), true), '', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 5
        }), true), '5 ', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 345
        }), true), '', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 548
        }), true), '2 ', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 1
        }), true), '', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 5
        }), true), '5 ', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ', 'prefix');
        assert.equal(moment(0).from(30000), ' ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), ' ', 'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({
            s: 30
        }).fromNow(), ' ', 'in a few seconds');
        assert.equal(moment().add({
            d: 5
        }).fromNow(), ' 5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(), '   02:00', 'today at the same time');
        assert.equal(moment(a).add({
            m: 25
        }).calendar(), '   02:25', 'Now plus 25 min');
        assert.equal(moment(a).add({
            h: 1
        }).calendar(), '   03:00', 'Now plus 1 hour');
        assert.equal(moment(a).add({
            d: 1
        }).calendar(), '   02:00', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({
            h: 1
        }).calendar(), '   01:00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({
            d: 1
        }).calendar(), '   02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [ ] LT'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [ ] LT'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [ ] LT'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [ ] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [ ] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [ ] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({
                w: 1
            }),
            weeksFromNow = moment().add({
                w: 1
            });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({
            w: 2
        });
        weeksFromNow = moment().add({
            w: 2
        });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ar');

    var months = [
        '  ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        ' ',
        '  ',
        '  ',
        '  '
    ];

    test('parse', function (assert) {
        var tests = months, i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());
        }
        for (i = 0; i < 12; i++) {
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMMM', i);
            equalTest(tests[i], 'MMMM', i);
            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      '     :: '],
                ['ddd, hA',                            ' '],
                ['M Mo MM MMMM MMM',                   '      '],
                ['YYYY YY',                            ' '],
                ['D Do DD',                            '  '],
                ['d do dddd ddd dd',                   '    '],
                ['DDD DDDo DDDD',                      '  '],
                ['w wo ww',                            '  '],
                ['h hh',                               ' '],
                ['H HH',                               ' '],
                ['m mm',                               ' '],
                ['s ss',                               ' '],
                ['a A',                                ' '],
                ['[the] DDDo [day of the year]',       'the  day of the year'],
                ['LT',                                 ':'],
                ['LTS',                                '::'],
                ['L',                                  '/\u200f/\u200f'],
                ['LL',                                 '   '],
                ['LLL',                                '    :'],
                ['LLLL',                               '     :'],
                ['l',                                  '/\u200f/\u200f'],
                ['ll',                                 '   '],
                ['lll',                                '    :'],
                ['llll',                               '     :']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '', '31');
    });

    test('format month', function (assert) {
        var expected = months, i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM'), expected[i], expected[i]);
            assert.equal(moment([2011, i, 1]).format('MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  ' ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   ' ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  ' ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   ' ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  ' ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  ' ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  ' ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   ' ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   ' ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '  ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '   :',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '   :',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '   :',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '   :',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '   :',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '   :', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');

        assert.equal(moment('2003 1 6', 'gggg w d').format('YYYY-MM-DD'), '--', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 0', 'gggg w e').format('YYYY-MM-DD'), '--', 'Week 1 of 2003 should be Dec 28 2002');
        assert.equal(moment('2003 1 6', 'gggg w d').format('gggg w d'), '  ', 'Saturday of week 1 of 2003 parsed should be formatted as 2003 1 6');
        assert.equal(moment('2003 1 0', 'gggg w e').format('gggg w e'), '  ', '1st day of week 1 of 2003 parsed should be formatted as 2003 1 0');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '  ', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '  ', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '  ', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '  ', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '  ', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

    test('no leading zeros in long date formats', function (assert) {
        var i, j, longDateStr, shortDateStr;
        for (i = 1; i <= 9; ++i) {
            for (j = 1; j <= 9; ++j) {
                longDateStr = moment([2014, i, j]).format('L');
                shortDateStr = moment([2014, i, j]).format('l');
                assert.equal(longDateStr, shortDateStr, 'should not have leading zeros in month or day');
            }
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('az');

    test('parse', function (assert) {
        var tests = 'yanvar yan_fevral fev_mart mar_Aprel apr_may may_iyun iyn_iyul iyl_Avqust avq_sentyabr sen_oktyabr okt_noyabr noy_dekabr dek'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, D MMMM YYYY, HH:mm:ss',        'Bazar, 14 fevral 2010, 15:25:50'],
                ['ddd, A h',                           'Baz, gndz 3'],
                ['M Mo MM MMMM MMM',                   '2 2-nci 02 fevral fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-nc 14'],
                ['d do dddd ddd dd',                   '0 0-nc Bazar Baz Bz'],
                ['DDD DDDo DDDD',                      '45 45-inci 045'],
                ['w wo ww',                            '7 7-nci 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'gndz gndz'],
                ['[ilin] DDDo [gn]',                 'ilin 45-inci gn'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 fevral 2010'],
                ['LLL',                                '14 fevral 2010 15:25'],
                ['LLLL',                               'Bazar, 14 fevral 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 fev 2010'],
                ['lll',                                '14 fev 2010 15:25'],
                ['llll',                               'Baz, 14 fev 2010 15:25']
            ],
            DDDo = [
                [359, '360-nc'],
                [199, '200-nc'],
                [149, '150-nci']
            ],
            dt = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            DDDoDt,
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(dt.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
        for (i = 0; i < DDDo.length; i++) {
            DDDoDt = moment([2010]);
            assert.equal(DDDoDt.add(DDDo[i][0], 'days').format('DDDo'), DDDo[i][1], DDDo[i][0] + ' ---> ' + DDDo[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-inci', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-nci', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-nc', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-nc', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-inci', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-nc', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-nci', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-inci', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-uncu', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-uncu', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-inci', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-nci', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-nc', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-nc', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-inci', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-nc', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-nci', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-inci', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-uncu', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-nci', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-inci', '21th');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-nci', '22th');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-nc', '23th');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-nc', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-inci', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-nc', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-nci', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-inci', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-uncu', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-uncu', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-inci', '31st');
    });

    test('format month', function (assert) {
        var expected = 'yanvar yan_fevral fev_mart mar_aprel apr_may may_iyun iyn_iyul iyl_avqust avq_sentyabr sen_oktyabr okt_noyabr noy_dekabr dek'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Bazar Baz Bz_Bazar ertsi BzE BE_rnb axam Ax A_rnb r _Cm axam CAx CA_Cm Cm C_nb n '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'birne saniyy', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'bir dqiq',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'bir dqiq',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 dqiq',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 dqiq',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'bir saat',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'bir saat',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 saat',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 saat',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 saat',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'bir gn',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'bir gn',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 gn',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'bir gn',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 gn',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 gn',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'bir ay',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'bir ay',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ay',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ay',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ay',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'bir ay',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ay',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bir il',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 il',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'bir il',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 il',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'birne saniyy sonra',  'prefix');
        assert.equal(moment(0).from(30000), 'birne saniyy vvl', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'birne saniyy vvl',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'birne saniyy sonra', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 gn sonra', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'bugn saat 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'bugn saat 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'bugn saat 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sabah saat 02:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'bugn saat 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'dnn 02:00',          'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[gln hft] dddd [saat] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[gln hft] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[gln hft] dddd [saat] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[ken hft] dddd [saat] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ken hft] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ken hft] dddd [saat] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-inci', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-inci', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-nci', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-nci', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-nc', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('be');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       ', 14-  2010, 15:25:50'],
                ['ddd, h A',                           ', 3 '],
                ['M Mo MM MMMM MMM',                   '2 2- 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14- 14'],
                ['d do dddd ddd dd',                   '0 0-   '],
                ['DDD DDDo DDDD',                      '45 45- 045'],
                ['w wo ww',                            '7 7- 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['DDDo [ ]',                   '45-  '],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14  2010 .'],
                ['LLL',                                '14  2010 ., 15:25'],
                ['LLLL',                               ', 14  2010 ., 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14  2010 .'],
                ['lll',                                '14  2010 ., 15:25'],
                ['llll',                               ', 14  2010 ., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-', '1-');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-', '2-');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-', '3-');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-', '4-');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-', '5-');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-', '6-');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-', '7-');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-', '8-');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-', '9-');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-', '10-');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-', '11-');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-', '12-');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-', '13-');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-', '14-');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-', '15-');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-', '16-');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-', '17-');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-', '18-');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-', '19-');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-', '20-');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-', '21-');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-', '22-');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-', '23-');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-', '24-');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-', '25-');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-', '26-');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-', '27-');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-', '28-');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-', '29-');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-', '30-');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-', '31-');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format month case with escaped symbols', function (assert) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[- ] MMMM'), '1-  ' + months.accusative[i], '1-  ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ',    '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 31}), true),  '31 ',  '31 minutes = 31 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 ',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 ',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ', 'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
        assert.equal(moment().add({m: 31}).fromNow(), ' 31 ', 'in 31 minutes = in 31 minutes');
        assert.equal(moment().subtract({m: 31}).fromNow(), '31  ', '31 minutes ago = 31 minutes ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  02:00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  02:00',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        function makeFormat(d) {
            return '[] dddd [] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 5:
            case 6:
                return '[ ] dddd [] LT';
            case 1:
            case 2:
            case 4:
                return '[ ] dddd [] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('bg');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, H:mm:ss',        ',  14- 2010, 15:25:50'],
                ['ddd, hA',                            ', 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2- 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14- 14'],
                ['d do dddd ddd dd',                   '0 0-   '],
                ['DDD DDDo DDDD',                      '45 45- 045'],
                ['w wo ww',                            '7 7- 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45- day of the year'],
                ['LT',                                 '15:25'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14  2010'],
                ['LLL',                                '14  2010 15:25'],
                ['LLLL',                               ', 14  2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14  2010'],
                ['lll',                                '14  2010 15:25'],
                ['llll',                               ', 14  2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-', '1-');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-', '2-');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-', '3-');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-', '4-');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-', '5-');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-', '6-');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-', '7-');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-', '8-');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-', '9-');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-', '10-');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-', '11-');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-', '12-');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-', '13-');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-', '14-');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-', '15-');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-', '16-');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-', '17-');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-', '18-');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-', '19-');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-', '20-');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-', '21-');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-', '22-');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-', '23-');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-', '24-');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-', '25-');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-', '26-');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-', '27-');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-', '28-');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-', '29-');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-', '30-');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-', '31-');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',          '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',          '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',        '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',       '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',             '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',             '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',             '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',             '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',           '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',             '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',           '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',          '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',           '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',           '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',           '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',        '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',        '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',        '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',           '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',        '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',          '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',          '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 6:
                return '[ ] dddd [] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[ ] dddd [] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('bn');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss ',  ',   ,  :: '],
                ['ddd, a h ',                       ',   '],
                ['M Mo MM MMMM MMM',                   '    '],
                ['YYYY YY',                            ' '],
                ['D Do DD',                            '  '],
                ['d do dddd ddd dd',                   '    '],
                ['DDD DDDo DDDD',                      '  '],
                ['w wo ww',                            '  '],
                ['h hh',                               ' '],
                ['H HH',                               ' '],
                ['m mm',                               ' '],
                ['s ss',                               ' '],
                ['a A',                                ' '],
                ['LT',                                 ' : '],
                ['LTS',                                ' :: '],
                ['L',                                  '//'],
                ['LL',                                 '  '],
                ['LLL',                                '  ,  : '],
                ['LLLL',                               ',   ,  : '],
                ['l',                                  '//'],
                ['ll',                                 '  '],
                ['lll',                                '  ,  : '],
                ['llll',                               ',   ,  : ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '', '');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  ' ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  ' ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  ' ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   ' ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  ' ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  ' ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   ' ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  ' ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  ' ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  ' ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  ' ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   ' ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), ' ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   ' ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', '  ');
        assert.equal(moment().add({d: 5}).fromNow(), '  ', '  ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  : ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  : ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '  : ',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  : ',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  : ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  : ', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '  ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '  ', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '  ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '  ', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '  ', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('bo');

    test('parse', function (assert) {
        var tests = ' ._ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss ',  ',   ,  :: '],
                ['ddd, a h ',                       ',   '],
                ['M Mo MM MMMM MMM',                   '    '],
                ['YYYY YY',                            ' '],
                ['D Do DD',                            '  '],
                ['d do dddd ddd dd',                   '    '],
                ['DDD DDDo DDDD',                      '  '],
                ['w wo ww',                            '  '],
                ['h hh',                               ' '],
                ['H HH',                               ' '],
                ['m mm',                               ' '],
                ['s ss',                               ' '],
                ['a A',                                ' '],
                ['LT',                                 ' :'],
                ['LTS',                                ' ::'],
                ['L',                                  '//'],
                ['LL',                                 '  '],
                ['LLL',                                '  ,  :'],
                ['LLLL',                               ',   ,  :'],
                ['l',                                  '//'],
                ['ll',                                 '  '],
                ['lll',                                '  ,  :'],
                ['llll',                               ',   ,  :']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '', '');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  ' ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  ' ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  ' ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   ' ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  ' ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  ' ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   ' ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  ' ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  ' ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  ' ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  ' ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   ' ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), ' ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   ' ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ',  'prefix');
        assert.equal(moment(0).from(30000), ' ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), ' ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), ' ', ' ');
        assert.equal(moment().add({d: 5}).fromNow(), '  ', '  ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  :',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  :',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '  :',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  :',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  :',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  :', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[][,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[][,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[][,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '  ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '  ', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '  ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '  ', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '  ', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('br');

    test('parse', function (assert) {
        var tests = 'Genver Gen_C\'hwevrer C\'hwe_Meurzh Meu_Ebrel Ebr_Mae Mae_Mezheven Eve_Gouere Gou_Eost Eos_Gwengolo Gwe_Here Her_Du Du_Kerzu Ker'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        moment.locale('br');
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sul, C\'hwevrer 14vet 2010, 3:25:50 pm'],
                ['ddd, h A',                            'Sul, 3 PM'],
                ['M Mo MM MMMM MMM',                   '2 2vet 02 C\'hwevrer C\'hwe'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14vet 14'],
                ['d do dddd ddd dd',                   '0 0vet Sul Sul Su'],
                ['DDD DDDo DDDD',                      '45 45vet 045'],
                ['w wo ww',                            '6 6vet 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['DDDo [devezh] [ar] [vloaz]',       '45vet devezh ar vloaz'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 a viz C\'hwevrer 2010'],
                ['LLL',                                '14 a viz C\'hwevrer 2010 3e25 PM'],
                ['LLLL',                               'Sul, 14 a viz C\'hwevrer 2010 3e25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        moment.locale('br');
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a', '1a');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2vet', '2vet');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3vet', '3vet');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4vet', '4vet');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5vet', '5vet');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6vet', '6vet');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7vet', '7vet');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8vet', '8vet');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9vet', '9vet');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10vet', '10vet');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11vet', '11vet');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12vet', '12vet');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13vet', '13vet');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14vet', '14vet');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15vet', '15vet');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16vet', '16vet');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17vet', '17vet');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18vet', '18vet');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19vet', '19vet');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20vet', '20vet');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21vet', '21vet');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22vet', '22vet');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23vet', '23vet');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24vet', '24vet');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25vet', '25vet');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26vet', '26vet');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27vet', '27vet');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28vet', '28vet');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29vet', '29vet');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30vet', '30vet');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31vet', '31vet');
    });

    test('format month', function (assert) {
        moment.locale('br');
        var expected = 'Genver Gen_C\'hwevrer C\'hwe_Meurzh Meu_Ebrel Ebr_Mae Mae_Mezheven Eve_Gouere Gou_Eost Eos_Gwengolo Gwe_Here Her_Du Du_Kerzu Ker'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        moment.locale('br');
        var expected = 'Sul Sul Su_Lun Lun Lu_Meurzh Meu Me_Merc\'her Mer Mer_Yaou Yao Ya_Gwener Gwe Gw_Sadorn Sad Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        moment.locale('br');
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'un nebeud segondenno', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ur vunutenn',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ur vunutenn',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 vunutenn',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 munutenn',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'un eur',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'un eur',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 eur',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 eur',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 eur',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un devezh',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un devezh',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 zevezh',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un devezh',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 devezh',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 devezh',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ur miz',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ur miz',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ur miz',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 viz',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 viz',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 miz',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ur miz',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 miz',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ur bloaz',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 vloaz',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ur bloaz',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 bloaz',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        moment.locale('br');
        assert.equal(moment(30000).from(0), 'a-benn un nebeud segondenno',  'prefix');
        assert.equal(moment(0).from(30000), 'un nebeud segondenno \'zo', 'suffix');
    });

    test('now from now', function (assert) {
        moment.locale('br');
        assert.equal(moment().fromNow(), 'un nebeud segondenno \'zo',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        moment.locale('br');
        assert.equal(moment().add({s: 30}).fromNow(), 'a-benn un nebeud segondenno', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'a-benn 5 devezh', 'in 5 days');
    });

    test('calendar day', function (assert) {
        moment.locale('br');

        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hiziv da 2e00 AM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hiziv da 2e25 AM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hiziv da 3e00 AM',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Warc\'hoazh da 2e00 AM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hiziv da 1e00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Dec\'h da 2e00 AM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        moment.locale('br');

        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [da] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        moment.locale('br');

        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [paset da] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        moment.locale('br');
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('special mutations for years', function (assert) {
        moment.locale('br');
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ur bloaz', 'mutation 1 year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 2}), true), '2 vloaz', 'mutation 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 3}), true), '3 bloaz', 'mutation 3 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 4}), true), '4 bloaz', 'mutation 4 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 bloaz', 'mutation 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 9}), true), '9 bloaz', 'mutation 9 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 10}), true), '10 vloaz', 'mutation 10 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 21}), true), '21 bloaz', 'mutation 21 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 22}), true), '22 vloaz', 'mutation 22 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 133}), true), '133 bloaz', 'mutation 133 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 148}), true), '148 vloaz', 'mutation 148 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 261}), true), '261 bloaz', 'mutation 261 years');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('bs');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj._juni jun._juli jul._august aug._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedjelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj._juni jun._juli jul._august aug._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_etvrtak et. e_petak pet. pe_subota sub. su'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'par sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedna minuta',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedna minuta',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za par sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prije par sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prije par sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za par sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'danas u 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juer u 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedjelju] [u] LT';
            case 3:
                return '[u] [srijedu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
                return '[prolu] dddd [u] LT';
            case 6:
                return '[prole] [subote] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[proli] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ca');

    test('parse', function (assert) {
        var tests = 'gener gen._febrer febr._mar mar._abril abr._maig mai._juny jun._juliol jul._agost ag._setembre set._octubre oct._novembre nov._desembre des.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'diumenge, 14 febrer 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dg., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2n 02 febrer febr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 diumenge dg. Dg'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6a 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 febrer 2010'],
                ['LLL',                                '14 febrer 2010 15:25'],
                ['LLLL',                               'diumenge 14 febrer 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 febr. 2010'],
                ['lll',                                '14 febr. 2010 15:25'],
                ['llll',                               'dg. 14 febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1r', '1r');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2n', '2n');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3r', '3r');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4t', '4t');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'gener gen._febrer febr._mar mar._abril abr._maig mai._juny jun._juliol jul._agost ag._setembre set._octubre oct._novembre nov._desembre des.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'diumenge dg. Dg_dilluns dl. Dl_dimarts dt. Dt_dimecres dc. Dc_dijous dj. Dj_divendres dv. Dv_dissabte ds. Ds'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'uns segons', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuts',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuts',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'una hora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'una hora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hores',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hores',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hores',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un dia',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un dia',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dies',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un dia',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dies',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dies',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesos',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesos',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesos',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesos',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un any',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anys',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un any',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anys',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'en uns segons',  'prefix');
        assert.equal(moment(0).from(30000), 'fa uns segons', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fa uns segons',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'en uns segons', 'en uns segons');
        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 dies', 'en 5 dies');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                         'avui a les 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),          'avui a les 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),           'avui a les 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),           'dem a les 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'dem a la 1:00',   'tomorrow minus 1 hour');
        assert.equal(moment(a).subtract({h: 1}).calendar(),      'avui a la 1:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),      'ahir a les 2:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[el] dddd [passat a ' + ((m.hours() !== 1) ? 'les' : 'la') + '] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52a', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1a', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1a', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2a', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2a', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('cs');

    test('parse', function (assert) {
        var tests = 'leden led_nor no_bezen be_duben dub_kvten kv_erven vn_ervenec vc_srpen srp_z z_jen j_listopad lis_prosinec pro'.split('_'), i;
        function equalTest(input, mmm, monthIndex) {
            assert.equal(moment(input, mmm).month(), monthIndex, input + ' should be month ' + (monthIndex + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss',  'nedle, nor 14. 2010, 3:25:50'],
                ['ddd, h',                       'ne, 3'],
                ['M Mo MM MMMM MMM',             '2 2. 02 nor no'],
                ['YYYY YY',                      '2010 10'],
                ['D Do DD',                      '14 14. 14'],
                ['d do dddd ddd dd',             '0 0. nedle ne ne'],
                ['DDD DDDo DDDD',                '45 45. 045'],
                ['w wo ww',                      '6 6. 06'],
                ['h hh',                         '3 03'],
                ['H HH',                         '15 15'],
                ['m mm',                         '25 25'],
                ['s ss',                         '50 50'],
                ['a A',                          'pm PM'],
                ['DDDo [den v roce]',            '45. den v roce'],
                ['LTS',                          '15:25:50'],
                ['L',                            '14.02.2010'],
                ['LL',                           '14. nor 2010'],
                ['LLL',                          '14. nor 2010 15:25'],
                ['LLLL',                         'nedle 14. nor 2010 15:25'],
                ['l',                            '14.2.2010'],
                ['ll',                           '14. no 2010'],
                ['lll',                          '14. no 2010 15:25'],
                ['llll',                         'ne 14. no 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'leden led_nor no_bezen be_duben dub_kvten kv_erven vn_ervenec vc_srpen srp_z z_jen j_listopad lis_prosinec pro'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedle ne ne_pondl po po_ter t t_steda st st_tvrtek t t_ptek p p_sobota so so'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'pr sekund',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuta',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuta',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuty',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minut',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'hodina',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'hodina',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hodiny',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hodin',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hodin',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'den',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'den',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dny',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'den',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dn',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dn',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'msc',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'msc',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'msc',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 msce',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 msce',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 msce',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'msc',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 msc',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 roky',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 let',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za pr sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'ped pr sekundami', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ped pr sekundami',  'now from now should display as in the past');
    });

    test('fromNow (future)', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za pr sekund', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(), 'za minutu', 'in a minute');
        assert.equal(moment().add({m: 3}).fromNow(), 'za 3 minuty', 'in 3 minutes');
        assert.equal(moment().add({m: 10}).fromNow(), 'za 10 minut', 'in 10 minutes');
        assert.equal(moment().add({h: 1}).fromNow(), 'za hodinu', 'in an hour');
        assert.equal(moment().add({h: 3}).fromNow(), 'za 3 hodiny', 'in 3 hours');
        assert.equal(moment().add({h: 10}).fromNow(), 'za 10 hodin', 'in 10 hours');
        assert.equal(moment().add({d: 1}).fromNow(), 'za den', 'in a day');
        assert.equal(moment().add({d: 3}).fromNow(), 'za 3 dny', 'in 3 days');
        assert.equal(moment().add({d: 10}).fromNow(), 'za 10 dn', 'in 10 days');
        assert.equal(moment().add({M: 1}).fromNow(), 'za msc', 'in a month');
        assert.equal(moment().add({M: 3}).fromNow(), 'za 3 msce', 'in 3 months');
        assert.equal(moment().add({M: 10}).fromNow(), 'za 10 msc', 'in 10 months');
        assert.equal(moment().add({y: 1}).fromNow(), 'za rok', 'in a year');
        assert.equal(moment().add({y: 3}).fromNow(), 'za 3 roky', 'in 3 years');
        assert.equal(moment().add({y: 10}).fromNow(), 'za 10 let', 'in 10 years');
    });

    test('fromNow (past)', function (assert) {
        assert.equal(moment().subtract({s: 30}).fromNow(), 'ped pr sekundami', 'a few seconds ago');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'ped minutou', 'a minute ago');
        assert.equal(moment().subtract({m: 3}).fromNow(), 'ped 3 minutami', '3 minutes ago');
        assert.equal(moment().subtract({m: 10}).fromNow(), 'ped 10 minutami', '10 minutes ago');
        assert.equal(moment().subtract({h: 1}).fromNow(), 'ped hodinou', 'an hour ago');
        assert.equal(moment().subtract({h: 3}).fromNow(), 'ped 3 hodinami', '3 hours ago');
        assert.equal(moment().subtract({h: 10}).fromNow(), 'ped 10 hodinami', '10 hours ago');
        assert.equal(moment().subtract({d: 1}).fromNow(), 'ped dnem', 'a day ago');
        assert.equal(moment().subtract({d: 3}).fromNow(), 'ped 3 dny', '3 days ago');
        assert.equal(moment().subtract({d: 10}).fromNow(), 'ped 10 dny', '10 days ago');
        assert.equal(moment().subtract({M: 1}).fromNow(), 'ped mscem', 'a month ago');
        assert.equal(moment().subtract({M: 3}).fromNow(), 'ped 3 msci', '3 months ago');
        assert.equal(moment().subtract({M: 10}).fromNow(), 'ped 10 msci', '10 months ago');
        assert.equal(moment().subtract({y: 1}).fromNow(), 'ped rokem', 'a year ago');
        assert.equal(moment().subtract({y: 3}).fromNow(), 'ped 3 lety', '3 years ago');
        assert.equal(moment().subtract({y: 10}).fromNow(), 'ped 10 lety', '10 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'dnes v 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'dnes v 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'dnes v 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'ztra v 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'dnes v 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'vera v 2:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, nextDay;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            nextDay = '';
            switch (m.day()) {
            case 0:
                nextDay = 'v nedli';
                break;
            case 1:
                nextDay = 'v pondl';
                break;
            case 2:
                nextDay = 'v ter';
                break;
            case 3:
                nextDay = 've stedu';
                break;
            case 4:
                nextDay = 've tvrtek';
                break;
            case 5:
                nextDay = 'v ptek';
                break;
            case 6:
                nextDay = 'v sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [v] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, lastDay;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            lastDay = '';
            switch (m.day()) {
            case 0:
                lastDay = 'minulou nedli';
                break;
            case 1:
                lastDay = 'minul pondl';
                break;
            case 2:
                lastDay = 'minul ter';
                break;
            case 3:
                lastDay = 'minulou stedu';
                break;
            case 4:
                lastDay = 'minul tvrtek';
                break;
            case 5:
                lastDay = 'minul ptek';
                break;
            case 6:
                lastDay = 'minulou sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [v] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('humanize duration', function (assert) {
        assert.equal(moment.duration(1, 'minutes').humanize(), 'minuta', 'a minute (future)');
        assert.equal(moment.duration(1, 'minutes').humanize(true), 'za minutu', 'in a minute');
        assert.equal(moment.duration(-1, 'minutes').humanize(), 'minuta', 'a minute (past)');
        assert.equal(moment.duration(-1, 'minutes').humanize(true), 'ped minutou', 'a minute ago');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('cv');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      ',  14- 2010, 3:25:50 pm'],
                ['ddd, hA',                            ', 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2- 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14- 14'],
                ['d do dddd ddd dd',                   '0 0-   '],
                ['DDD DDDo DDDD',                      '45 45- 045'],
                ['w wo ww',                            '7 7- 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                [' DDDo ',                    ' 45- '],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '2010    14-'],
                ['LLL',                                '2010    14-, 15:25'],
                ['LLLL',                               ', 2010    14-, 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '2010    14-'],
                ['lll',                                '2010    14-, 15:25'],
                ['llll',                               ', 2010    14-, 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-', '1-');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-', '2-');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-', '3-');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-', '4-');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-', '5-');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-', '6-');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-', '7-');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-', '8-');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-', '9-');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-', '10-');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-', '11-');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-', '12-');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-', '13-');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-', '14-');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-', '15-');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-', '16-');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-', '17-');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-', '18-');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-', '19-');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-', '20-');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-', '21-');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-', '22-');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-', '23-');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-', '24-');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-', '25-');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-', '26-');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-', '27-');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-', '28-');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-', '29-');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-', '30-');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-', '31-');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '- ', '44 sekunder = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  ' ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '- ',  'prefix');
        assert.equal(moment(0).from(30000), '-  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '-  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '- ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ', 'in 5 days');
        assert.equal(moment().add({h: 2}).fromNow(), '2 ', 'in 2 hours, the right suffix!');
        assert.equal(moment().add({y: 3}).fromNow(), '3 ', 'in 3 years, the right suffix!');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);
        assert.equal(moment(a).calendar(),                   ' 02:00 ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      ' 02:25 ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       ' 03:00 ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       ' 02:00 ',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  ' 01:00 ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  ' 02:00 ',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd LT []'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd LT []'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd LT []'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd LT []'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd LT []'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd LT []'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 1st is the first week of the year.

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('cy');

    test('parse', function (assert) {
        var tests = 'Ionawr Ion_Chwefror Chwe_Mawrth Maw_Ebrill Ebr_Mai Mai_Mehefin Meh_Gorffennaf Gor_Awst Aws_Medi Med_Hydref Hyd_Tachwedd Tach_Rhagfyr Rhag'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Dydd Sul, Chwefror 14eg 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sul, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2il 02 Chwefror Chwe'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14eg 14'],
                ['d do dddd ddd dd',                   '0 0 Dydd Sul Sul Su'],
                ['DDD DDDo DDDD',                      '45 45ain 045'],
                ['w wo ww',                            '6 6ed 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45ain day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Chwefror 2010'],
                ['LLL',                                '14 Chwefror 2010 15:25'],
                ['LLLL',                               'Dydd Sul, 14 Chwefror 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Chwe 2010'],
                ['lll',                                '14 Chwe 2010 15:25'],
                ['llll',                               'Sul, 14 Chwe 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1af', '1af');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2il', '2il');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3ydd', '3ydd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4ydd', '4ydd');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5ed', '5ed');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6ed', '6ed');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7ed', '7ed');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8fed', '8fed');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9fed', '9fed');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10fed', '10fed');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11eg', '11eg');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12fed', '12fed');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13eg', '13eg');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14eg', '14eg');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15fed', '15fed');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16eg', '16eg');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17eg', '17eg');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18fed', '18fed');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19eg', '19eg');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20fed', '20fed');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ain', '21ain');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ain', '22ain');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ain', '23ain');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ain', '24ain');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ain', '25ain');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ain', '26ain');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ain', '27ain');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ain', '28ain');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ain', '29ain');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ain', '30ain');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ain', '31ain');
    });

    test('format month', function (assert) {
        var expected = 'Ionawr Ion_Chwefror Chwe_Mawrth Maw_Ebrill Ebr_Mai Mai_Mehefin Meh_Gorffennaf Gor_Awst Aws_Medi Med_Hydref Hyd_Tachwedd Tach_Rhagfyr Rhag'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Dydd Sul Sul Su_Dydd Llun Llun Ll_Dydd Mawrth Maw Ma_Dydd Mercher Mer Me_Dydd Iau Iau Ia_Dydd Gwener Gwe Gw_Dydd Sadwrn Sad Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ychydig eiliadau', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'munud',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'munud',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 munud',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 munud', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'awr',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'awr',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 awr',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 awr',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 awr',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'diwrnod',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'diwrnod',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 diwrnod',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'diwrnod',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 diwrnod',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 diwrnod',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mis',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mis',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mis',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mis',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mis',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mis',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mis',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mis',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'blwyddyn',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 flynedd',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'blwyddyn',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 flynedd',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'mewn ychydig eiliadau', 'prefix');
        assert.equal(moment(0).from(30000), 'ychydig eiliadau yn l', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'mewn ychydig eiliadau', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'mewn 5 diwrnod', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Heddiw am 02:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Heddiw am 02:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Heddiw am 03:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Yfory am 02:00',         'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Heddiw am 01:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ddoe am 02:00',           'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [am] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [diwethaf am] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ain', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1af', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1af', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2il', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2il', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('da');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_marts mar_april apr_maj maj_juni jun_juli jul_august aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd [den] Do MMMM YYYY, h:mm:ss a', 'sndag den 14. februar 2010, 3:25:50 pm'],
                ['ddd hA',                             'sn 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sndag sn s'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[den] DDDo [dag p ret]',           'den 45. dag p ret'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'sndag d. 14. februar 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14. feb 2010'],
                ['lll',                                '14. feb 2010 15:25'],
                ['llll',                               'sn d. 14. feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_marts mar_april apr_maj maj_juni jun_juli jul_august aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sndag sn s_mandag man ma_tirsdag tir ti_onsdag ons on_torsdag tor to_fredag fre fr_lrdag lr l'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'f sekunder', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'et minut',    '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'et minut',    '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutter',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutter', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en time',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en time',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timer',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timer',     '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timer',    '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dage',      '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dage',      '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dage',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mned',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mned',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mned',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mneder',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mneder',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mneder',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mned',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mneder',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'et r',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 r',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'et r',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 r',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om f sekunder',  'prefix');
        assert.equal(moment(0).from(30000), 'f sekunder siden', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'f sekunder siden',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om f sekunder', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dage', 'in 5 days');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('de-at');

    test('parse', function (assert) {
        var tests = 'Jnner Jn._Februar Febr._Mrz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a', 'Sonntag, 14. Februar 2010, 3:25:50 pm'],
                ['ddd, hA', 'So., 3PM'],
                ['M Mo MM MMMM MMM', '2 2. 02 Februar Febr.'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14. 14'],
                ['d do dddd ddd dd', '0 0. Sonntag So. So'],
                ['DDD DDDo DDDD', '45 45. 045'],
                ['w wo ww', '6 6. 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45. day of the year'],
                ['LTS', '15:25:50'],
                ['L', '14.02.2010'],
                ['LL', '14. Februar 2010'],
                ['LLL', '14. Februar 2010 15:25'],
                ['LLLL', 'Sonntag, 14. Februar 2010 15:25'],
                ['l', '14.2.2010'],
                ['ll', '14. Febr. 2010'],
                ['lll', '14. Febr. 2010 15:25'],
                ['llll', 'So., 14. Febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'Jnner Jn._Februar Febr._Mrz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sonntag So. So_Montag Mo. Mo_Dienstag Di. Di_Mittwoch Mi. Mi_Donnerstag Do. Do_Freitag Fr. Fr_Samstag Sa. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'ein paar Sekunden', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'eine Minute', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'eine Minute', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 Minuten', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 Minuten', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'eine Stunde', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'eine Stunde', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 Stunden', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 Stunden', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 Stunden', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'ein Tag', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'ein Tag', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 Tage', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'ein Tag', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 Tage', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 Tage', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'ein Monat', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'ein Monat', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 Monate', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 Monate', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 Monate', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'ein Monat', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 Monate', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ein Jahr', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Jahre', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ein Jahr', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 Jahre', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in ein paar Sekunden', 'prefix');
        assert.equal(moment(0).from(30000), 'vor ein paar Sekunden', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in ein paar Sekunden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 Tagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(), 'Heute um 02:00 Uhr', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(), 'Heute um 02:25 Uhr', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(), 'Heute um 03:00 Uhr', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(), 'Morgen um 02:00 Uhr', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(), 'Heute um 01:00 Uhr', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(), 'Gestern um 02:00 Uhr', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [um] LT [Uhr]'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('[letzten] dddd [um] LT [Uhr]'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(), 1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(), 1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(), 2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(), 2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008, 0, 1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008, 0, 6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008, 0, 7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008, 0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008, 0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003, 0, 1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003, 0, 5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003, 0, 6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003, 0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003, 0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009, 0, 1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009, 0, 4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009, 0, 5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009, 0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009, 0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010, 0, 1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010, 0, 3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010, 0, 4]).week(), 1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010, 0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010, 0, 11]).week(), 2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011, 0, 1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011, 0, 2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011, 0, 3]).week(), 1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011, 0, 9]).week(), 1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011, 0, 10]).week(), 2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('de');

    test('parse', function (assert) {
        var tests = 'Januar Jan._Februar Febr._Mrz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'Sonntag, 14. Februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'So., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 Februar Febr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. Sonntag So. So'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. Februar 2010'],
                ['LLL',                                '14. Februar 2010 15:25'],
                ['LLLL',                               'Sonntag, 14. Februar 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. Febr. 2010'],
                ['lll',                                '14. Febr. 2010 15:25'],
                ['llll',                               'So., 14. Febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'Januar Jan._Februar Febr._Mrz Mrz._April Apr._Mai Mai_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sonntag So. So_Montag Mo. Mo_Dienstag Di. Di_Mittwoch Mi. Mi_Donnerstag Do. Do_Freitag Fr. Fr_Samstag Sa. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ein paar Sekunden',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'eine Minute',       '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'eine Minute',       '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 Minuten',          '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 Minuten',         '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'eine Stunde',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'eine Stunde',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 Stunden',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 Stunden',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 Stunden',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein Tag',          '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein Tag',          '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 Tage',            '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein Tag',          '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 Tage',            '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 Tage',           '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein Monat',        '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein Monat',        '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein Monat',        '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 Monate',          '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 Monate',          '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 Monate',          '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein Monat',        '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 Monate',          '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ein Jahr',         '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Jahre',           '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ein Jahr',         '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 Jahre',           '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in ein paar Sekunden', 'prefix');
        assert.equal(moment(0).from(30000), 'vor ein paar Sekunden', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in ein paar Sekunden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 Tagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Heute um 02:00 Uhr',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Heute um 02:25 Uhr',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Heute um 03:00 Uhr',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Morgen um 02:00 Uhr',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Heute um 01:00 Uhr',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Gestern um 02:00 Uhr', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [um] LT [Uhr]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[letzten] dddd [um] LT [Uhr]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('el');

    test('parse', function (assert) {
        var i,
            tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse meridiem', function (assert) {
        var i,
            b = moment(),
            meridiemTests = [
                // h a patterns, expected hours, isValid
                ['10 ',   10, true],
                ['10 ',   22, true],
                ['10 ..', 10, true],
                ['10 ..', 22, true],
                ['10 ',    10, true],
                ['10 ',    22, true],
                ['10 ',   10, true],
                ['10 ',   22, true],
                ['10 ..', 10, true],
                ['10 ..', 22, true],
                ['10 ',    10, true],
                ['10 ',    22, true],
                ['10 am',   10, false],
                ['10 pm',   10, false]
            ];

        // test that a formatted moment including meridiem string can be parsed back to the same moment
        assert.ok(b.isSame(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true), 'seconds'), b.format('h:mm:ss a') + ' should be equal to ' + moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true).format('h:mm:ss a'));

        // test that a formatted moment having a meridiem string can be parsed with strict flag
        assert.ok(moment(b.format('h:mm:ss a'), 'h:mm:ss a', 'el', true).isValid(), b.format('h:mm:ss a') + ' should be parsed as valid');

        for (i = 0; i < meridiemTests.length; i++) {
            assert.equal(moment(meridiemTests[i][0], 'h a', 'el', true).hours(), meridiemTests[i][1], moment(meridiemTests[i][0], 'h a', 'el', true).hours() + ' should be ' + meridiemTests[i][1]);
            assert.ok(moment(meridiemTests[i][0], 'h a', 'el', true).isValid() === meridiemTests[i][2], meridiemTests[i][0] + ' ----> ' + meridiemTests[i][2]);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      ',  14 2010, 3:25:50 '],
                ['dddd, D MMMM YYYY, h:mm:ss a',       ', 14  2010, 3:25:50 '],
                ['ddd, hA',                            ', 3'],
                ['dddd, MMMM YYYY',                    ',  2010'],
                ['M Mo MM MMMM MMM',                   '2 2 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '3:25:50 '],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14  2010'],
                ['LLL',                                '14  2010 3:25 '],
                ['LLLL',                               ', 14  2010 3:25 '],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14  2010'],
                ['lll',                                '14  2010 3:25 '],
                ['llll',                               ', 14  2010 3:25 ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = '  _  _  _  _  _  _  '.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',           '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',           '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',             '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',            '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',             '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',             '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',              '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',              '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',             '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',            '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',            '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',             '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',            '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',             '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',            '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',          '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',          '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  ' ',          '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',             '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',             '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',             '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',          '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',             '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',         '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',            '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',         '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',            '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  2:00 ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  2:25 ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  3:00 ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  2:00 ',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  1:00 ',        'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  2:00 ',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [' + (m.hours() % 12 === 1 ? '' : '') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, dayString;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            dayString = m.day() === 6 ? '[  ]' : '[ ] dddd';
            assert.equal(m.calendar(),       m.format(dayString + ' [' + (m.hours() % 12 === 1 ? '' : '') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(1).minutes(30).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(dayString + ' [] LT'),  'Today - ' + i + ' days one o clock');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(dayString + ' [] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(dayString + ' [] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 52, 'Dec 31 2006 should be week 52');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 30]).week(), 52, 'Dec 30 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 52, 'Dec 29 2002 should be week 52');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 52, 'Dec 28 2008 should be week 52');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 52, 'Dec 27 2009 should be week 52');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  2]).week(), 53, 'Jan  2 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  9]).week(), 1, 'Jan  9 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(), 2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 51, 'Dec 26 2010 should be week 51');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  8]).week(), 1, 'Jan  8 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(), 1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(), 2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'),   '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'),   '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('en-au');

    test('parse', function (assert) {
        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '6 6th 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '3:25:50 PM'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 February 2010'],
                ['LLL',                                '14 February 2010 3:25 PM'],
                ['LLLL',                               'Sunday, 14 February 2010 3:25 PM'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 3:25 PM'],
                ['llll',                               'Sun, 14 Feb 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Today at 2:00 AM',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 2:25 AM',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 3:00 AM',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 2:00 AM',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 1:00 AM',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 2:00 AM',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testStr;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testStr = moment(ordinalStr, 'YYYY MM Do').format('YYYY MM D');
            assert.equal(testStr, '2014 01 ' + i, 'lenient ordinal parsing ' + i);
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testStr;
        for (i = 1; i <= 31; ++i) {
            testStr = moment('2014 01 ' + i, 'YYYY MM Do').format('YYYY MM D');
            assert.equal(testStr, '2014 01 ' + i,
                    'lenient ordinal parsing of number ' + i);
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MMM Do');
            testMoment = moment(ordinalStr, 'YYYY MMM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('en-ca');

    test('parse', function (assert) {
        var i,
            tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '8 8th 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['L',                                  '2010-02-14'],
                ['LTS',                                '3:25:50 PM'],
                ['LL',                                 '14 February, 2010'],
                ['LLL',                                '14 February, 2010 3:25 PM'],
                ['LLLL',                               'Sunday, 14 February, 2010 3:25 PM'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14 Feb, 2010'],
                ['lll',                                '14 Feb, 2010 3:25 PM'],
                ['llll',                               'Sun, 14 Feb, 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var i,
            expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Today at 2:00 AM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 2:25 AM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 3:00 AM',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 2:00 AM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 1:00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 2:00 AM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1st', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1st', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2nd', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2nd', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3rd', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('en-gb');

    test('parse', function (assert) {
        var tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '6 6th 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 February 2010'],
                ['LLL',                                '14 February 2010 15:25'],
                ['LLLL',                               'Sunday, 14 February 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 15:25'],
                ['llll',                               'Sun, 14 Feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Today at 02:00',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 02:25',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 03:00',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 02:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 01:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 02:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52nd', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1st', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1st', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2nd', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2nd', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('en');

    test('parse', function (assert) {
        var i,
            tests = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Sunday, February 14th 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2nd 02 February Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14th 14'],
                ['d do dddd ddd dd',                   '0 0th Sunday Sun Su'],
                ['DDD DDDo DDDD',                      '45 45th 045'],
                ['w wo ww',                            '8 8th 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45th day of the year'],
                ['LTS',                                '3:25:50 PM'],
                ['L',                                  '02/14/2010'],
                ['LL',                                 'February 14, 2010'],
                ['LLL',                                'February 14, 2010 3:25 PM'],
                ['LLLL',                               'Sunday, February 14, 2010 3:25 PM'],
                ['l',                                  '2/14/2010'],
                ['ll',                                 'Feb 14, 2010'],
                ['lll',                                'Feb 14, 2010 3:25 PM'],
                ['llll',                               'Sun, Feb 14, 2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1st', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2nd', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3rd', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4th', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5th', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6th', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7th', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8th', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9th', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10th', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11th', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12th', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13th', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14th', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15th', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16th', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17th', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18th', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19th', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20th', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21st', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22nd', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23rd', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24th', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25th', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26th', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27th', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28th', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29th', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30th', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31st', '31st');
    });

    test('format month', function (assert) {
        var i,
            expected = 'January Jan_February Feb_March Mar_April Apr_May May_June Jun_July Jul_August Aug_September Sep_October Oct_November Nov_December Dec'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Sunday Sun Su_Monday Mon Mo_Tuesday Tue Tu_Wednesday Wed We_Thursday Thu Th_Friday Fri Fr_Saturday Sat Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'a month',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 months',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 months',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 months',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 years',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 years',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in a few seconds',  'prefix');
        assert.equal(moment(0).from(30000), 'a few seconds ago', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'a few seconds ago',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in a few seconds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'in 5 days', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Today at 2:00 AM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at 2:25 AM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at 3:00 AM',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at 2:00 AM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at 1:00 AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at 2:00 AM', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [at] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Last] dddd [at] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1st', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1st', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2nd', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2nd', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3rd', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('eo');

    test('parse', function (assert) {
        var tests = 'januaro jan_februaro feb_marto mar_aprilo apr_majo maj_junio jun_julio jul_agusto ag_septembro sep_oktobro okt_novembro nov_decembro dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Dimano, februaro 14a 2010, 3:25:50 p.t.m.'],
                ['ddd, hA',                            'Dim, 3P.T.M.'],
                ['M Mo MM MMMM MMM',                   '2 2a 02 februaro feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14a 14'],
                ['d do dddd ddd dd',                   '0 0a Dimano Dim Di'],
                ['DDD DDDo DDDD',                      '45 45a 045'],
                ['w wo ww',                            '7 7a 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'p.t.m. P.T.M.'],
                ['[la] DDDo [tago] [de] [la] [jaro]',  'la 45a tago de la jaro'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '14-an de februaro, 2010'],
                ['LLL',                                '14-an de februaro, 2010 15:25'],
                ['LLLL',                               'Dimano, la 14-an de februaro, 2010 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14-an de feb, 2010'],
                ['lll',                                '14-an de feb, 2010 15:25'],
                ['llll',                               'Dim, la 14-an de feb, 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a', '1a');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2a', '2a');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3a', '3a');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4a', '4a');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5a', '5a');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6a', '6a');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7a', '7a');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8a', '8a');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9a', '9a');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10a', '10a');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11a', '11a');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12a', '12a');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13a', '13a');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14a', '14a');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15a', '15a');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16a', '16a');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17a', '17a');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18a', '18a');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19a', '19a');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20a', '20a');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21a', '21a');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22a', '22a');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23a', '23a');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24a', '24a');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25a', '25a');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26a', '26a');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27a', '27a');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28a', '28a');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29a', '29a');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30a', '30a');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31a', '31a');
    });

    test('format month', function (assert) {
        var expected = 'januaro jan_februaro feb_marto mar_aprilo apr_majo maj_junio jun_julio jul_agusto ag_septembro sep_oktobro okt_novembro nov_decembro dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Dimano Dim Di_Lundo Lun Lu_Mardo Mard Ma_Merkredo Merk Me_ado a a_Vendredo Ven Ve_Sabato Sab Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'sekundoj', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutoj',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutoj',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'horo',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'horo',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horoj',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horoj',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horoj',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'tago',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'tago',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 tagoj',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'tago',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 tagoj',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 tagoj',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'monato',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'monato',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'monato',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 monatoj',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 monatoj',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 monatoj',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'monato',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 monatoj',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'jaro',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaroj',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'jaro',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaroj',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'je sekundoj',  'je prefix');
        assert.equal(moment(0).from(30000), 'anta sekundoj', 'anta prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'anta sekundoj',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'je sekundoj', 'je sekundoj');
        assert.equal(moment().add({d: 5}).fromNow(), 'je 5 tagoj', 'je 5 tagoj');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hodia je 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hodia je 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hodia je 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Morga je 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hodia je 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hiera je 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [je] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[pasinta] dddd [je] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1a', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1a', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2a', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2a', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3a', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('es');

    test('parse', function (assert) {
        var tests = 'enero ene._febrero feb._marzo mar._abril abr._mayo may._junio jun._julio jul._agosto ago._septiembre sep._octubre oct._noviembre nov._diciembre dic.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Febrero 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Febrero Feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Domingo Dom. Do'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['YYYY-MMM-DD',                        '2010-Feb-14'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 de Febrero de 2010'],
                ['LLL',                                '14 de Febrero de 2010 15:25'],
                ['LLLL',                               'Domingo, 14 de Febrero de 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 de Feb. de 2010'],
                ['lll',                                '14 de Feb. de 2010 15:25'],
                ['llll',                               'Dom., 14 de Feb. de 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'Enero Ene._Febrero Feb._Marzo Mar._Abril Abr._Mayo May._Junio Jun._Julio Jul._Agosto Ago._Septiembre Sep._Octubre Oct._Noviembre Nov._Diciembre Dic.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom. Do_Lunes Lun. Lu_Martes Mar. Ma_Mircoles Mi. Mi_Jueves Jue. Ju_Viernes Vie. Vi_Sbado Sb. S'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'unos segundos', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'una hora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'una hora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un da',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un da',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 das',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un da',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 das',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 das',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un ao',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 aos',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un ao',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 aos',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'en unos segundos',  'prefix');
        assert.equal(moment(0).from(30000), 'hace unos segundos', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'hace unos segundos',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'en unos segundos', 'en unos segundos');
        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 das', 'en 5 das');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                         'hoy a las 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),          'hoy a las 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),           'hoy a las 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),           'maana a las 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'maana a la 1:00',   'tomorrow minus 1 hour');
        assert.equal(moment(a).subtract({h: 1}).calendar(),      'hoy a la 1:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),      'ayer a las 2:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[el] dddd [pasado a la' + ((m.hours() !== 1) ? 's' : '') + '] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('et');

    test('parse', function (assert) {
        var tests = 'jaanuar jaan_veebruar veebr_mrts mrts_aprill apr_mai mai_juuni juuni_juuli juuli_august aug_september sept_oktoober okt_november nov_detsember dets'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' peaks olema kuu ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, H:mm:ss',      'phapev, 14. veebruar 2010, 15:25:50'],
                ['ddd, h',                           'P, 3'],
                ['M Mo MM MMMM MMM',                 '2 2. 02 veebruar veebr'],
                ['YYYY YY',                          '2010 10'],
                ['D Do DD',                          '14 14. 14'],
                ['d do dddd ddd dd',                 '0 0. phapev P P'],
                ['DDD DDDo DDDD',                    '45 45. 045'],
                ['w wo ww',                          '6 6. 06'],
                ['h hh',                             '3 03'],
                ['H HH',                             '15 15'],
                ['m mm',                             '25 25'],
                ['s ss',                             '50 50'],
                ['a A',                              'pm PM'],
                ['[aasta] DDDo [pev]',              'aasta 45. pev'],
                ['LTS',                              '15:25:50'],
                ['L',                                '14.02.2010'],
                ['LL',                               '14. veebruar 2010'],
                ['LLL',                              '14. veebruar 2010 15:25'],
                ['LLLL',                             'phapev, 14. veebruar 2010 15:25'],
                ['l',                                '14.2.2010'],
                ['ll',                               '14. veebr 2010'],
                ['lll',                              '14. veebr 2010 15:25'],
                ['llll',                             'P, 14. veebr 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'jaanuar jaan_veebruar veebr_mrts mrts_aprill apr_mai mai_juuni juuni_juuli juuli_august aug_september sept_oktoober okt_november nov_detsember dets'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'phapev P P_esmaspev E E_teisipev T T_kolmapev K K_neljapev N N_reede R R_laupev L L'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'paar sekundit',  '44 seconds = paar sekundit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ks minut',      '45 seconds = ks minut');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ks minut',      '89 seconds = ks minut');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutit',      '90 seconds = 2 minutit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutit',     '44 minutes = 44 minutit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ks tund',       '45 minutes = tund aega');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ks tund',       '89 minutes = ks tund');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tundi',        '90 minutes = 2 tundi');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tundi',        '5 hours = 5 tundi');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tundi',       '21 hours = 21 tundi');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ks pev',       '22 hours = ks pev');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ks pev',       '35 hours = ks pev');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 peva',        '36 hours = 2 peva');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ks pev',       '1 day = ks pev');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 peva',        '5 days = 5 peva');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 peva',       '25 days = 25 peva');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ks kuu',        '26 days = ks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ks kuu',        '30 days = ks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ks kuu',        '43 days = ks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 kuud',         '46 days = 2 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 kuud',         '75 days = 2 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 kuud',         '76 days = 3 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ks kuu',        '1 month = ks kuu');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 kuud',         '5 months = 5 kuud');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ks aasta',      '345 days = ks aasta');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 aastat',       '548 days = 2 aastat');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ks aasta',      '1 year = ks aasta');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 aastat',       '5 years = 5 aastat');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'mne sekundi prast',  'prefix');
        assert.equal(moment(0).from(30000), 'mni sekund tagasi', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'mni sekund tagasi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'mne sekundi prast', 'in a few seconds');
        assert.equal(moment().subtract({s: 30}).fromNow(), 'mni sekund tagasi', 'a few seconds ago');

        assert.equal(moment().add({m: 1}).fromNow(), 'he minuti prast', 'in a minute');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'ks minut tagasi', 'a minute ago');

        assert.equal(moment().add({m: 5}).fromNow(), '5 minuti prast', 'in 5 minutes');
        assert.equal(moment().subtract({m: 5}).fromNow(), '5 minutit tagasi', '5 minutes ago');

        assert.equal(moment().add({d: 1}).fromNow(), 'he peva prast', 'in one day');
        assert.equal(moment().subtract({d: 1}).fromNow(), 'ks pev tagasi', 'one day ago');

        assert.equal(moment().add({d: 5}).fromNow(), '5 peva prast', 'in 5 days');
        assert.equal(moment().subtract({d: 5}).fromNow(), '5 peva tagasi', '5 days ago');

        assert.equal(moment().add({M: 1}).fromNow(), 'kuu aja prast', 'in a month');
        assert.equal(moment().subtract({M: 1}).fromNow(), 'kuu aega tagasi', 'a month ago');

        assert.equal(moment().add({M: 5}).fromNow(), '5 kuu prast', 'in 5 months');
        assert.equal(moment().subtract({M: 5}).fromNow(), '5 kuud tagasi', '5 months ago');

        assert.equal(moment().add({y: 1}).fromNow(), 'he aasta prast', 'in a year');
        assert.equal(moment().subtract({y: 1}).fromNow(), 'aasta tagasi', 'a year ago');

        assert.equal(moment().add({y: 5}).fromNow(), '5 aasta prast', 'in 5 years');
        assert.equal(moment().subtract({y: 5}).fromNow(), '5 aastat tagasi', '5 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Tna, 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Tna, 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Tna, 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Homme, 2:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Tna, 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Eile, 2:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[Jrgmine] dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Jrgmine] dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Jrgmine] dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Eelmine] dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 ndal tagasi');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '1 ndala prast');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 ndalat tagasi');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 ndala prast');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('eu');

    test('parse', function (assert) {
        var tests = 'urtarrila urt._otsaila ots._martxoa mar._apirila api._maiatza mai._ekaina eka._uztaila uzt._abuztua abu._iraila ira._urria urr._azaroa aza._abendua abe.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'igandea, otsaila 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ig., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 otsaila ots.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. igandea ig. ig'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '2010ko otsailaren 14a'],
                ['LLL',                                '2010ko otsailaren 14a 15:25'],
                ['LLLL',                               'igandea, 2010ko otsailaren 14a 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '2010ko ots. 14a'],
                ['lll',                                '2010ko ots. 14a 15:25'],
                ['llll',                               'ig., 2010ko ots. 14a 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'urtarrila urt._otsaila ots._martxoa mar._apirila api._maiatza mai._ekaina eka._uztaila uzt._abuztua abu._iraila ira._urria urr._azaroa aza._abendua abe.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'igandea ig. ig_astelehena al. al_asteartea ar. ar_asteazkena az. az_osteguna og. og_ostirala ol. ol_larunbata lr. lr'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'segundo batzuk', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minutu bat',     '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minutu bat',     '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutu',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutu',      '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ordu bat',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ordu bat',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ordu',         '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ordu',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ordu',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'egun bat',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'egun bat',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 egun',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'egun bat',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 egun',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 egun',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'hilabete bat',   '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'hilabete bat',   '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'hilabete bat',   '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 hilabete',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 hilabete',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 hilabete',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'hilabete bat',   '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 hilabete',     '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'urte bat',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 urte',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'urte bat',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 urte',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'segundo batzuk barru',  'prefix');
        assert.equal(moment(0).from(30000), 'duela segundo batzuk', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'duela segundo batzuk',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'segundo batzuk barru', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 egun barru', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'gaur 02:00etan',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'gaur 02:25etan',  'now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'gaur 03:00etan',  'now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'bihar 02:00etan', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'gaur 01:00etan',  'now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'atzo 02:00etan',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT[etan]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[aurreko] dddd LT[etan]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fa');

    test('parse', function (assert) {
        var tests = '___________'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1) + ' instead is month ' + moment(input, mmm).month());
        }
        for (i = 0; i < 12; i++) {
            equalTest(tests[i], 'MMM', i);
            equalTest(tests[i], 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      '\u200c    ::   '],
                ['ddd, hA',                            '\u200c   '],
                ['M Mo MM MMMM MMM',                   '    '],
                ['YYYY YY',                            ' '],
                ['D Do DD',                            '  '],
                ['d do dddd ddd dd',                   '  \u200c \u200c '],
                ['DDD DDDo DDDD',                      '  '],
                ['w wo ww',                            '  '],
                ['h hh',                               ' '],
                ['H HH',                               ' '],
                ['m mm',                               ' '],
                ['s ss',                               ' '],
                ['a A',                                '     '],
                ['DDDo [ ]',             '  '],
                ['LTS',                                '::'],
                ['L',                                  '//'],
                ['LL',                                 '  '],
                ['LLL',                                '   :'],
                ['LLLL',                               '\u200c    :'],
                ['l',                                  '//'],
                ['ll',                                 '  '],
                ['lll',                                '   :'],
                ['llll',                               '\u200c    :']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '', '31');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '\u200c \u200c _  _\u200c \u200c _  _\u200c \u200c _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',       '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',       '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  ' ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  ' ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  ' ',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   ' ',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  ' ',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  ' ',       '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   ' ',       '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  ' ',      '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',      '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',      '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  ' ',      '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  ' ',       '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  ' ',       '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  ' ',       '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',      '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   ' ',       '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',      '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), ' ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',      '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   ' ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ', 'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '  ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  :', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  :', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  :', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  :', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  :', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  :', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '  ', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '  ', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '  ', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '  ', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '  ', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fi');

    test('parse', function (assert) {
        var tests = 'tammikuu tammi_helmikuu helmi_maaliskuu maalis_huhtikuu huhti_toukokuu touko_keskuu kes_heinkuu hein_elokuu elo_syyskuu syys_lokakuu loka_marraskuu marras_joulukuu joulu'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sunnuntai, helmikuu 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'su, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 helmikuu helmi'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sunnuntai su su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[vuoden] DDDo [piv]',              'vuoden 45. piv'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. helmikuuta 2010'],
                ['LLL',                                '14. helmikuuta 2010, klo 15.25'],
                ['LLLL',                               'sunnuntai, 14. helmikuuta 2010, klo 15.25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. helmi 2010'],
                ['lll',                                '14. helmi 2010, klo 15.25'],
                ['llll',                               'su, 14. helmi 2010, klo 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31st');
    });

    test('format month', function (assert) {
        var expected = 'tammikuu tammi_helmikuu helmi_maaliskuu maalis_huhtikuu huhti_toukokuu touko_keskuu kes_heinkuu hein_elokuu elo_syyskuu syys_lokakuu loka_marraskuu marras_joulukuu joulu'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sunnuntai su su_maanantai ma ma_tiistai ti ti_keskiviikko ke ke_torstai to to_perjantai pe pe_lauantai la la'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'muutama sekunti', '44 seconds = few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuutti',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuutti',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  'kaksi minuuttia',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuuttia',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'tunti',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'tunti',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  'kaksi tuntia',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   'viisi tuntia',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tuntia',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'piv',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'piv',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  'kaksi piv',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'piv',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   'viisi piv',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 piv',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'kuukausi',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'kuukausi',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'kuukausi',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  'kaksi kuukautta',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  'kaksi kuukautta',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  'kolme kuukautta',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'kuukausi',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   'viisi kuukautta',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'vuosi',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), 'kaksi vuotta',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'vuosi',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   'viisi vuotta',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'muutaman sekunnin pst',  'prefix');
        assert.equal(moment(0).from(30000), 'muutama sekunti sitten', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'muutama sekunti sitten',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'muutaman sekunnin pst', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'viiden pivn pst', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'tnn klo 02.00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'tnn klo 02.25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'tnn klo 03.00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'huomenna klo 02.00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'tnn klo 01.00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'eilen klo 02.00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [klo] LT'),  'today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[viime] dddd[na] [klo] LT'),  'today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'yksi viikko sitten');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'yhden viikon pst');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'kaksi viikkoa sitten');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'kaden viikon pst');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fo');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_mars mar_aprl apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd [tann] Do MMMM YYYY, h:mm:ss a', 'sunnudagur tann 14. februar 2010, 3:25:50 pm'],
                ['ddd hA',                             'sun 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sunnudagur sun su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[tann] DDDo [dagin  rinum]',       'tann 45. dagin  rinum'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 februar 2010'],
                ['LLL',                                '14 februar 2010 15:25'],
                ['LLLL',                               'sunnudagur 14. februar, 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'sun 14. feb, 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_mars mar_aprl apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sunnudagur sun su_mnadagur mn m_tsdagur ts t_mikudagur mik mi_hsdagur hs h_frggjadagur fr fr_leygardagur ley le'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'f sekund', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ein minutt',    '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ein minutt',    '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuttir',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuttir', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ein tmi',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ein tmi',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tmar',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tmar',     '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tmar',    '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein dagur',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein dagur',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',      '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein dagur',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',      '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein mnai',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein mnai',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein mnai',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mnair',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mnair',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mnair',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein mnai',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mnair',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eitt r',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 r',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eitt r',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 r',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'um f sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'f sekund sani', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'f sekund sani',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'um f sekund', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'um 5 dagar', 'in 5 days');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fr-ca');

    test('parse', function (assert) {
        var i,
            tests = 'janvier janv._fvrier fvr._mars mars_avril avr._mai mai_juin juin_juillet juil._aot aot_septembre sept._octobre oct._novembre nov._dcembre dc.'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, fvrier 14e 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dim., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2e 02 fvrier fvr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14e 14'],
                ['d do dddd ddd dd',                   '0 0e dimanche dim. Di'],
                ['DDD DDDo DDDD',                      '45 45e 045'],
                ['w wo ww',                            '8 8e 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45e day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '14 fvrier 2010'],
                ['LLL',                                '14 fvrier 2010 15:25'],
                ['LLLL',                               'dimanche 14 fvrier 2010 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14 fvr. 2010'],
                ['lll',                                '14 fvr. 2010 15:25'],
                ['llll',                               'dim. 14 fvr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2e', '2e');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3e', '3e');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4e', '4e');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5e', '5e');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6e', '6e');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7e', '7e');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8e', '8e');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9e', '9e');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10e', '10e');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11e', '11e');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12e', '12e');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13e', '13e');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14e', '14e');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15e', '15e');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16e', '16e');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17e', '17e');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18e', '18e');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19e', '19e');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20e', '20e');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21e', '21e');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22e', '22e');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23e', '23e');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24e', '24e');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25e', '25e');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26e', '26e');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27e', '27e');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28e', '28e');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29e', '29e');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30e', '30e');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31e', '31e');
    });

    test('format month', function (assert) {
        var i,
            expected = 'janvier janv._fvrier fvr._mars mars_avril avr._mai mai_juin juin_juillet juil._aot aot_septembre sept._octobre oct._novembre nov._dcembre dc.'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');
        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Aujourd\'hui  02:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\'hui  02:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\'hui  03:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain  02:00',         'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\'hui  01:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier  02:00',           'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [dernier ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [dernier ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [dernier ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1er', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1er', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2e', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2e', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3e', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fr');

    test('parse', function (assert) {
        var tests = 'janvier janv._fvrier fvr._mars mars_avril avr._mai mai_juin juin_juillet juil._aot aot_septembre sept._octobre oct._novembre nov._dcembre dc.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'dimanche, fvrier 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'dim., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 fvrier fvr.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 dimanche dim. Di'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 fvrier 2010'],
                ['LLL',                                '14 fvrier 2010 15:25'],
                ['LLLL',                               'dimanche 14 fvrier 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 fvr. 2010'],
                ['lll',                                '14 fvr. 2010 15:25'],
                ['llll',                               'dim. 14 fvr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1er', '1er');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'janvier janv._fvrier fvr._mars mars_avril avr._mai mai_juin juin_juillet juil._aot aot_septembre sept._octobre oct._novembre nov._dcembre dc.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'dimanche dim. Di_lundi lun. Lu_mardi mar. Ma_mercredi mer. Me_jeudi jeu. Je_vendredi ven. Ve_samedi sam. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'quelques secondes', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'une minute',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'une minute',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutes',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutes', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'une heure',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'une heure',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 heures',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 heures',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 heures',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un jour',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un jour',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 jours',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un jour',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 jours',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 jours',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mois',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mois',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mois',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mois',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mois',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mois',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mois',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mois',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ans',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ans',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dans quelques secondes', 'prefix');
        assert.equal(moment(0).from(30000), 'il y a quelques secondes', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dans quelques secondes', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dans 5 jours', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Aujourd\'hui  02:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Aujourd\'hui  02:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Aujourd\'hui  03:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Demain  02:00',         'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Aujourd\'hui  01:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hier  02:00',           'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [dernier ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [dernier ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [dernier ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1er', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1er', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('fy');

    test('parse', function (assert) {
        var tests = 'jannewaris jan._febrewaris feb._maart mrt._april apr._maaie mai._juny jun._july jul._augustus aug._septimber sep._oktober okt._novimber nov._desimber des.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',       'snein, febrewaris 14de 2010, 15:25:50'],
                ['ddd, HH',                            'si., 15'],
                ['M Mo MM MMMM MMM',                   '2 2de 02 febrewaris feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14de 14'],
                ['d do dddd ddd dd',                   '0 0de snein si. Si'],
                ['DDD DDDo DDDD',                      '45 45ste 045'],
                ['w wo ww',                            '6 6de 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '14 febrewaris 2010'],
                ['LLL',                                '14 febrewaris 2010 15:25'],
                ['LLLL',                               'snein 14 febrewaris 2010 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '14 feb. 2010'],
                ['lll',                                '14 feb. 2010 15:25'],
                ['llll',                               'si. 14 feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');
    });

    test('format month', function (assert) {
        var expected = 'jannewaris jan._febrewaris feb._maart mrt._april apr._maaie mai_juny jun._july jul._augustus aug._septimber sep._oktober okt._novimber nov._desimber des.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'snein si. Si_moandei mo. Mo_tiisdei ti. Ti_woansdei wo. Wo_tongersdei to. To_freed fr. Fr_sneon so. So'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'in pear sekonden', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ien mint',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ien mint',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuten',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuten',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ien oere',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ien oere',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 oeren',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 oeren',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 oeren',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ien dei',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ien dei',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagen',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ien dei',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagen',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagen',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ien moanne',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ien moanne',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ien moanne',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 moannen',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 moannen',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 moannen',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ien moanne',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 moannen',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ien jier',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jierren',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ien jier',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jierren',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'oer in pear sekonden',  'prefix');
        assert.equal(moment(0).from(30000), 'in pear sekonden lyn', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'in pear sekonden lyn',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'oer in pear sekonden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'oer 5 dagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'hjoed om 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'hjoed om 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'hjoed om 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'moarn om 02:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'hjoed om 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juster om 02:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[frne] dddd [om] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[frne] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[frne] dddd [om] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('month abbreviation', function (assert) {
        assert.equal(moment([2012, 5, 23]).format('D-MMM-YYYY'), '23-jun-2012', 'format month abbreviation surrounded by dashes should not include a dot');
        assert.equal(moment([2012, 5, 23]).format('D MMM YYYY'), '23 jun. 2012', 'format month abbreviation not surrounded by dashes should include a dot');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('gl');

    test('parse', function (assert) {
        var tests = 'Xaneiro Xan._Febreiro Feb._Marzo Mar._Abril Abr._Maio Mai._Xuo Xu._Xullo Xul._Agosto Ago._Setembro Set._Outubro Out._Novembro Nov._Decembro Dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Febreiro 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Febreiro Feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Domingo Dom. Do'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Febreiro 2010'],
                ['LLL',                                '14 Febreiro 2010 15:25'],
                ['LLLL',                               'Domingo 14 Febreiro 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb. 2010'],
                ['lll',                                '14 Feb. 2010 15:25'],
                ['llll',                               'Dom. 14 Feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'Xaneiro Xan._Febreiro Feb._Marzo Mar._Abril Abr._Maio Mai._Xuo Xu._Xullo Xul._Agosto Ago._Setembro Set._Outubro Out._Novembro Nov._Decembro Dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom. Do_Luns Lun. Lu_Martes Mar. Ma_Mrcores Mr. M_Xoves Xov. Xo_Venres Ven. Ve_Sbado Sb. S'.split('_'),
        i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'uns segundos', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'unha hora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'unha hora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un da',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un da',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 das',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un da',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 das',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 das',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un ano',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un ano',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'nuns segundos',  'prefix');
        assert.equal(moment(0).from(30000), 'hai uns segundos', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'hai uns segundos',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'nuns segundos', 'en unos segundos');
        assert.equal(moment().add({d: 5}).fromNow(), 'en 5 das', 'en 5 das');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                         'hoxe s 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),          'hoxe s 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),           'hoxe s 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),           'ma s 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).add({d: 1, h : -1}).calendar(),   'ma  1:00',   'tomorrow minus 1 hour');
        assert.equal(moment(a).subtract({h: 1}).calendar(),      'hoxe  1:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),      'onte  2:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? 's' : 'a') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? 's' : 'a') + '] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [' + ((m.hours() !== 1) ? 's' : 'a') + '] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? 's' : 'a') + '] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? 's' : 'a') + '] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[o] dddd [pasado ' + ((m.hours() !== 1) ? 's' : 'a') + '] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('regression tests', function (assert) {
        var lastWeek = moment().subtract({d: 4}).hours(1);
        assert.equal(lastWeek.calendar(), lastWeek.format('[o] dddd [pasado a] LT'), '1 o\'clock bug');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('he');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      ',  14 2010, 3:25:50 pm'],
                ['ddd, hA',                            ', 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14  2010'],
                ['LLL',                                '14  2010 15:25'],
                ['LLLL',                               ', 14  2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14  2010'],
                ['lll',                                '14  2010 15:25'],
                ['llll',                               ', 14  2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  |  |  |  |  |  |  '.split('|'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 3699}), true), '10 ',        '345 days = 10 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 7340}), true), '20 ',       '548 days = 20 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     ' 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      ' 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       ' 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       ' 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  ' 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  ' 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd [ ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd [ ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd [ ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('hi');

    test('parse', function (assert) {
        var tests = ' ._ ._ _ ._ _ _ ._ ._ ._ ._ ._ .'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss ',  ',   ,  :: '],
                ['ddd, a h ',                       ',   '],
                ['M Mo MM MMMM MMM',                   '    .'],
                ['YYYY YY',                            ' '],
                ['D Do DD',                            '  '],
                ['d do dddd ddd dd',                   '    '],
                ['DDD DDDo DDDD',                      '  '],
                ['w wo ww',                            '  '],
                ['h hh',                               ' '],
                ['H HH',                               ' '],
                ['m mm',                               ' '],
                ['s ss',                               ' '],
                ['a A',                                ' '],
                ['LTS',                                ' :: '],
                ['L',                                  '//'],
                ['LL',                                 '  '],
                ['LLL',                                '  ,  : '],
                ['LLLL',                               ',   ,  : '],
                ['l',                                  '//'],
                ['ll',                                 ' . '],
                ['lll',                                ' . ,  : '],
                ['llll',                               ',  . ,  : ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '', '');
    });

    test('format month', function (assert) {
        var expected = ' ._ ._ _ ._ _ _ ._ ._ ._ ._ ._ .'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '  ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  ' ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  ' ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  ' ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   ' ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  ' ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  ' ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   ' ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  ' ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  ' ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  ' ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  ' ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  ' ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   ' ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), ' ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   ' ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '   ',  'prefix');
        assert.equal(moment(0).from(30000), '   ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '   ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '   ', '   ');
        assert.equal(moment().add({d: 5}).fromNow(), '  ', '  ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  : ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  : ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '  : ',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  : ',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  : ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  : ', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem invariant', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '  ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '  ', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '  ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '  ', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '  ', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('hr');

    test('parse', function (assert) {
        var tests = 'sijeanj sij._veljaa velj._oujak ou._travanj tra._svibanj svi._lipanj lip._srpanj srp._kolovoz kol._rujan ruj._listopad lis._studeni stu._prosinac pro.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. veljaa 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 veljaa velj.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. veljaa 2010'],
                ['LLL',                                '14. veljaa 2010 15:25'],
                ['LLLL',                               'nedjelja, 14. veljaa 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. velj. 2010'],
                ['lll',                                '14. velj. 2010 15:25'],
                ['llll',                               'ned., 14. velj. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'sijeanj sij._veljaa velj._oujak ou._travanj tra._svibanj svi._lipanj lip._srpanj srp._kolovoz kol._rujan ruj._listopad lis._studeni stu._prosinac pro.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_etvrtak et. e_petak pet. pe_subota sub. su'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'par sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedna minuta',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedna minuta',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za par sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prije par sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prije par sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za par sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'danas u 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'juer u 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedjelju] [u] LT';
            case 3:
                return '[u] [srijedu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
                return '[prolu] dddd [u] LT';
            case 6:
                return '[prole] [subote] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[proli] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('hu');

    test('parse', function (assert) {
        var tests = 'janur jan_februr feb_mrcius mrc_prilis pr_mjus mj_jnius jn_jlius jl_augusztus aug_szeptember szept_oktber okt_november nov_december dec'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',      'vasrnap, februr 14. 2010, 15:25:50'],
                ['ddd, HH',                            'vas, 15'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februr feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. vasrnap vas v'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['[az v] DDDo [napja]',               'az v 45. napja'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010.02.14.'],
                ['LL',                                 '2010. februr 14.'],
                ['LLL',                                '2010. februr 14. 15:25'],
                ['LLLL',                               '2010. februr 14., vasrnap 15:25'],
                ['l',                                  '2010.2.14.'],
                ['ll',                                 '2010. feb 14.'],
                ['lll',                                '2010. feb 14. 15:25'],
                ['llll',                               '2010. feb 14., vas 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0,  0]).format('a'), 'de', 'am');
        assert.equal(moment([2011, 2, 23, 11, 59]).format('a'), 'de', 'am');
        assert.equal(moment([2011, 2, 23, 12,  0]).format('a'), 'du', 'pm');
        assert.equal(moment([2011, 2, 23, 23, 59]).format('a'), 'du', 'pm');

        assert.equal(moment([2011, 2, 23,  0,  0]).format('A'), 'DE', 'AM');
        assert.equal(moment([2011, 2, 23, 11, 59]).format('A'), 'DE', 'AM');
        assert.equal(moment([2011, 2, 23, 12,  0]).format('A'), 'DU', 'PM');
        assert.equal(moment([2011, 2, 23, 23, 59]).format('A'), 'DU', 'PM');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'janur jan_februr feb_mrcius mrc_prilis pr_mjus mj_jnius jn_jlius jl_augusztus aug_szeptember szept_oktber okt_november nov_december dec'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'vasrnap vas_htf ht_kedd kedd_szerda sze_cstrtk cst_pntek pn_szombat szo'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nhny msodperc', '44 msodperc = nhny msodperc');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'egy perc',         '45 msodperc = egy perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'egy perc',         '89 msodperc = egy perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 perc',           '90 msodperc = 2 perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 perc',          '44 perc = 44 perc');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'egy ra',          '45 perc = egy ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'egy ra',          '89 perc = egy ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ra',            '90 perc = 2 ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ra',            '5 ra = 5 ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ra',           '21 ra = 21 ra');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'egy nap',          '22 ra = egy nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'egy nap',          '35 ra = egy nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 nap',            '36 ra = 2 nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'egy nap',          '1 nap = egy nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 nap',            '5 nap = 5 nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 nap',           '25 nap = 25 nap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'egy hnap',        '26 nap = egy hnap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'egy hnap',        '30 nap = egy hnap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'egy hnap',        '45 nap = egy hnap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 hnap',          '46 nap = 2 hnap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 hnap',          '75 nap = 2 hnap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 hnap',          '76 nap = 3 hnap');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'egy hnap',        '1 hnap = egy hnap');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 hnap',          '5 hnap = 5 hnap');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'egy v',           '345 nap = egy v');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 v',             '548 nap = 2 v');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'egy v',           '1 v = egy v');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 v',             '5 v = 5 v');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'nhny msodperc mlva',  'prefix');
        assert.equal(moment(0).from(30000), 'nhny msodperce', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'nhny msodperce',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'nhny msodperc mlva', 'nhny msodperc mlva');
        assert.equal(moment().add({d: 5}).fromNow(), '5 nap mlva', '5 nap mlva');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'ma 2:00-kor',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'ma 2:25-kor',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'ma 3:00-kor',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'holnap 2:00-kor', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'ma 1:00-kor',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'tegnap 2:00-kor', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, days = 'vasrnap_htfn_kedden_szerdn_cstrtkn_pnteken_szombaton'.split('_');
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + days[m.day()] + '] LT[-kor]'),  'today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, days = 'vasrnap_htfn_kedden_szerdn_cstrtkn_pnteken_szombaton'.split('_');

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[mlt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[mlt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[mlt ' + days[m.day()] + '] LT[-kor]'),  'today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  'egy hte');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'egy ht mlva');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 hete');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 ht mlva');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('hy-am');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse exceptional case', function (assert) {
        assert.equal(moment('11  1989', ['DD MMMM YYYY']).format('DD-MM-YYYY'), '11-05-1989');
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       ', 14  2010, 15:25:50'],
                ['ddd, h A',                           ', 3 '],
                ['M Mo MM MMMM MMM',                   '2 2 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45- 045'],
                ['w wo ww',                            '7 7- 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['[] DDDo []',                 ' 45- '],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14  2010 .'],
                ['LLL',                                '14  2010 ., 15:25'],
                ['LLLL',                               ', 14  2010 ., 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14  2010 .'],
                ['lll',                                '14  2010 ., 15:25'],
                ['llll',                               ', 14  2010 ., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-', '1-');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-', '2-');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-', '3-');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-', '4-');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-', '5-');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-', '6-');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-', '7-');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-', '8-');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-', '9-');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-', '10-');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-', '11-');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-', '12-');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-', '13-');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-', '14-');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-', '15-');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-', '16-');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-', '17-');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-', '18-');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-', '19-');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-', '20-');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-', '21-');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-', '22-');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-', '23-');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-', '24-');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-', '25-');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-', '26-');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-', '27-');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-', '28-');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-', '29-');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-', '30-');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-', '31-');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format month short case', function (assert) {
        var monthsShort = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMM'), monthsShort.nominative[i], '1 ' + monthsShort.nominative[i]);
        }
    });

    test('format month case with escaped symbols', function (assert) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[- ] MMMM'), '1-  ' + months.accusative[i], '1-  ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);
        }
    });

    test('format month short case with escaped symbols', function (assert) {
        var monthsShort = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMM[</b>]'), '<i>1</i> <b>' + monthsShort.accusative[i] + '</b>', '1 <b>' + monthsShort.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[- ] MMM'), '1-  ' + monthsShort.accusative[i], '1-  ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMM'), '1, ' + monthsShort.nominative[i], '1, ' + monthsShort.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '  ',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 ',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 ',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '   ', 'prefix');
        assert.equal(moment(0).from(30000), '   ', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '   ', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5  ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     ' 02:00',   'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      ' 02:25',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       ' 03:00',   'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       ' 02:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  ' 01:00',   'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  ' 02:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        function makeFormat(d) {
            return 'dddd [ ] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            return '[] dddd [ ] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('id');

    test('parse', function (assert) {
        var tests = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Minggu, Februari 14 2010, 3:25:50 sore'],
                ['ddd, hA',                            'Min, 3sore'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Minggu Min Mg'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'sore sore'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Minggu, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Min, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_November Nov_Desember Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Minggu Min Mg_Senin Sen Sn_Selasa Sel Sl_Rabu Rab Rb_Kamis Kam Km_Jumat Jum Jm_Sabtu Sab Sb'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa detik', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'semenit',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'semenit',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 menit',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 menit',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dalam beberapa detik',  'prefix');
        assert.equal(moment(0).from(30000), 'beberapa detik yang lalu', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'beberapa detik yang lalu',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa detik', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hari ini pukul 02.00', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 02.25', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 03.00', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Besok pukul 02.00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 01.00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kemarin pukul 02.00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [lalu pukul] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('is');

    test('parse', function (assert) {
        var tests = 'janar jan_febrar feb_mars mar_aprl apr_ma ma_jn jn_jl jl_gst g_september sep_oktber okt_nvember nv_desember des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'sunnudagur, 14. febrar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 febrar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sunnudagur sun Su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14. febrar 2010'],
                ['LLL',                                '14. febrar 2010 kl. 15:25'],
                ['LLLL',                               'sunnudagur, 14. febrar 2010 kl. 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14. feb 2010'],
                ['lll',                                '14. feb 2010 kl. 15:25'],
                ['llll',                               'sun, 14. feb 2010 kl. 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'janar jan_febrar feb_mars mar_aprl apr_ma ma_jn jn_jl jl_gst g_september sep_oktber okt_nvember nv_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sunnudagur sun Su_mnudagur mn M_rijudagur ri r_mivikudagur mi Mi_fimmtudagur fim Fi_fstudagur fs F_laugardagur lau La'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nokkrar sekndur', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'mnta',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'mnta',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 mntur',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 mntur',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 21}), true),  '21 mnta',    '21 minutes = 21 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'klukkustund',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'klukkustund',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 klukkustundir',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 klukkustundir',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 klukkustund',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dagur',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dagur',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dagur',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 dagar',       '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 dagur',       '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mnuur',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mnuur',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mnuur',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mnuir',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mnuir',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mnuir',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mnuur',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mnuir',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 r',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 r',       '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 21}), true),  '21 r',       '21 years = 21 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'eftir nokkrar sekndur',  'prefix');
        assert.equal(moment(0).from(30000), 'fyrir nokkrum sekndum san', 'suffix');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'fyrir mntu san', 'a minute ago');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fyrir nokkrum sekndum san',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'eftir nokkrar sekndur', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(), 'eftir mntu', 'in a minute');
        assert.equal(moment().add({d: 5}).fromNow(), 'eftir 5 daga', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     ' dag kl. 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      ' dag kl. 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       ' dag kl. 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       ' morgun kl. 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  ' dag kl. 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  ' gr kl. 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[sasta] dddd [kl.] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[sasta] dddd [kl.] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[sasta] dddd [kl.] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('it');

    test('parse', function (assert) {
        var tests = 'gennaio gen_febbraio feb_marzo mar_aprile apr_maggio mag_giugno giu_luglio lug_agosto ago_settembre set_ottobre ott_novembre nov_dicembre dic'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domenica, febbraio 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 febbraio feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Domenica Dom D'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 febbraio 2010'],
                ['LLL',                                '14 febbraio 2010 15:25'],
                ['LLLL',                               'Domenica, 14 febbraio 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'Dom, 14 feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'gennaio gen_febbraio feb_marzo mar_aprile apr_maggio mag_giugno giu_luglio lug_agosto ago_settembre set_ottobre ott_novembre nov_dicembre dic'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domenica Dom D_Luned Lun L_Marted Mar Ma_Mercoled Mer Me_Gioved Gio G_Venerd Ven V_Sabato Sab S'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'alcuni secondi', '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minuto',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minuto',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuti',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuti',      '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'un\'ora',        '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'un\'ora',        '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ore',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ore',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ore',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'un giorno',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'un giorno',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 giorni',       '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'un giorno',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 giorni',       '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 giorni',      '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'un mese',        '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'un mese',        '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'un mese',        '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesi',         '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesi',         '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesi',         '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'un mese',        '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesi',         '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un anno',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anni',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un anno',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anni',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'in alcuni secondi', 'prefix');
        assert.equal(moment(0).from(30000), 'alcuni secondi fa', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'in alcuni secondi', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'tra 5 giorni', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Oggi alle 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Oggi alle 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Oggi alle 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Domani alle 02:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Oggi alle 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ieri alle 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [alle] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, weekday, datestring;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            // Different date string
            weekday = parseInt(m.format('d'), 10);
            datestring = (weekday === 0) ? '[la scorsa] dddd [alle] LT' : '[lo scorso] dddd [alle] LT';
            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format(datestring), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ja');

    test('parse', function (assert) {
        var tests = '1 1_2 2_3 3_4 4_5 5_6 6_7 7_8 8_9 9_10 10_11 11_12 12'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, a h:mm:ss',      ', 2 14 2010,  3:25:50'],
                ['ddd, Ah',                            ', 3'],
                ['M Mo MM MMMM MMM',                   '2 2 02 2 2'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '32550'],
                ['L',                                  '2010/02/14'],
                ['LL',                                 '2010214'],
                ['LLL',                                '2010214325'],
                ['LLLL',                               '2010214325 '],
                ['l',                                  '2010/2/14'],
                ['ll',                                 '2010214'],
                ['lll',                                '2010214325'],
                ['llll',                               '2010214325 ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = '1 1_2 2_3 3_4 4_5 5_6 6_7 7_8 8_9 9_10 10_11 11_12 12'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '',  'prefix');
        assert.equal(moment(0).from(30000), '', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     ' 20',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      ' 225',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       ' 30',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       ' 20',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  ' 10',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  ' 20',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[]dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[]dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[]dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[]dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[]dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[]dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('jv');


    test('parse', function (assert) {
        var tests = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_Nopember Nop_Desember Des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Minggu, Februari 14 2010, 3:25:50 sonten'],
                ['ddd, hA',                            'Min, 3sonten'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Minggu Min Mg'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'sonten sonten'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Minggu, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Min, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'Januari Jan_Februari Feb_Maret Mar_April Apr_Mei Mei_Juni Jun_Juli Jul_Agustus Ags_September Sep_Oktober Okt_Nopember Nop_Desember Des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Minggu Min Mg_Senen Sen Sn_Seloso Sel Sl_Rebu Reb Rb_Kemis Kem Km_Jemuwah Jem Jm_Septu Sep Sp'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'sawetawis detik', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'setunggal menit',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'setunggal menit',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 menit',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 menit',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'setunggal jam',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'setunggal jam',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sedinten',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sedinten',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dinten',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sedinten',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dinten',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dinten',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sewulan',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sewulan',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sewulan',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 wulan',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 wulan',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 wulan',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sewulan',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 wulan',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setaun',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 taun',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setaun',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 taun',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'wonten ing sawetawis detik',  'prefix');
        assert.equal(moment(0).from(30000), 'sawetawis detik ingkang kepengker', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'sawetawis detik ingkang kepengker',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'wonten ing sawetawis detik', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'wonten ing 5 dinten', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Dinten puniko pukul 02.00', 'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Dinten puniko pukul 02.25', 'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Dinten puniko pukul 03.00', 'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Mbenjang pukul 02.00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Dinten puniko pukul 01.00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kala wingi pukul 02.00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kepengker pukul] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 1st is the first week of the year.

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ka');

    test('parse', function (assert) {
        var i,
            tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + '    ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', ',  -14 2010, 3:25:50 pm'],
                ['ddd, hA',                       ', 3PM'],
                ['M Mo MM MMMM MMM',              '2 -2 02  '],
                ['YYYY YY',                       '2010 10'],
                ['D Do DD',                       '14 -14 14'],
                ['d do dddd ddd dd',              '0 0   '],
                ['DDD DDDo DDDD',                 '45 45- 045'],
                ['w wo ww',                       '7 -7 07'],
                ['h hh',                          '3 03'],
                ['H HH',                          '15 15'],
                ['m mm',                          '25 25'],
                ['s ss',                          '50 50'],
                ['a A',                           'pm PM'],
                [' DDDo ',                 ' 45- '],
                ['LTS',                           '3:25:50 PM'],
                ['L',                             '14/02/2010'],
                ['LL',                            '14  2010'],
                ['LLL',                           '14  2010 3:25 PM'],
                ['LLLL',                          ', 14  2010 3:25 PM'],
                ['l',                             '14/2/2010'],
                ['ll',                            '14  2010'],
                ['lll',                           '14  2010 3:25 PM'],
                ['llll',                          ', 14  2010 3:25 PM']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'),  '1-',  '1-');
        assert.equal(moment([2011, 0, 2]).format('DDDo'),  '-2',  '-2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'),  '-3',  '-3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'),  '-4',  '-4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'),  '-5',  '-5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'),  '-6',  '-6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'),  '-7',  '-7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'),  '-8',  '-8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'),  '-9',  '-9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '-10', '-10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '-11', '-11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '-12', '-12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '-13', '-13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '-14', '-14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '-15', '-15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '-16', '-16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '-17', '-17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '-18', '-18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '-19', '-19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '-20', '-20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-', '21-');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-', '22-');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-', '23-');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-', '24-');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-', '25-');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-', '26-');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-', '27-');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-', '28-');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-', '29-');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-', '30-');

        assert.equal(moment('2011 40', 'YYYY DDD').format('DDDo'),  '-40',  '-40');
        assert.equal(moment('2011 50', 'YYYY DDD').format('DDDo'),  '50-',   '50-');
        assert.equal(moment('2011 60', 'YYYY DDD').format('DDDo'),  '-60',  '-60');
        assert.equal(moment('2011 100', 'YYYY DDD').format('DDDo'), '-100', '-100');
        assert.equal(moment('2011 101', 'YYYY DDD').format('DDDo'), '101-',  '101-');
    });

    test('format month', function (assert) {
        var i,
            expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = '  _  _  _  _  _  _  '.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}),  true), ' ', '44   =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}),  true), '',           '45   = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}),  true), '',           '89   = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}),  true), '2 ',         '90   = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}),  true), '44 ',        '44   = 44 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}),  true), '',          '45   = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}),  true), '',          '89   = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}),  true), '2 ',        '90   = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}),   true), '5 ',        '5   = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}),  true), '21 ',       '21  = 21 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}),  true), '',            '22  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}),  true), '',            '35  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}),  true), '2 ',          '36  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}),   true), '',            '1     = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}),   true), '5 ',          '5     = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}),  true), '25 ',         '25    = 25 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}),  true), '',            '26    = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}),  true), '',            '30    = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}),  true), '',            '45    = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}),  true), '2 ',          '46    = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}),  true), '2 ',          '75    = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}),  true), '3 ',          '76    = 3 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}),   true), '',            '1     = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}),   true), '5 ',          '5     = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',           '345   = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',         '548   = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}),   true), '',           '1    = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}),   true), '5 ',         '5    = 5 ');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ',     ' ');
        assert.equal(moment(0).from(30000), '  ', ' ');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ', '   ');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), ' ', ' ');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ', '5 ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     ' 2:00 AM-',  '  ');
        assert.equal(moment(a).add({m: 25}).calendar(),      ' 2:25 AM-',  '   25 ');
        assert.equal(moment(a).add({h: 1}).calendar(),       ' 3:00 AM-',  '   1 ');
        assert.equal(moment(a).add({d: 1}).calendar(),       ' 2:00 AM-',  '  ');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  ' 1:00 AM-',  '   1 ');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  ' 2:00 AM-', '  ');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd LT[-]'),  ' + ' + i + '   ');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd LT[-]'),  ' + ' + i + '   ');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd LT[-]'),  ' + ' + i + '   ');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd LT[-]'),  ' - ' + i + '   ');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd LT[-]'),  ' - ' + i + '   ');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd LT[-]'),  ' - ' + i + '   ');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1  ');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '1 ');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2  ');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  '2 ');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, ' 26 2011    1');
        assert.equal(moment([2012,  0,  1]).week(), 1, '  1 2012    1');
        assert.equal(moment([2012,  0,  2]).week(), 2, '  2 2012    2');
        assert.equal(moment([2012,  0,  8]).week(), 2, '  8 2012    2');
        assert.equal(moment([2012,  0,  9]).week(), 3, '  9 2012    3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, '  1 2007    1');
        assert.equal(moment([2007, 0, 7]).week(),  1, '  7 2007    1');
        assert.equal(moment([2007, 0, 8]).week(),  2, '  8 2007    2');
        assert.equal(moment([2007, 0, 14]).week(), 2, ' 14 2007    2');
        assert.equal(moment([2007, 0, 15]).week(), 3, ' 15 2007    3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, ' 31 2007    1');
        assert.equal(moment([2008,  0,  1]).week(), 1, '  1 2008    1');
        assert.equal(moment([2008,  0,  6]).week(), 1, '  6 2008    1');
        assert.equal(moment([2008,  0,  7]).week(), 2, '  7 2008    2');
        assert.equal(moment([2008,  0, 13]).week(), 2, ' 13 2008    2');
        assert.equal(moment([2008,  0, 14]).week(), 3, ' 14 2008    3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, ' 30 2002    1');
        assert.equal(moment([2003,  0,  1]).week(), 1, '  1 2003    1');
        assert.equal(moment([2003,  0,  5]).week(), 1, '  5 2003    1');
        assert.equal(moment([2003,  0,  6]).week(), 2, '  6 2003    2');
        assert.equal(moment([2003,  0, 12]).week(), 2, ' 12 2003    2');
        assert.equal(moment([2003,  0, 13]).week(), 3, ' 13 2003    3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, ' 29 2008    1');
        assert.equal(moment([2009,  0,  1]).week(), 1, '  1 2009    1');
        assert.equal(moment([2009,  0,  4]).week(), 1, '  4 2009    1');
        assert.equal(moment([2009,  0,  5]).week(), 2, '  5 2009    2');
        assert.equal(moment([2009,  0, 11]).week(), 2, ' 11 2009    2');
        assert.equal(moment([2009,  0, 12]).week(), 3, ' 12 2009    3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, ' 28 2009    1');
        assert.equal(moment([2010,  0,  1]).week(), 1, '  1 2010    1');
        assert.equal(moment([2010,  0,  3]).week(), 1, '  3 2010    1');
        assert.equal(moment([2010,  0,  4]).week(), 2, '  4 2010    2');
        assert.equal(moment([2010,  0, 10]).week(), 2, ' 10 2010    2');
        assert.equal(moment([2010,  0, 11]).week(), 3, ' 11 2010    3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, ' 27 2010    1');
        assert.equal(moment([2011,  0,  1]).week(), 1, '  1 2011    1');
        assert.equal(moment([2011,  0,  2]).week(), 1, '  2 2011    1');
        assert.equal(moment([2011,  0,  3]).week(), 2, '  3 2011    2');
        assert.equal(moment([2011,  0,  9]).week(), 2, '  9 2011    2');
        assert.equal(moment([2011,  0, 10]).week(), 3, ' 10 2011    3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-', ' 26 2011    1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-', '  1 2012    1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 -2', '  2 2012    2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 -2', '  8 2012    2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 -3', '  9 2012    3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('km');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'),
            i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', ',  14 2010, 3:25:50 pm'],
                ['ddd, hA', ', 3PM'],
                ['M Mo MM MMMM MMM', '2 2 02  '],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14 14'],
                ['d do dddd ddd dd', '0 0   '],
                ['DDD DDDo DDDD', '45 45 045'],
                ['w wo ww', '6 6 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45 day of the year'],
                ['LTS', '15:25:50'],
                ['L', '14/02/2010'],
                ['LL', '14  2010'],
                ['LLL', '14  2010 15:25'],
                ['LLLL', ', 14  2010 15:25'],
                ['l', '14/2/2010'],
                ['ll', '14  2010'],
                ['lll', '14  2010 15:25'],
                ['llll', ', 14  2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21st');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22nd');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23rd');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31st');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), '', '44 seconds = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), '', '45 seconds = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), '', '89 seconds = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 ', '90 seconds = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 ', '44 minutes = 44 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), '', '45 minutes = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), '', '89 minutes = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 ', '90 minutes = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 ', '5 hours = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 ', '21 hours = 21 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), '', '22 hours = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), '', '35 hours = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 ', '36 hours = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), '', '1 day = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 ', '5 days = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 ', '25 days = 25 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), '', '26 days = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), '', '30 days = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), '', '43 days = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 ', '46 days = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 ', '75 days = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 ', '76 days = 3 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), '', '1 month = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 ', '5 months = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '', '345 days = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ', '548 days = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), '', '1 year = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 ', '5 years = 5 ');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '', 'prefix');
        assert.equal(moment(0).from(30000), '', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '', 'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({
            s: 30
        }).fromNow(), '', 'in a few seconds');
        assert.equal(moment().add({
            d: 5
        }).fromNow(), '5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(), '  02:00', 'today at the same time');
        assert.equal(moment(a).add({
            m: 25
        }).calendar(), '  02:25', 'Now plus 25 min');
        assert.equal(moment(a).add({
            h: 1
        }).calendar(), '  03:00', 'Now plus 1 hour');
        assert.equal(moment(a).add({
            d: 1
        }).calendar(), '  02:00', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({
            h: 1
        }).calendar(), '  01:00', 'Now minus 1 hour');
        assert.equal(moment(a).subtract({
            d: 1
        }).calendar(), '  02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [] LT'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [] LT'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [] LT'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd [] [] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd [] [] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd [] [] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({
                w: 1
            }),
            weeksFromNow = moment().add({
                w: 1
            });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '1 week ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 1 week');

        weeksAgo = moment().subtract({
            w: 2
        });
        weeksFromNow = moment().add({
            w: 2
        });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '2 weeks ago');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), 'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(), 1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(), 1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(), 2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(), 2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008, 0, 1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008, 0, 6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008, 0, 7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008, 0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008, 0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003, 0, 1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003, 0, 5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003, 0, 6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003, 0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003, 0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009, 0, 1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009, 0, 4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009, 0, 5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009, 0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009, 0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010, 0, 1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010, 0, 3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010, 0, 4]).week(), 1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010, 0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010, 0, 11]).week(), 2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011, 0, 1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011, 0, 2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011, 0, 3]).week(), 1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011, 0, 9]).week(), 1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011, 0, 10]).week(), 2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ko');

    test('parse', function (assert) {
        var tests = '1 1_2 2_3 3_4 4_5 5_6 6_7 7_8 8_9 9_10 10_11 11_12 12'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse meridiem', function (assert) {
        var elements = [{
            expression : '1981 9 8  2 30',
            inputFormat : 'YYYY[] M[] D[] A h[] m[]',
            outputFormat : 'A',
            expected : ''
        }, {
            expression : '1981 9 8  2 30',
            inputFormat : 'YYYY[] M[] D[] A h[] m[]',
            outputFormat : 'A h',
            expected : ' 2'
        }, {
            expression : '14 30',
            inputFormat : 'H[] m[]',
            outputFormat : 'A',
            expected : ''
        }, {
            expression : ' 4',
            inputFormat : 'A h[]',
            outputFormat : 'H',
            expected : '16'
        }], i, l, it, actual;


        for (i = 0, l = elements.length; i < l; ++i) {
            it = elements[i];
            actual = moment(it.expression, it.inputFormat).format(it.outputFormat);

            assert.equal(
                actual,
                it.expected,
                '\'' + it.outputFormat + '\' of \'' + it.expression + '\' must be \'' + it.expected + '\' but was \'' + actual + '\'.'
            );
        }
    });

    test('format', function (assert) {
        var a = [
                ['YYYY MMMM Do dddd a h:mm:ss',      '2010 2 14   3:25:50'],
                ['ddd A h',                            '  3'],
                ['M Mo MM MMMM MMM',                   '2 2 02 2 2'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['  DDDo  ',                 '  45  '],
                ['LTS',                                ' 3 25 50'],
                ['L',                                  '2010.02.14'],
                ['LL',                                 '2010 2 14'],
                ['LLL',                                '2010 2 14  3 25'],
                ['LLLL',                               '2010 2 14   3 25'],
                ['l',                                  '2010.2.14'],
                ['ll',                                 '2010 2 14'],
                ['lll',                                '2010 2 14  3 25'],
                ['llll',                               '2010 2 14   3 25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = '1 1_2 2_3 3_4 4_5 5_6 6_7 7_8 8_9 9_10 10_11 11_12 12'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '', '44 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',      '45 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',      '89 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2',     '90 = 2');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44',    '44 = 44');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',       '45 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',       '89 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2',       '90 = 2');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5',       '5 = 5');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21',      '21 = 21');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',         '22 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',         '35 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2',        '36 = 2');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',         ' = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5',        '5 = 5');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25',       '25 = 25');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',       '26 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',       '30 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',       '45 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2',      '46 = 2');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2',      '75 = 2');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3',      '76 = 3');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',       '1 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5',      '5 = 5');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',        '345 = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2',       '548 = 2');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',        ' = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5',       '5 = 5');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ',  'prefix');
        assert.equal(moment(0).from(30000), ' ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), ' ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), ' ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  2 0',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  2 25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  3 0',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  2 0',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  1 0',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  2 0',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(' dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(' dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(' dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('lb');

    test('parse', function (assert) {
        var tests = 'Januar Jan._Februar Febr._Merz Mrz._Abrll Abr._Mee Mee_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss', 'Sonndeg, 14. Februar 2010, 15:25:50'],
                ['ddd, HH:mm', 'So., 15:25'],
                ['M Mo MM MMMM MMM', '2 2. 02 Februar Febr.'],
                ['YYYY YY', '2010 10'],
                ['D Do DD', '14 14. 14'],
                ['d do dddd ddd dd', '0 0. Sonndeg So. So'],
                ['DDD DDDo DDDD', '45 45. 045'],
                ['w wo ww', '6 6. 06'],
                ['h hh', '3 03'],
                ['H HH', '15 15'],
                ['m mm', '25 25'],
                ['s ss', '50 50'],
                ['a A', 'pm PM'],
                ['[the] DDDo [day of the year]', 'the 45. day of the year'],
                ['LTS', '15:25:50 Auer'],
                ['L', '14.02.2010'],
                ['LL', '14. Februar 2010'],
                ['LLL', '14. Februar 2010 15:25 Auer'],
                ['LLLL', 'Sonndeg, 14. Februar 2010 15:25 Auer'],
                ['l', '14.2.2010'],
                ['ll', '14. Febr. 2010'],
                ['lll', '14. Febr. 2010 15:25 Auer'],
                ['llll', 'So., 14. Febr. 2010 15:25 Auer']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = 'Januar Jan._Februar Febr._Merz Mrz._Abrll Abr._Mee Mee_Juni Jun._Juli Jul._August Aug._September Sept._Oktober Okt._November Nov._Dezember Dez.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sonndeg So. So_Mindeg M. M_Dnschdeg D. D_Mttwoch M. M_Donneschdeg Do. Do_Freideg Fr. Fr_Samschdeg Sa. Sa'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true), 'e puer Sekonnen', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true), 'eng Minutt', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true), 'eng Minutt', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '2 Minutten', '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), '44 Minutten', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true), 'eng Stonn', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true), 'eng Stonn', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true), '2 Stonnen', '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true), '5 Stonnen', '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true), '21 Stonnen', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true), 'een Dag', '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true), 'een Dag', '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true), '2 Deeg', '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true), 'een Dag', '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true), '5 Deeg', '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true), '25 Deeg', '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), 'ee Mount', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), 'ee Mount', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), 'ee Mount', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), '2 Mint', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), '2 Mint', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), '3 Mint', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), 'ee Mount', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), '5 Mint', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ee Joer', '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 Joer', '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true), 'ee Joer', '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), '5 Joer', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'an e puer Sekonnen', 'prefix');
        assert.equal(moment(0).from(30000), 'virun e puer Sekonnen', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'an e puer Sekonnen', 'in a few seconds');
        assert.equal(moment().add({d: 1}).fromNow(), 'an engem Dag', 'in one day');
        assert.equal(moment().add({d: 2}).fromNow(), 'an 2 Deeg', 'in 2 days');
        assert.equal(moment().add({d: 3}).fromNow(), 'an 3 Deeg', 'in 3 days');
        assert.equal(moment().add({d: 4}).fromNow(), 'a 4 Deeg', 'in 4 days');
        assert.equal(moment().add({d: 5}).fromNow(), 'a 5 Deeg', 'in 5 days');
        assert.equal(moment().add({d: 6}).fromNow(), 'a 6 Deeg', 'in 6 days');
        assert.equal(moment().add({d: 7}).fromNow(), 'a 7 Deeg', 'in 7 days');
        assert.equal(moment().add({d: 8}).fromNow(), 'an 8 Deeg', 'in 8 days');
        assert.equal(moment().add({d: 9}).fromNow(), 'an 9 Deeg', 'in 9 days');
        assert.equal(moment().add({d: 10}).fromNow(), 'an 10 Deeg', 'in 10 days');
        assert.equal(moment().add({y: 100}).fromNow(), 'an 100 Joer', 'in 100 years');
        assert.equal(moment().add({y: 400}).fromNow(), 'a 400 Joer', 'in 400 years');
    });

    test('calendar last week', function (assert) {
        var i, m, weekday, datestring;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});

            // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday)
            weekday = parseInt(m.format('d'), 10);
            datestring = (weekday === 2 || weekday === 4 ? '[Leschten] dddd [um] LT' : '[Leschte] dddd [um] LT');

            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format(datestring), 'Today + ' + i + ' days end of day');
        }
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('lt');

    test('parse', function (assert) {
        var tests = 'sausis sau_vasaris vas_kovas kov_balandis bal_gegu geg_birelis bir_liepa lie_rugpjtis rgp_rugsjis rgs_spalis spa_lapkritis lap_gruodis grd'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'sekmadienis, 14-oji vasario 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sek, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2-oji 02 vasaris vas'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14-oji 14'],
                ['d do dddd ddd dd',                   '0 0-oji sekmadienis Sek S'],
                ['DDD DDDo DDDD',                      '45 45-oji 045'],
                ['w wo ww',                            '6 6-oji 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['DDDo [met diena]',                  '45-oji met diena'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '2010 m. vasaris 14 d.'],
                ['LLL',                                '2010 m. vasaris 14 d., 15:25 val.'],
                ['LLLL',                               '2010 m. vasaris 14 d., sekmadienis, 15:25 val.'],
                ['l',                                  '2010-02-14'],
                ['ll',                                 '2010 m. vasaris 14 d.'],
                ['lll',                                '2010 m. vasaris 14 d., 15:25 val.'],
                ['llll',                               '2010 m. vasaris 14 d., Sek, 15:25 val.']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-oji', '1-oji');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-oji', '2-oji');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-oji', '3-oji');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-oji', '4-oji');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-oji', '5-oji');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-oji', '6-oji');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-oji', '7-oji');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-oji', '8-oji');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-oji', '9-oji');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-oji', '10-oji');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-oji', '11-oji');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-oji', '12-oji');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-oji', '13-oji');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-oji', '14-oji');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-oji', '15-oji');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-oji', '16-oji');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-oji', '17-oji');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-oji', '18-oji');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-oji', '19-oji');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-oji', '20-oji');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-oji', '21-oji');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-oji', '22-oji');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-oji', '23-oji');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-oji', '24-oji');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-oji', '25-oji');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-oji', '26-oji');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-oji', '27-oji');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-oji', '28-oji');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-oji', '29-oji');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-oji', '30-oji');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-oji', '31-oji');
    });

    test('format month', function (assert) {
        var expected = 'sausis sau_vasaris vas_kovas kov_balandis bal_gegu geg_birelis bir_liepa lie_rugpjtis rgp_rugsjis rgs_spalis spa_lapkritis lap_gruodis grd'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sekmadienis Sek S_pirmadienis Pir P_antradienis Ant A_treiadienis Tre T_ketvirtadienis Ket K_penktadienis Pen Pn_etadienis e '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('format week on US calendar', function (assert) {
        // Tests, whether the weekday names are correct, even if the week does not start on Monday
        moment.locale('lt', {week: {dow: 0, doy: 6}});
        var expected = 'sekmadienis Sek S_pirmadienis Pir P_antradienis Ant A_treiadienis Tre T_ketvirtadienis Ket K_penktadienis Pen Pn_etadienis e '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
        moment.locale('lt', {week: {dow: 1, doy: 4}});
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'kelios sekunds', '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minut',          '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minut',          '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuts',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 10}), true),  '10 minui',       '10 minutes = 10 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 11}), true),  '11 minui',       '11 minutes = 11 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 19}), true),  '19 minui',       '19 minutes = 19 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 20}), true),  '20 minui',       '20 minutes = 20 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuts',      '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'valanda',         '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'valanda',         '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 valandos',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 valandos',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 10}), true),  '10 valand',      '10 hours = 10 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 valandos',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'diena',           '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'diena',           '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dienos',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'diena',           '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dienos',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 10}), true),  '10 dien',        '10 days = 10 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dienos',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mnuo',           '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mnuo',           '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mnuo',           '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mnesiai',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mnesiai',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mnesiai',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mnuo',           '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mnesiai',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 10}), true),  '10 mnesi',      '10 months = 10 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'metai',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 metai',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'metai',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 metai',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'po keli sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prie kelias sekundes', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prie kelias sekundes',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'po keli sekundi', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'po 5 dien', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'iandien 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'iandien 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'iandien 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Rytoj 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'iandien 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Vakar 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Prajus] dddd LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Prajus] dddd LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Prajus] dddd LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52-oji', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1-oji', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1-oji', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2-oji', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2-oji', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('lv');

    test('parse', function (assert) {
        var tests = 'janvris jan_februris feb_marts mar_aprlis apr_maijs mai_jnijs jn_jlijs jl_augusts aug_septembris sep_oktobris okt_novembris nov_decembris dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'svtdiena, 14. februris 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Sv, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februris feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. svtdiena Sv Sv'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010.'],
                ['LL',                                 '2010. gada 14. februris'],
                ['LLL',                                '2010. gada 14. februris, 15:25'],
                ['LLLL',                               '2010. gada 14. februris, svtdiena, 15:25'],
                ['l',                                  '14.2.2010.'],
                ['ll',                                 '2010. gada 14. feb'],
                ['lll',                                '2010. gada 14. feb, 15:25'],
                ['llll',                               '2010. gada 14. feb, Sv, 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'janvris jan_februris feb_marts mar_aprlis apr_maijs mai_jnijs jn_jlijs jl_augusts aug_septembris sep_oktobris okt_novembris nov_decembris dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'svtdiena Sv Sv_pirmdiena P P_otrdiena O O_trediena T T_ceturtdiena C C_piektdiena Pk Pk_sestdiena S S'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    // Includes testing the cases of withoutSuffix = true and false.
    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),   'daas sekundes',       '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), false),  'pirms dam sekundm', '44 seconds with suffix = seconds ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),   'minte',               '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), false),  'pirms mintes',        '45 seconds with suffix = a minute ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),   'minte',               '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: -89}), false), 'pc mintes',          '89 seconds with suffix/prefix = in a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),   '2 mintes',            '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), false),  'pirms 2 mintm',      '90 seconds with suffix = 2 minutes ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),   '44 mintes',           '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), false),  'pirms 44 mintm',     '44 minutes with suffix = 44 minutes ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),   'stunda',               '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), false),  'pirms stundas',        '45 minutes with suffix = an hour ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),   'stunda',               '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),   '2 stundas',            '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: -90}), false), 'pc 2 stundm',        '90 minutes with suffix = in 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),    '5 stundas',            '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), false),   'pirms 5 stundm',      '5 hours with suffix = 5 hours ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),   '21 stunda',            '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), false),  'pirms 21 stundas',     '21 hours with suffix = 21 hours ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),   'diena',                '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), false),  'pirms dienas',         '22 hours with suffix = a day ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),   'diena',                '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),   '2 dienas',             '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), false),  'pirms 2 dienm',       '36 hours with suffix = 2 days ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),    'diena',                '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),    '5 dienas',             '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), false),   'pirms 5 dienm',       '5 days with suffix = 5 days ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),   '25 dienas',            '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), false),  'pirms 25 dienm',      '25 days with suffix = 25 days ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),   'mnesis',              '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), false),  'pirms mnea',         '26 days with suffix = a month ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),   'mnesis',              '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),   'mnesis',              '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),   '2 mnei',             '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), false),  'pirms 2 mneiem',     '46 days with suffix = 2 months ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),   '2 mnei',             '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),   '3 mnei',             '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), false),  'pirms 3 mneiem',     '76 days with suffix = 3 months ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),    'mnesis',              '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),    '5 mnei',             '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), false),   'pirms 5 mneiem',     '5 months with suffix = 5 months ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true),  'gads',                 '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), false), 'pirms gada',           '345 days with suffix = a year ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true),  '2 gadi',               '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), false), 'pirms 2 gadiem',       '548 days with suffix = 2 years ago');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),    'gads',                 '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),    '5 gadi',               '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), false),   'pirms 5 gadiem',       '5 years with suffix = 5 years ago');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'pc dam sekundm',  'prefix');
        assert.equal(moment(0).from(30000), 'pirms dam sekundm', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pirms dam sekundm',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'pc dam sekundm', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'pc 5 dienm', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'odien pulksten 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'odien pulksten 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'odien pulksten 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Rt pulksten 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'odien pulksten 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Vakar pulksten 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pulksten] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Pagju] dddd [pulksten] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Pagju] dddd [pulksten] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Pagju] dddd [pulksten] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('me');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedjelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedjelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedjelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedjelja ned. ne_ponedjeljak pon. po_utorak uto. ut_srijeda sri. sr_etvrtak et. e_petak pet. pe_subota sub. su'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekoliko sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedan minut',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedan minut',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuta',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mjesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mjesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mjesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mjeseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mjeseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mjeseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mjesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mjeseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za nekoliko sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'prije nekoliko sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'prije nekoliko sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za nekoliko sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'danas u 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sjutra u 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'jue u 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedjelju] [u] LT';
            case 3:
                return '[u] [srijedu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            var lastWeekDay = [
                    '[prole] [nedjelje] [u] LT',
                    '[prolog] [ponedjeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srijede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];

            return lastWeekDay[d.day()];
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 1st is the first week of the year.

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('mk');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, H:mm:ss',        ',  14- 2010, 15:25:50'],
                ['ddd, hA',                            ', 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2- 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14- 14'],
                ['d do dddd ddd dd',                   '0 0-   e'],
                ['DDD DDDo DDDD',                      '45 45- 045'],
                ['w wo ww',                            '7 7- 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45- day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14  2010'],
                ['LLL',                                '14  2010 15:25'],
                ['LLLL',                               ', 14  2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14  2010'],
                ['lll',                                '14  2010 15:25'],
                ['llll',                               ', 14  2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-', '1-');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-', '2-');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-', '3-');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-', '4-');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-', '5-');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-', '6-');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-', '7-');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-', '8-');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-', '9-');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-', '10-');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-', '11-');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-', '12-');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-', '13-');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-', '14-');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-', '15-');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-', '16-');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-', '17-');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-', '18-');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-', '19-');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-', '20-');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-', '21-');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-', '22-');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-', '23-');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-', '24-');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-', '25-');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-', '26-');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-', '27-');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-', '28-');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-', '29-');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-', '30-');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-', '31-');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  e_  o_  _  _  _  _  a'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',          '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',          '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',        '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',       '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',             '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',             '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',         '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',             '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',             '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',          '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',             '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',          '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',         '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',           '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',           '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',           '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',        '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',        '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',        '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',           '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',        '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',          '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',          '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 6:
                return '[ ] dddd [] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[ ] dddd [] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ml');

    test('parse', function (assert) {
        var tests = ' ._ ._ ._ ._ _ _ ._ ._ ._ ._ ._ .'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss -',  ', 14  2010,   3:25:50 -'],
                ['ddd, a h -',                       ',   3 -'],
                ['M Mo MM MMMM MMM',                   '2 2 02  .'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '   '],
                ['LTS',                                '  3:25:50 -'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14  2010'],
                ['LLL',                                '14  2010,   3:25 -'],
                ['LLLL',                               ', 14  2010,   3:25 -'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 . 2010'],
                ['lll',                                '14 . 2010,   3:25 -'],
                ['llll',                               ', 14 . 2010,   3:25 -']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = ' ._ ._ ._ ._ _ _ ._ ._ ._ ._ ._ .'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  ' ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', '  ');
        assert.equal(moment().add({d: 5}).fromNow(), '5  ', '5  ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  2:00 -',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  2:25 -',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '  5:00 -',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  2:00 -',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  1:00 -',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  2:00 -', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), ' ', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), ' ', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('mr');

    test('parse', function (assert) {
        var tests = ' ._ ._ ._ ._ ._ ._ ._ ._ ._ ._ ._ .'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss ', ',   ,  :: '],
                ['ddd, a h ',                       ',   '],
                ['M Mo MM MMMM MMM',                   '    .'],
                ['YYYY YY',                            ' '],
                ['D Do DD',                            '  '],
                ['d do dddd ddd dd',                   '    '],
                ['DDD DDDo DDDD',                      '  '],
                ['w wo ww',                            '  '],
                ['h hh',                               ' '],
                ['H HH',                               ' '],
                ['m mm',                               ' '],
                ['s ss',                               ' '],
                ['a A',                                ' '],
                ['LTS',                                ' :: '],
                ['L',                                  '//'],
                ['LL',                                 '  '],
                ['LLL',                                '  ,  : '],
                ['LLLL',                               ',   ,  : '],
                ['l',                                  '//'],
                ['ll',                                 ' . '],
                ['lll',                                ' . ,  : '],
                ['llll',                               ',  . ,  : ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '', '');
    });

    test('format month', function (assert) {
        var expected = ' ._ ._ ._ ._ ._ ._ ._ ._ ._ ._ ._ .'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  ' ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true), ' ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  ' ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   ' ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  ' ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  ' ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   ' ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  ' ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true), ' ', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true), ' ', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true), ' ', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true), ' ', '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true), ' ', '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true), ' ', '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true), ' ', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true), ' ', '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), ' ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true), ' ', '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ', 'prefix');
        assert.equal(moment(0).from(30000), ' ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), ' ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), ' ', ' ');
        assert.equal(moment().add({d: 5}).fromNow(), '  ', '  ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  : ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  : ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 3}).calendar(),       '  : ',     'Now plus 3 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  : ',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  : ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  : ', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format('[] dddd[,] LT'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('[] dddd[,] LT'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('[] dddd[,] LT'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '', ' during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '  ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '  ', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '  ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '  ', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '  ', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ms-my');

    test('parse', function (assert) {
        var i,
            tests = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' sepatutnya bulan ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ahad, Februari 14 2010, 3:25:50 petang'],
                ['ddd, hA',                            'Ahd, 3petang'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Ahad Ahd Ah'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'petang petang'],
                ['[hari] [ke] DDDo [tahun] ini', 'hari ke 45 tahun ini'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Ahad, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Ahd, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Ahad Ahd Ah_Isnin Isn Is_Selasa Sel Sl_Rabu Rab Rb_Khamis Kha Km_Jumaat Jum Jm_Sabtu Sab Sb'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa saat', '44 saat = beberapa saat');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'seminit',      '45 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'seminit',      '89 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minit',     '90 saat = 2 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minit',    '44 minit = 44 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minit = 2 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 jam = 5 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 jam = 21 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 jam = 2 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 hari = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 hari = 5 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 hari = 25 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '45 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 hari = 3 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 bulan = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 bulan = 5 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 hari = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 hari = 2 tahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 tahun = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 tahun = 5 tahun');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dalam beberapa saat',  'prefix');
        assert.equal(moment(0).from(30000), 'beberapa saat yang lepas', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'beberapa saat yang lepas',  'waktu sekarang dari sekarang sepatutnya menunjukkan sebagai telah lepas');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa saat', 'dalam beberapa saat');
        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'dalam 5 hari');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hari ini pukul 02.00',     'hari ini pada waktu yang sama');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 02.25',     'Sekarang tambah 25 minit');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 03.00',     'Sekarang tambah 1 jam');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Esok pukul 02.00',  'esok pada waktu yang sama');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 01.00',     'Sekarang tolak 1 jam');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kelmarin pukul 02.00', 'kelmarin pada waktu yang sama');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari tamat hari');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari tamat hari');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 1 minggu');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 2 minggu');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 sepatutnya minggu 1');
        assert.equal(moment([2012, 0,  7]).week(), 2, 'Jan  7 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0, 14]).week(), 3, 'Jan 14 2012 sepatutnya minggu 3');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 sepatutnya minggu 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 53, 'Dec 31 2006 sepatutnya minggu 53');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 sepatutnya minggu 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 sepatutnya minggu 1');
        assert.equal(moment([2007,  0,  7]).week(), 1, 'Jan  7 2007 sepatutnya minggu 1');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 sepatutnya minggu 2');
        assert.equal(moment([2007,  0, 14]).week(), 2, 'Jan 14 2007 sepatutnya minggu 2');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 30]).week(), 52, 'Dec 30 2007 sepatutnya minggu 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 sepatutnya minggu 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 sepatutnya minggu 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 sepatutnya minggu 1');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 sepatutnya minggu 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 sepatutnya minggu 2');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 52, 'Dec 29 2002 sepatutnya minggu 52');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 sepatutnya minggu 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 sepatutnya minggu 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 sepatutnya minggu 1');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 sepatutnya minggu 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 sepatutnya minggu 2');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 52, 'Dec 28 2008 sepatutnya minggu 52');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 sepatutnya minggu 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 sepatutnya minggu 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 sepatutnya minggu 1');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 sepatutnya minggu 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 sepatutnya minggu 2');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 52, 'Dec 27 2009 sepatutnya minggu 52');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 sepatutnya minggu 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 sepatutnya minggu 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 sepatutnya minggu 1');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 sepatutnya minggu 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 sepatutnya minggu 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 52, 'Dec 26 2010 sepatutnya minggu 52');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 sepatutnya minggu 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 sepatutnya minggu 1');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 sepatutnya minggu 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 sepatutnya minggu 2');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 sepatutnya minggu 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 sepatutnya minggu 3');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 sepatutnya minggu 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ms');

    test('parse', function (assert) {
        var i,
            tests = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' sepatutnya bulan ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Ahad, Februari 14 2010, 3:25:50 petang'],
                ['ddd, hA',                            'Ahd, 3petang'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Februari Feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Ahad Ahd Ah'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'petang petang'],
                ['[hari] [ke] DDDo [tahun] ini', 'hari ke 45 tahun ini'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Februari 2010'],
                ['LLL',                                '14 Februari 2010 pukul 15.25'],
                ['LLLL',                               'Ahad, 14 Februari 2010 pukul 15.25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Feb 2010'],
                ['lll',                                '14 Feb 2010 pukul 15.25'],
                ['llll',                               'Ahd, 14 Feb 2010 pukul 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = 'Januari Jan_Februari Feb_Mac Mac_April Apr_Mei Mei_Jun Jun_Julai Jul_Ogos Ogs_September Sep_Oktober Okt_November Nov_Disember Dis'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'Ahad Ahd Ah_Isnin Isn Is_Selasa Sel Sl_Rabu Rab Rb_Khamis Kha Km_Jumaat Jum Jm_Sabtu Sab Sb'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'beberapa saat', '44 saat = beberapa saat');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'seminit',      '45 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'seminit',      '89 saat = seminit');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minit',     '90 saat = 2 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minit',    '44 minit = 44 minit');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'sejam',       '45 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'sejam',       '89 minit = sejam');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 jam',       '90 minit = 2 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 jam',       '5 jam = 5 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 jam',      '21 jam = 21 jam');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'sehari',         '22 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'sehari',         '35 jam = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 hari',        '36 jam = 2 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'sehari',         '1 hari = sehari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 hari',        '5 hari = 5 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 hari',       '25 hari = 25 hari');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'sebulan',       '26 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'sebulan',       '30 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'sebulan',       '45 hari = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 bulan',      '46 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 bulan',      '75 hari = 2 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 bulan',      '76 hari = 3 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'sebulan',       '1 bulan = sebulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 bulan',      '5 bulan = 5 bulan');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'setahun',        '345 hari = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 tahun',       '548 hari = 2 tahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'setahun',        '1 tahun = setahun');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 tahun',       '5 tahun = 5 tahun');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dalam beberapa saat',  'prefix');
        assert.equal(moment(0).from(30000), 'beberapa saat yang lepas', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'beberapa saat yang lepas',  'waktu sekarang dari sekarang sepatutnya menunjukkan sebagai telah lepas');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dalam beberapa saat', 'dalam beberapa saat');
        assert.equal(moment().add({d: 5}).fromNow(), 'dalam 5 hari', 'dalam 5 hari');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hari ini pukul 02.00',     'hari ini pada waktu yang sama');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hari ini pukul 02.25',     'Sekarang tambah 25 minit');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hari ini pukul 03.00',     'Sekarang tambah 1 jam');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Esok pukul 02.00',  'esok pada waktu yang sama');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hari ini pukul 01.00',     'Sekarang tolak 1 jam');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kelmarin pukul 02.00', 'kelmarin pada waktu yang sama');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [pukul] LT'),  'Hari ini + ' + i + ' hari tamat hari');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari waktu sekarang');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari permulaan hari');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [lepas] [pukul] LT'),  'Hari ini - ' + i + ' hari tamat hari');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 1 minggu');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 minggu lepas');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'dalam 2 minggu');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 sepatutnya minggu 1');
        assert.equal(moment([2012, 0,  7]).week(), 2, 'Jan  7 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0, 14]).week(), 3, 'Jan 14 2012 sepatutnya minggu 3');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 sepatutnya minggu 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 53, 'Dec 31 2006 sepatutnya minggu 53');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 sepatutnya minggu 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 sepatutnya minggu 1');
        assert.equal(moment([2007,  0,  7]).week(), 1, 'Jan  7 2007 sepatutnya minggu 1');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 sepatutnya minggu 2');
        assert.equal(moment([2007,  0, 14]).week(), 2, 'Jan 14 2007 sepatutnya minggu 2');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 30]).week(), 52, 'Dec 30 2007 sepatutnya minggu 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 sepatutnya minggu 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 sepatutnya minggu 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 sepatutnya minggu 1');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 sepatutnya minggu 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 sepatutnya minggu 2');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 52, 'Dec 29 2002 sepatutnya minggu 52');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 sepatutnya minggu 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 sepatutnya minggu 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 sepatutnya minggu 1');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 sepatutnya minggu 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 sepatutnya minggu 2');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 52, 'Dec 28 2008 sepatutnya minggu 52');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 sepatutnya minggu 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 sepatutnya minggu 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 sepatutnya minggu 1');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 sepatutnya minggu 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 sepatutnya minggu 2');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 52, 'Dec 27 2009 sepatutnya minggu 52');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 sepatutnya minggu 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 sepatutnya minggu 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 sepatutnya minggu 1');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 sepatutnya minggu 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 sepatutnya minggu 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 52, 'Dec 26 2010 sepatutnya minggu 52');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 sepatutnya minggu 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 sepatutnya minggu 1');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 sepatutnya minggu 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 sepatutnya minggu 2');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 sepatutnya minggu 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 sepatutnya minggu 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 sepatutnya minggu 3');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 sepatutnya minggu 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('my');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'),
            i;

        function equalTest (input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', ',   , :: pm'],
                ['ddd, hA', ', PM'],
                ['M Mo MM MMMM MMM', '    '],
                ['YYYY YY', ' '],
                ['D Do DD', '  '],
                ['d do dddd ddd dd', '    '],
                ['DDD DDDo DDDD', '  '],
                ['w wo ww', '  '],
                ['h hh', ' '],
                ['H HH', ' '],
                ['m mm', ' '],
                ['s ss', ' '],
                ['a A', 'pm PM'],
                ['[] DDDo []', '  '],
                ['LTS', '::'],
                ['L', '//'],
                ['LL', '  '],
                ['LLL', '   :'],
                ['LLLL', '    :'],
                ['l', '//'],
                ['ll', '  '],
                ['lll', '   :'],
                ['llll', '    :']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '', '');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'),
            i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 44
        }), true), '.', ' . = .');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 45
        }), true), '', ' . = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 89
        }), true), '', ' . = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            s: 90
        }), true), ' ', ' . =   ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 44
        }), true), ' ', '  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 45
        }), true), '', '  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 89
        }), true), '', '  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            m: 90
        }), true), ' ', ' =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 5
        }), true), ' ', ' =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 21
        }), true), ' ', '  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 22
        }), true), '', '  =');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 35
        }), true), '', '  =');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            h: 36
        }), true), ' ', '  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 1
        }), true), '', ' = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 5
        }), true), ' ', '  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 25
        }), true), ' ', ' =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 26
        }), true), '', '  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 30
        }), true), '', '  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 43
        }), true), '', '  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 46
        }), true), ' ', '  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 74
        }), true), ' ', ' =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 76
        }), true), ' ', '  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 1
        }), true), '', '  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            M: 5
        }), true), ' ', '  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 345
        }), true), '', '  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            d: 548
        }), true), ' ', '  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 1
        }), true), '', '  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({
            y: 5
        }), true), ' ', '  =  ');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' . ', 'prefix');
        assert.equal(moment(0).from(30000), ' . ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), ' . ', ' ');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({
            s: 30
        }).fromNow(), ' . ', ' . ');
        assert.equal(moment().add({
            d: 5
        }).fromNow(), '   ', '   ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(), '. : ', '. ');
        assert.equal(moment(a).add({
            m: 25
        }).calendar(), '. : ', '  ');
        assert.equal(moment(a).add({
            h: 1
        }).calendar(), '. : ', '  ');
        assert.equal(moment(a).add({
            d: 1
        }).calendar(), ' : ', ' ');
        assert.equal(moment(a).subtract({
            h: 1
        }).calendar(), '. : ', '  ');
        assert.equal(moment(a).subtract({
            d: 1
        }).calendar(), '. : ', '. ');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({
                d: i
            });
            assert.equal(m.calendar(), m.format('dddd LT []'), 'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('dddd LT []'), 'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('dddd LT []'), 'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({
                d: i
            });
            assert.equal(m.calendar(), m.format('[] dddd LT []'), 'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format('[] dddd LT []'), 'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format('[] dddd LT []'), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({
                w: 1
            }),
            weeksFromNow = moment().add({
                w: 1
            });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '  ');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), ' ');

        weeksAgo = moment().subtract({
            w: 2
        });
        weeksFromNow = moment().add({
            w: 2
        });

        assert.equal(weeksAgo.calendar(), weeksAgo.format('L'), '  ');
        assert.equal(weeksFromNow.calendar(), weeksFromNow.format('L'), '  ');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(), 1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(), 1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(), 2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(), 2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008, 0, 1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008, 0, 6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008, 0, 7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008, 0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008, 0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003, 0, 1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003, 0, 5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003, 0, 6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003, 0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003, 0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009, 0, 1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009, 0, 4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009, 0, 5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009, 0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009, 0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010, 0, 1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010, 0, 3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010, 0, 4]).week(), 1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010, 0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010, 0, 11]).week(), 2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011, 0, 1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011, 0, 2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011, 0, 3]).week(), 1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011, 0, 9]).week(), 1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011, 0, 10]).week(), 2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0, 1]).format('w ww wo'), '  ', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).format('w ww wo'), '  ', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).format('w ww wo'), '  ', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).format('w ww wo'), '  ', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '  ', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('nb');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sndag, februar 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sn, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sndag sn s'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[den] DDDo [dagen i ret]',          'den 45. dagen i ret'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 kl. 15.25'],
                ['LLLL',                               'sndag 14. februar 2010 kl. 15.25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. feb 2010'],
                ['lll',                                '14. feb 2010 kl. 15.25'],
                ['llll',                               'sn 14. feb 2010 kl. 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sndag sn s_mandag man ma_tirsdag tirs ti_onsdag ons on_torsdag tors to_fredag fre fr_lrdag lr l'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'noen sekunder', '44 sekunder = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ett minutt',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ett minutt',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutter',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutter',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en time',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en time',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timer',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timer',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timer',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dager',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dager',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dager',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mned',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mned',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mned',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mneder',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mneder',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mneder',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mned',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mneder',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ett r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 r',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ett r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 r',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om noen sekunder',  'prefix');
        assert.equal(moment(0).from(30000), 'for noen sekunder siden', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'for noen sekunder siden',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om noen sekunder', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dager', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'i dag kl. 2.00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'i dag kl. 2.25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'i dag kl. 3.00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'i morgen kl. 2.00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'i dag kl. 1.00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'i gr kl. 2.00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [kl.] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[forrige] dddd [kl.] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ne');

    test('parse', function (assert) {
        var tests = ' ._ ._ _ ._ _ _ ._ ._ ._ ._ ._ .'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, a h:mm:ss ',       ',   ,  :: '],
                ['ddd, a h ',                                                      '.,   '],
                ['M Mo MM MMMM MMM',                   '    .'],
                ['YYYY YY',                            ' '],
                ['D Do DD',                            '  '],
                ['d do dddd ddd dd',                   '   . .'],
                ['DDD DDDo DDDD',                      '  '],
                ['w wo ww',                            '  '],
                ['h hh',                               ' '],
                ['H HH',                               ' '],
                ['m mm',                               ' '],
                ['s ss',                               ' '],
                ['a A',                                ' '],
                ['LTS',                                ' :: '],
                ['L',                                  '//'],
                ['LL',                                 '  '],
                ['LLL',                                '  ,  : '],
                ['LLLL',                               ',   ,  : '],
                ['l',                                  '//'],
                ['ll',                                 ' . '],
                ['lll',                                ' . ,  : '],
                ['llll',                               '.,  . ,  : ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '', '');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '', '');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '', '');
    });

    test('format month', function (assert) {
        var expected = ' ._ ._ _ ._ _ _ ._ ._ ._ ._ ._ .'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = ' . ._ . ._ . _ . ._ . ._ . ._ . .'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  ' ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  ' ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  ' ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   ' ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  ' ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  ' ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   ' ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  ' ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  ' ',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  ' ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  ' ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  ' ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   ' ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), ' ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   ' ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), ' ', ' ');
        assert.equal(moment().add({d: 5}).fromNow(), ' ', ' ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  : ',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  : ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  : ',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  : ',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  : ',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  : ', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd[,] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), '', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('a'), '', 'night');

        assert.equal(moment([2011, 2, 23,  2, 30]).format('A'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('A'), '', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('A'), '', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('A'), '', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('A'), '', 'late evening');
        assert.equal(moment([2011, 2, 23, 21, 20]).format('A'), '', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '  ', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '  ', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '  ', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '  ', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '  ', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('nl');

    test('parse', function (assert) {
        var tests = 'januari jan._februari feb._maart mrt._april apr._mei mei._juni jun._juli jul._augustus aug._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',       'zondag, februari 14de 2010, 15:25:50'],
                ['ddd, HH',                            'zo., 15'],
                ['M Mo MM MMMM MMM',                   '2 2de 02 februari feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14de 14'],
                ['d do dddd ddd dd',                   '0 0de zondag zo. Zo'],
                ['DDD DDDo DDDD',                      '45 45ste 045'],
                ['w wo ww',                            '6 6de 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45ste day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14-02-2010'],
                ['LL',                                 '14 februari 2010'],
                ['LLL',                                '14 februari 2010 15:25'],
                ['LLLL',                               'zondag 14 februari 2010 15:25'],
                ['l',                                  '14-2-2010'],
                ['ll',                                 '14 feb. 2010'],
                ['lll',                                '14 feb. 2010 15:25'],
                ['llll',                               'zo. 14 feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1ste', '1ste');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2de', '2de');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3de', '3de');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4de', '4de');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5de', '5de');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6de', '6de');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7de', '7de');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8ste', '8ste');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9de', '9de');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10de', '10de');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11de', '11de');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12de', '12de');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13de', '13de');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14de', '14de');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15de', '15de');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16de', '16de');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17de', '17de');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18de', '18de');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19de', '19de');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20ste', '20ste');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21ste', '21ste');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22ste', '22ste');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23ste', '23ste');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24ste', '24ste');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25ste', '25ste');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26ste', '26ste');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27ste', '27ste');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28ste', '28ste');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29ste', '29ste');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30ste', '30ste');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31ste', '31ste');
    });

    test('format month', function (assert) {
        var expected = 'januari jan._februari feb._maart mrt._april apr._mei mei_juni jun._juli jul._augustus aug._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'zondag zo. Zo_maandag ma. Ma_dinsdag di. Di_woensdag wo. Wo_donderdag do. Do_vrijdag vr. Vr_zaterdag za. Za'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'een paar seconden', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'n minuut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'n minuut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuten',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuten',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'n uur',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'n uur',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 uur',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 uur',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 uur',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'n dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'n dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagen',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'n dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagen',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagen',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'n maand',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'n maand',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'n maand',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 maanden',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 maanden',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 maanden',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'n maand',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 maanden',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'n jaar',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 jaar',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'n jaar',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 jaar',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'over een paar seconden',  'prefix');
        assert.equal(moment(0).from(30000), 'een paar seconden geleden', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'een paar seconden geleden',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'over een paar seconden', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'over 5 dagen', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'vandaag om 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'vandaag om 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'vandaag om 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'morgen om 02:00',    'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'vandaag om 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'gisteren om 02:00',   'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [om] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[afgelopen] dddd [om] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('month abbreviation', function (assert) {
        assert.equal(moment([2012, 5, 23]).format('D-MMM-YYYY'), '23-jun-2012', 'format month abbreviation surrounded by dashes should not include a dot');
        assert.equal(moment([2012, 5, 23]).format('D MMM YYYY'), '23 jun. 2012', 'format month abbreviation not surrounded by dashes should include a dot');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52ste', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1ste', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1ste', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),    '2 02 2de', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),    '2 02 2de', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('nn');

    test('parse', function (assert) {
        var tests = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sundag, februar 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sun, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. sundag sun su'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 februar 2010'],
                ['LLL',                                '14 februar 2010 15:25'],
                ['LLLL',                               'sundag 14 februar 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'sun 14 feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan_februar feb_mars mar_april apr_mai mai_juni jun_juli jul_august aug_september sep_oktober okt_november nov_desember des'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sundag sun su_mndag mn m_tysdag tys ty_onsdag ons on_torsdag tor to_fredag fre fr_laurdag lau l'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nokre sekund', '44 sekunder = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'eit minutt',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'eit minutt',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutt',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutt',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ein time',     '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ein time',     '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timar',      '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timar',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timar',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ein dag',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ein dag',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',      '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ein dag',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',      '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ein mnad',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ein mnad',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ein mnad',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mnader',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mnader',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mnader',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ein mnad',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mnader',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eit r',       '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 r',         '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eit r',       '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 r',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om nokre sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'for nokre sekund sidan', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'for nokre sekund sidan',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om nokre sekund', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dagar', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'I dag klokka 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'I dag klokka 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'I dag klokka 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'I morgon klokka 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'I dag klokka 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'I gr klokka 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [klokka] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[Fregande] dddd [klokka] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[Fregande] dddd [klokka] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[Fregande] dddd [klokka] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('pl');

    test('parse', function (assert) {
        var tests = 'stycze stycznia sty_luty lutego lut_marzec marca mar_kwiecie kwietnia kwi_maj maja maj_czerwiec czerwca cze_lipiec lipca lip_sierpie sierpnia sie_wrzesie wrzenia wrz_padziernik padziernika pa_listopad listopada lis_grudzie grudnia gru'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][2], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][2], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse strict', function (assert) {
        var tests = 'stycze stycznia sty_luty lutego lut_marzec marca mar_kwiecie kwietnia kwi_maj maja maj_czerwiec czerwca cze_lipiec lipca lip_sierpie sierpnia sie_wrzesie wrzenia wrz_padziernik padziernika pa_listopad listopada lis_grudzie grudnia gru'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm, true).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][2], 'MMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleLowerCase(), 'MMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][2].toLocaleUpperCase(), 'MMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'niedziela, luty 14. 2010, 3:25:50 pm'],
                ['ddd, hA',                            'nie, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 luty lut'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. niedziela nie N'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 lutego 2010'],
                ['LLL',                                '14 lutego 2010 15:25'],
                ['LLLL',                               'niedziela, 14 lutego 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 lut 2010'],
                ['lll',                                '14 lut 2010 15:25'],
                ['llll',                               'nie, 14 lut 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'stycze sty_luty lut_marzec mar_kwiecie kwi_maj maj_czerwiec cze_lipiec lip_sierpie sie_wrzesie wrz_padziernik pa_listopad lis_grudzie gru'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'niedziela nie N_poniedziaek pon Pn_wtorek wt Wt_roda r r_czwartek czw Cz_pitek pt Pt_sobota sb So'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'kilka sekund',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minuta',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minuta',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuty',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuty',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'godzina',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'godzina',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 godziny',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 godzin',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 godzin',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 dzie',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 dzie',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 dzie',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dni',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dni',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'miesic',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'miesic',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'miesic',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 miesice',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 miesice',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 miesice',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'miesic',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 miesicy',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 lata',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 lat',         '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 112}), true), '112 lat',       '112 years = 112 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 122}), true), '122 lata',      '122 years = 122 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 213}), true), '213 lat',       '213 years = 213 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 223}), true), '223 lata',      '223 years = 223 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za kilka sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'kilka sekund temu', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'kilka sekund temu',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za kilka sekund', 'in a few seconds');
        assert.equal(moment().add({h: 1}).fromNow(), 'za godzin', 'in an hour');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dni', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Dzi o 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Dzi o 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Dzi o 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Jutro o 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Dzi o 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Wczoraj o 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[W] dddd [o] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[W zesz niedziel o] LT';
            case 3:
                return '[W zesz rod o] LT';
            case 6:
                return '[W zesz sobot o] LT';
            default:
                return '[W zeszy] dddd [o] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days current time');

            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days beginning of day');

            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(), m.format(makeFormat(m)), 'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('pt-br');

    test('parse', function (assert) {
        var tests = 'janeiro jan_fevereiro fev_maro mar_abril abr_maio mai_junho jun_julho jul_agosto ago_setembro set_outubro out_novembro nov_dezembro dez'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Fevereiro 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Fevereiro Fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd',                      '0 0 Domingo Dom'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 de Fevereiro de 2010'],
                ['LLL',                                '14 de Fevereiro de 2010 s 15:25'],
                ['LLLL',                               'Domingo, 14 de Fevereiro de 2010 s 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 de Fev de 2010'],
                ['lll',                                '14 de Fev de 2010 s 15:25'],
                ['llll',                               'Dom, 14 de Fev de 2010 s 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'Janeiro Jan_Fevereiro Fev_Maro Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom_Segunda-Feira Seg_Tera-Feira Ter_Quarta-Feira Qua_Quinta-Feira Qui_Sexta-Feira Sex_Sbado Sb'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'poucos segundos', '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'um minuto',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'um minuto',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'uma hora',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'uma hora',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'um dia',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'um dia',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dias',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'um dia',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dias',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dias',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'um ms',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'um ms',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'um ms',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'um ms',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'um ano',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'um ano',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'em poucos segundos', 'prefix');
        assert.equal(moment(0).from(30000), 'poucos segundos atrs', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'em poucos segundos', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'em 5 dias', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hoje s 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hoje s 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hoje s 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Amanh s 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hoje s 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ontem s 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [s] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [s] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [s] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[ltimo] dddd [s] LT' : '[ltima] dddd [s] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[ltimo] dddd [s] LT' : '[ltima] dddd [s] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[ltimo] dddd [s] LT' : '[ltima] dddd [s] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('pt');

    test('parse', function (assert) {
        var tests = 'Janeiro Jan_Fevereiro Fev_Maro Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Domingo, Fevereiro 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Dom, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Fevereiro Fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd',                      '0 0 Domingo Dom'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 de Fevereiro de 2010'],
                ['LLL',                                '14 de Fevereiro de 2010 15:25'],
                ['LLLL',                               'Domingo, 14 de Fevereiro de 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 de Fev de 2010'],
                ['lll',                                '14 de Fev de 2010 15:25'],
                ['llll',                               'Dom, 14 de Fev de 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'Janeiro Jan_Fevereiro Fev_Maro Mar_Abril Abr_Maio Mai_Junho Jun_Julho Jul_Agosto Ago_Setembro Set_Outubro Out_Novembro Nov_Dezembro Dez'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Domingo Dom Dom_Segunda-Feira Seg 2_Tera-Feira Ter 3_Quarta-Feira Qua 4_Quinta-Feira Qui 5_Sexta-Feira Sex 6_Sbado Sb Sb'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'segundos',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'um minuto',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'um minuto',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minutos',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minutos', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'uma hora',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'uma hora',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 horas',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 horas',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 horas',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'um dia',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'um dia',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dias',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'um dia',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dias',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dias',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'um ms',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'um ms',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'um ms',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meses',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meses',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meses',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'um ms',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meses',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'um ano',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 anos',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'um ano',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 anos',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'em segundos', 'prefix');
        assert.equal(moment(0).from(30000), 'h segundos', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'em segundos', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'em 5 dias', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hoje s 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hoje s 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hoje s 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Amanh s 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hoje s 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Ontem s 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [s] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [s] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [s] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[ltimo] dddd [s] LT' : '[ltima] dddd [s] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[ltimo] dddd [s] LT' : '[ltima] dddd [s] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format((m.day() === 0 || m.day() === 6) ? '[ltimo] dddd [s] LT' : '[ltima] dddd [s] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),  '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),  '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),  '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),  '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ro');

    test('parse', function (assert) {
        var tests = 'ianuarie ian._februarie febr._martie mart._aprilie apr._mai mai_iunie iun._iulie iul._august aug._septembrie sept._octombrie oct._noiembrie nov._decembrie dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss A',  'duminic, februarie 14 2010, 3:25:50 PM'],
                ['ddd, hA',                        'Dum, 3PM'],
                ['M Mo MM MMMM MMM',               '2 2 02 februarie febr.'],
                ['YYYY YY',                        '2010 10'],
                ['D Do DD',                        '14 14 14'],
                ['d do dddd ddd dd',               '0 0 duminic Dum Du'],
                ['DDD DDDo DDDD',                  '45 45 045'],
                ['w wo ww',                        '7 7 07'],
                ['h hh',                           '3 03'],
                ['H HH',                           '15 15'],
                ['m mm',                           '25 25'],
                ['s ss',                           '50 50'],
                ['a A',                            'pm PM'],
                ['[a] DDDo[a zi a anului]',        'a 45a zi a anului'],
                ['LTS',                            '15:25:50'],
                ['L',                              '14.02.2010'],
                ['LL',                             '14 februarie 2010'],
                ['LLL',                            '14 februarie 2010 15:25'],
                ['LLLL',                           'duminic, 14 februarie 2010 15:25'],
                ['l',                              '14.2.2010'],
                ['ll',                             '14 febr. 2010'],
                ['lll',                            '14 febr. 2010 15:25'],
                ['llll',                           'Dum, 14 febr. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'ianuarie ian._februarie febr._martie mart._aprilie apr._mai mai_iunie iun._iulie iul._august aug._septembrie sept._octombrie oct._noiembrie nov._decembrie dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'duminic Dum Du_luni Lun Lu_mari Mar Ma_miercuri Mie Mi_joi Joi Jo_vineri Vin Vi_smbt Sm S'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'cteva secunde', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'un minut',       '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'un minut',       '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',       '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 de minute',   '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'o or',          '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'o or',          '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ore',          '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ore',          '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 de ore',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'o zi',           '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'o zi',           '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 zile',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'o zi',           '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 zile',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 de zile',     '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'o lun',         '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'o lun',         '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'o lun',         '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 luni',         '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 luni',         '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 luni',         '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'o lun',         '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 luni',         '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'un an',          '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ani',          '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'un an',          '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ani',          '5 years = 5 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 19}), true),   '19 ani',        '19 years = 19 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 20}), true),   '20 de ani',     '20 years = 20 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 100}), true),   '100 de ani',   '100 years = 100 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 101}), true),   '101 ani',      '101 years = 101 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 119}), true),   '119 ani',      '119 years = 119 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 120}), true),   '120 de ani',   '120 years = 120 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 219}), true),   '219 ani',      '219 years = 219 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 220}), true),   '220 de ani',   '220 years = 220 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'peste cteva secunde',   'prefix');
        assert.equal(moment(0).from(30000), 'cteva secunde n urm', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'cteva secunde n urm',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'peste cteva secunde', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'peste 5 zile', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'azi la 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'azi la 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'azi la 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'mine la 2:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'azi la 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ieri la 2:00',    'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [la] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[fosta] dddd [la] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ru');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('parse exceptional case', function (assert) {
        assert.equal(moment('11  1989', ['DD MMMM YYYY']).format('DD-MM-YYYY'), '11-05-1989');
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       ', 14-  2010, 15:25:50'],
                ['ddd, h A',                           ', 3 '],
                ['M Mo MM MMMM MMM',                   '2 2- 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14- 14'],
                ['d do dddd ddd dd',                   '0 0-   '],
                ['DDD DDDo DDDD',                      '45 45- 045'],
                ['w wo ww',                            '7 7- 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['DDDo [ ]',                   '45-  '],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14  2010 .'],
                ['LLL',                                '14  2010 ., 15:25'],
                ['LLLL',                               ', 14  2010 ., 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14  2010 .'],
                ['lll',                                '14  2010 ., 15:25'],
                ['llll',                               ', 14  2010 ., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-', '1-');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-', '2-');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-', '3-');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-', '4-');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-', '5-');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-', '6-');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-', '7-');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-', '8-');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-', '9-');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-', '10-');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-', '11-');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-', '12-');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-', '13-');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-', '14-');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-', '15-');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-', '16-');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-', '17-');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-', '18-');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-', '19-');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-', '20-');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-', '21-');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-', '22-');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-', '23-');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-', '24-');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-', '25-');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-', '26-');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-', '27-');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-', '28-');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-', '29-');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-', '30-');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-', '31-');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format month short case', function (assert) {
        var monthsShort = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMM'), monthsShort.nominative[i], '1 ' + monthsShort.nominative[i]);
        }
    });

    test('format month case with escaped symbols', function (assert) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMMM[</b>]'), '<i>1</i> <b>' + months.accusative[i] + '</b>', '1 <b>' + months.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[- ] MMMM'), '1-  ' + months.accusative[i], '1-  ' + months.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMMM'), '1, ' + months.nominative[i], '1, ' + months.nominative[i]);
        }
    });

    test('format month short case with escaped symbols', function (assert) {
        var monthsShort = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2013, i, 1]).format('D[] MMM'), '1 ' + monthsShort.accusative[i], '1 ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('[<i>]D[</i>] [<b>]MMM[</b>]'), '<i>1</i> <b>' + monthsShort.accusative[i] + '</b>', '1 <b>' + monthsShort.accusative[i] + '</b>');
            assert.equal(moment([2013, i, 1]).format('D[- ] MMM'), '1-  ' + monthsShort.accusative[i], '1-  ' + monthsShort.accusative[i]);
            assert.equal(moment([2013, i, 1]).format('D, MMM'), '1, ' + monthsShort.nominative[i], '1, ' + monthsShort.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 31}), true),  '31 ',  '31 minutes = 31 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 ',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 ',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ', 'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
        assert.equal(moment().add({m: 31}).fromNow(), ' 31 ', 'in 31 minutes = in 31 minutes');
        assert.equal(moment().subtract({m: 31}).fromNow(), '31  ', '31 minutes ago = 31 minutes ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  02:00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  02:00',       'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        function makeFormat(d) {
            return d.day() === 2 ? '[] dddd [] LT' : '[] dddd [] LT';
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, now;

        function makeFormatLast(d) {
            switch (d.day()) {
            case 0:
                return '[ ] dddd [] LT';
            case 1:
            case 2:
            case 4:
                return '[ ] dddd [] LT';
            case 3:
            case 5:
            case 6:
                return '[ ] dddd [] LT';
            }
        }

        function makeFormatThis(d) {
            switch (d.day()) {
            case 2:
                return '[] dddd [] LT';
            case 0:
            case 1:
            case 3:
            case 4:
            case 5:
            case 6:
                return '[] dddd [] LT';
            }
        }

        now = moment().startOf('week');
        for (i = 2; i < 7; i++) {
            m = moment(now).subtract({d: i});
            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(now),       m.format(makeFormatLast(m)),  'Today - ' + i + ' days end of day');
        }

        now = moment().endOf('week');
        for (i = 2; i < 7; i++) {
            m = moment(now).subtract({d: i});
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(now),       m.format(makeFormatThis(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('si');

    /*jshint -W100*/
    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['YYYY MMMM Do dddd, a h:mm:ss',       '2010  14  , .. 3:25:50'],
                ['YYYY MMMM Do dddd, a h:mm:ss',       '2010  14  , .. 3:25:50'],
                ['ddd, A h',                            ',   3'],
                ['M Mo MM MMMM MMM',                   '2 2  02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14  14'],
                ['d do dddd ddd dd',                   '0 0    '],
                ['DDD DDDo DDDD',                      '45 45  045'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                '..  '],
                ['[] DDDo []',                      ' 45  '],
                ['LTS',                                '.. 3:25:50'],
                ['LT',                                 '.. 3:25'],
                ['L',                                  '2010/02/14'],
                ['LL',                                 '2010  14'],
                ['LLL',                                '2010  14, .. 3:25'],
                ['LLLL',                               '2010  14  , .. 3:25:50'],
                ['l',                                  '2010/2/14'],
                ['ll',                                 '2010  14'],
                ['lll',                                '2010  14, .. 3:25'],
                ['llll',                               '2010  14  , .. 3:25:50']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1 ', '1 ');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2 ', '2 ');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3 ', '3 ');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4 ', '4 ');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5 ', '5 ');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6 ', '6 ');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7 ', '7 ');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8 ', '8 ');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9 ', '9 ');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10 ', '10 ');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11 ', '11 ');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12 ', '12 ');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13 ', '13 ');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14 ', '14 ');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15 ', '15 ');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16 ', '16 ');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17 ', '17 ');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18 ', '18 ');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19 ', '19 ');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20 ', '20 ');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21 ', '21 ');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22 ', '22 ');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23 ', '23 ');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24 ', '24 ');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25 ', '25 ');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26 ', '26 ');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27 ', '27 ');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28 ', '28 ');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29 ', '29 ');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30 ', '30 ');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31 ', '31 ');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  ' 2',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  ' 44',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  ' 2',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   ' 5',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  ' 21',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  ' 2',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   ' 5',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  ' 25',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  ' 2',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  ' 2',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  ' 3',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   ' 5',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), ' 2',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   ' 5',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), ' ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   ' .. 2:00',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      ' .. 2:25',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       ' .. 3:00',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       ' .. 2:00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  ' .. 1:00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  ' .. 2:00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd LT[]'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd LT[]'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd LT[]'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd LT[]'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd LT[]'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd LT[]'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sk');

    test('parse', function (assert) {
        var tests = 'janur jan._februr feb._marec mar._aprl apr._mj mj_jn jn._jl jl._august aug._september sep._oktber okt._november nov._december dec.'.split('_'), i;
        function equalTest(input, mmm, monthIndex) {
            assert.equal(moment(input, mmm).month(), monthIndex, input + ' should be month ' + (monthIndex + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss',  'nedea, februr 14. 2010, 3:25:50'],
                ['ddd, h',                       'ne, 3'],
                ['M Mo MM MMMM MMM',             '2 2. 02 februr feb'],
                ['YYYY YY',                      '2010 10'],
                ['D Do DD',                      '14 14. 14'],
                ['d do dddd ddd dd',             '0 0. nedea ne ne'],
                ['DDD DDDo DDDD',                '45 45. 045'],
                ['w wo ww',                      '6 6. 06'],
                ['h hh',                         '3 03'],
                ['H HH',                         '15 15'],
                ['m mm',                         '25 25'],
                ['s ss',                         '50 50'],
                ['a A',                          'pm PM'],
                ['DDDo [de v roku]',            '45. de v roku'],
                ['LTS',                          '15:25:50'],
                ['L',                            '14.02.2010'],
                ['LL',                           '14. februr 2010'],
                ['LLL',                          '14. februr 2010 15:25'],
                ['LLLL',                         'nedea 14. februr 2010 15:25'],
                ['l',                            '14.2.2010'],
                ['ll',                           '14. feb 2010'],
                ['lll',                          '14. feb 2010 15:25'],
                ['llll',                         'ne 14. feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'janur jan_februr feb_marec mar_aprl apr_mj mj_jn jn_jl jl_august aug_september sep_oktber okt_november nov_december dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedea ne ne_pondelok po po_utorok ut ut_streda st st_tvrtok t t_piatok pi pi_sobota so so'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'pr seknd',  '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minta',        '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minta',        '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minty',      '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 mint',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'hodina',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'hodina',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 hodiny',     '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 hodn',      '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 hodn',     '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'de',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'de',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',         '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'de',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dn',         '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dn',        '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mesiac',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mesiac',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mesiac',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesiace',    '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesiace',    '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesiace',    '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mesiac',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesiacov',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'rok',           '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 roky',        '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'rok',           '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 rokov',         '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za pr seknd',  'prefix');
        assert.equal(moment(0).from(30000), 'pred pr sekundami', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pred pr sekundami',  'now from now should display as in the past');
    });

    test('fromNow (future)', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za pr seknd', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(), 'za mintu', 'in a minute');
        assert.equal(moment().add({m: 3}).fromNow(), 'za 3 minty', 'in 3 minutes');
        assert.equal(moment().add({m: 10}).fromNow(), 'za 10 mint', 'in 10 minutes');
        assert.equal(moment().add({h: 1}).fromNow(), 'za hodinu', 'in an hour');
        assert.equal(moment().add({h: 3}).fromNow(), 'za 3 hodiny', 'in 3 hours');
        assert.equal(moment().add({h: 10}).fromNow(), 'za 10 hodn', 'in 10 hours');
        assert.equal(moment().add({d: 1}).fromNow(), 'za de', 'in a day');
        assert.equal(moment().add({d: 3}).fromNow(), 'za 3 dni', 'in 3 days');
        assert.equal(moment().add({d: 10}).fromNow(), 'za 10 dn', 'in 10 days');
        assert.equal(moment().add({M: 1}).fromNow(), 'za mesiac', 'in a month');
        assert.equal(moment().add({M: 3}).fromNow(), 'za 3 mesiace', 'in 3 months');
        assert.equal(moment().add({M: 10}).fromNow(), 'za 10 mesiacov', 'in 10 months');
        assert.equal(moment().add({y: 1}).fromNow(), 'za rok', 'in a year');
        assert.equal(moment().add({y: 3}).fromNow(), 'za 3 roky', 'in 3 years');
        assert.equal(moment().add({y: 10}).fromNow(), 'za 10 rokov', 'in 10 years');
    });

    test('fromNow (past)', function (assert) {
        assert.equal(moment().subtract({s: 30}).fromNow(), 'pred pr sekundami', 'a few seconds ago');
        assert.equal(moment().subtract({m: 1}).fromNow(), 'pred mintou', 'a minute ago');
        assert.equal(moment().subtract({m: 3}).fromNow(), 'pred 3 mintami', '3 minutes ago');
        assert.equal(moment().subtract({m: 10}).fromNow(), 'pred 10 mintami', '10 minutes ago');
        assert.equal(moment().subtract({h: 1}).fromNow(), 'pred hodinou', 'an hour ago');
        assert.equal(moment().subtract({h: 3}).fromNow(), 'pred 3 hodinami', '3 hours ago');
        assert.equal(moment().subtract({h: 10}).fromNow(), 'pred 10 hodinami', '10 hours ago');
        assert.equal(moment().subtract({d: 1}).fromNow(), 'pred dom', 'a day ago');
        assert.equal(moment().subtract({d: 3}).fromNow(), 'pred 3 dami', '3 days ago');
        assert.equal(moment().subtract({d: 10}).fromNow(), 'pred 10 dami', '10 days ago');
        assert.equal(moment().subtract({M: 1}).fromNow(), 'pred mesiacom', 'a month ago');
        assert.equal(moment().subtract({M: 3}).fromNow(), 'pred 3 mesiacmi', '3 months ago');
        assert.equal(moment().subtract({M: 10}).fromNow(), 'pred 10 mesiacmi', '10 months ago');
        assert.equal(moment().subtract({y: 1}).fromNow(), 'pred rokom', 'a year ago');
        assert.equal(moment().subtract({y: 3}).fromNow(), 'pred 3 rokmi', '3 years ago');
        assert.equal(moment().subtract({y: 10}).fromNow(), 'pred 10 rokmi', '10 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'dnes o 2:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'dnes o 2:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'dnes o 3:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'zajtra o 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'dnes o 1:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'vera o 2:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m, nextDay;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            nextDay = '';
            switch (m.day()) {
            case 0:
                nextDay = 'v nedeu';
                break;
            case 1:
                nextDay = 'v pondelok';
                break;
            case 2:
                nextDay = 'v utorok';
                break;
            case 3:
                nextDay = 'v stredu';
                break;
            case 4:
                nextDay = 'vo tvrtok';
                break;
            case 5:
                nextDay = 'v piatok';
                break;
            case 6:
                nextDay = 'v sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + nextDay + '] [o] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m, lastDay;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            lastDay = '';
            switch (m.day()) {
            case 0:
                lastDay = 'minul nedeu';
                break;
            case 1:
                lastDay = 'minul pondelok';
                break;
            case 2:
                lastDay = 'minul utorok';
                break;
            case 3:
                lastDay = 'minul stredu';
                break;
            case 4:
                lastDay = 'minul tvrtok';
                break;
            case 5:
                lastDay = 'minul piatok';
                break;
            case 6:
                lastDay = 'minul sobotu';
                break;
            }
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[' + lastDay + '] [o] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('humanize duration', function (assert) {
        assert.equal(moment.duration(1, 'minutes').humanize(), 'minta', 'a minute (future)');
        assert.equal(moment.duration(1, 'minutes').humanize(true), 'za mintu', 'in a minute');
        assert.equal(moment.duration(-1, 'minutes').humanize(), 'minta', 'a minute (past)');
        assert.equal(moment.duration(-1, 'minutes').humanize(true), 'pred mintou', 'a minute ago');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sl');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._marec mar._april apr._maj maj_junij jun._julij jul._avgust avg._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._marec mar._april apr._maj maj._junij jun._julij jul._avgust avg._september sep._oktober okt._november nov._december dec.'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedelja ned. ne_ponedeljek pon. po_torek tor. to_sreda sre. sr_etrtek et. e_petek pet. pe_sobota sob. so'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekaj sekund', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'ena minuta',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'ena minuta',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuti',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minut',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'ena ura',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'ena ura',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 uri',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ur',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ur',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dni',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dni',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dni',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesece',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesecev',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'eno leto',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 leti',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'eno leto',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 let',        '5 years = 5 years');

        assert.equal(start.from(moment([2007, 1, 28]).add({m: 1}), true),  'ena minuta', 'a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 2}), true),  '2 minuti',   '2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 3}), true),  '3 minute',   '3 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 4}), true),  '4 minute',   '4 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 5}), true),  '5 minut',    '5 minutes');

        assert.equal(start.from(moment([2007, 1, 28]).add({h: 1}), true),  'ena ura', 'an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 2}), true),  '2 uri',   '2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 3}), true),  '3 ure',   '3 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 4}), true),  '4 ure',   '4 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),  '5 ur',    '5 hours');

        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),  'en dan', 'a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 2}), true),  '2 dni',  '2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 3}), true),  '3 dni',  '3 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 4}), true),  '4 dni',  '4 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),  '5 dni',  '5 days');

        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),  'en mesec',  'a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 2}), true),  '2 meseca',  '2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 3}), true),  '3 mesece',  '3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 4}), true),  '4 mesece',  '4 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),  '5 mesecev', '5 months');

        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),  'eno leto', 'a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 2}), true),  '2 leti',   '2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 3}), true),  '3 leta',   '3 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 4}), true),  '4 leta',   '4 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),  '5 let',    '5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'ez nekaj sekund',  'prefix');
        assert.equal(moment(0).from(30000), 'pred nekaj sekundami', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pred nekaj sekundami',  'now from now should display as in the past');
    });

    test('fromNow (future)', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'ez nekaj sekund', 'in a few seconds');
        assert.equal(moment().add({m: 1}).fromNow(),  'ez eno minuto', 'in a minute');
        assert.equal(moment().add({m: 2}).fromNow(),  'ez 2 minuti',   'in 2 minutes');
        assert.equal(moment().add({m: 3}).fromNow(),  'ez 3 minute',   'in 3 minutes');
        assert.equal(moment().add({m: 4}).fromNow(),  'ez 4 minute',   'in 4 minutes');
        assert.equal(moment().add({m: 5}).fromNow(),  'ez 5 minut',    'in 5 minutes');

        assert.equal(moment().add({h: 1}).fromNow(),  'ez eno uro', 'in an hour');
        assert.equal(moment().add({h: 2}).fromNow(),  'ez 2 uri',   'in 2 hours');
        assert.equal(moment().add({h: 3}).fromNow(),  'ez 3 ure',   'in 3 hours');
        assert.equal(moment().add({h: 4}).fromNow(),  'ez 4 ure',   'in 4 hours');
        assert.equal(moment().add({h: 5}).fromNow(),  'ez 5 ur',    'in 5 hours');

        assert.equal(moment().add({d: 1}).fromNow(),  'ez en dan', 'in a day');
        assert.equal(moment().add({d: 2}).fromNow(),  'ez 2 dni',  'in 2 days');
        assert.equal(moment().add({d: 3}).fromNow(),  'ez 3 dni',  'in 3 days');
        assert.equal(moment().add({d: 4}).fromNow(),  'ez 4 dni',  'in 4 days');
        assert.equal(moment().add({d: 5}).fromNow(),  'ez 5 dni',  'in 5 days');

        assert.equal(moment().add({M: 1}).fromNow(),  'ez en mesec',  'in a month');
        assert.equal(moment().add({M: 2}).fromNow(),  'ez 2 meseca',  'in 2 months');
        assert.equal(moment().add({M: 3}).fromNow(),  'ez 3 mesece',  'in 3 months');
        assert.equal(moment().add({M: 4}).fromNow(),  'ez 4 mesece',  'in 4 months');
        assert.equal(moment().add({M: 5}).fromNow(),  'ez 5 mesecev', 'in 5 months');

        assert.equal(moment().add({y: 1}).fromNow(),  'ez eno leto', 'in a year');
        assert.equal(moment().add({y: 2}).fromNow(),  'ez 2 leti',   'in 2 years');
        assert.equal(moment().add({y: 3}).fromNow(),  'ez 3 leta',   'in 3 years');
        assert.equal(moment().add({y: 4}).fromNow(),  'ez 4 leta',   'in 4 years');
        assert.equal(moment().add({y: 5}).fromNow(),  'ez 5 let',    'in 5 years');

        assert.equal(moment().subtract({s: 30}).fromNow(), 'pred nekaj sekundami', 'a few seconds ago');

        assert.equal(moment().subtract({m: 1}).fromNow(),  'pred eno minuto', 'a minute ago');
        assert.equal(moment().subtract({m: 2}).fromNow(),  'pred 2 minutama', '2 minutes ago');
        assert.equal(moment().subtract({m: 3}).fromNow(),  'pred 3 minutami', '3 minutes ago');
        assert.equal(moment().subtract({m: 4}).fromNow(),  'pred 4 minutami', '4 minutes ago');
        assert.equal(moment().subtract({m: 5}).fromNow(),  'pred 5 minutami', '5 minutes ago');

        assert.equal(moment().subtract({h: 1}).fromNow(),  'pred eno uro', 'an hour ago');
        assert.equal(moment().subtract({h: 2}).fromNow(),  'pred 2 urama', '2 hours ago');
        assert.equal(moment().subtract({h: 3}).fromNow(),  'pred 3 urami', '3 hours ago');
        assert.equal(moment().subtract({h: 4}).fromNow(),  'pred 4 urami', '4 hours ago');
        assert.equal(moment().subtract({h: 5}).fromNow(),  'pred 5 urami', '5 hours ago');

        assert.equal(moment().subtract({d: 1}).fromNow(),  'pred enim dnem', 'a day ago');
        assert.equal(moment().subtract({d: 2}).fromNow(),  'pred 2 dnevoma', '2 days ago');
        assert.equal(moment().subtract({d: 3}).fromNow(),  'pred 3 dnevi',   '3 days ago');
        assert.equal(moment().subtract({d: 4}).fromNow(),  'pred 4 dnevi',   '4 days ago');
        assert.equal(moment().subtract({d: 5}).fromNow(),  'pred 5 dnevi',   '5 days ago');

        assert.equal(moment().subtract({M: 1}).fromNow(),  'pred enim mesecem', 'a month ago');
        assert.equal(moment().subtract({M: 2}).fromNow(),  'pred 2 mesecema',   '2 months ago');
        assert.equal(moment().subtract({M: 3}).fromNow(),  'pred 3 meseci',     '3 months ago');
        assert.equal(moment().subtract({M: 4}).fromNow(),  'pred 4 meseci',     '4 months ago');
        assert.equal(moment().subtract({M: 5}).fromNow(),  'pred 5 meseci',     '5 months ago');

        assert.equal(moment().subtract({y: 1}).fromNow(),  'pred enim letom', 'a year ago');
        assert.equal(moment().subtract({y: 2}).fromNow(),  'pred 2 letoma',   '2 years ago');
        assert.equal(moment().subtract({y: 3}).fromNow(),  'pred 3 leti',     '3 years ago');
        assert.equal(moment().subtract({y: 4}).fromNow(),  'pred 4 leti',     '4 years ago');
        assert.equal(moment().subtract({y: 5}).fromNow(),  'pred 5 leti',     '5 years ago');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'danes ob 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danes ob 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danes ob 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'jutri ob 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danes ob 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'veraj ob 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[v] [nedeljo] [ob] LT';
            case 3:
                return '[v] [sredo] [ob] LT';
            case 6:
                return '[v] [soboto] [ob] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[v] dddd [ob] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[prejnjo] [nedeljo] [ob] LT';
            case 3:
                return '[prejnjo] [sredo] [ob] LT';
            case 6:
                return '[prejnjo] [soboto] [ob] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[prejnji] dddd [ob] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sq');

    test('parse', function (assert) {
        var i,
            tests = 'Janar Jan_Shkurt Shk_Mars Mar_Prill Pri_Maj Maj_Qershor Qer_Korrik Kor_Gusht Gus_Shtator Sht_Tetor Tet_Nntor Nn_Dhjetor Dhj'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, HH:mm:ss',       'E Diel, Shkurt 14. 2010, 15:25:50'],
                ['ddd, HH',                            'Die, 15'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 Shkurt Shk'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. E Diel Die D'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'MD MD'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 Shkurt 2010'],
                ['LLL',                                '14 Shkurt 2010 15:25'],
                ['LLLL',                               'E Diel, 14 Shkurt 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Shk 2010'],
                ['lll',                                '14 Shk 2010 15:25'],
                ['llll',                               'Die, 14 Shk 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), 'PD', 'before dawn');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), 'MD', 'noon');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var i,
            expected = 'Janar Jan_Shkurt Shk_Mars Mar_Prill Pri_Maj Maj_Qershor Qer_Korrik Kor_Gusht Gus_Shtator Sht_Tetor Tet_Nntor Nn_Dhjetor Dhj'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'E Diel Die D_E Hn Hn H_E Mart Mar Ma_E Mrkur Mr M_E Enjte Enj E_E Premte Pre P_E Shtun Sht Sh'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'disa sekonda', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'nj minut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'nj minut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuta',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'nj or',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'nj or',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 or',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 or',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 or',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'nj dit',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'nj dit',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dit',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'nj dit',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dit',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dit',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'nj muaj',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'nj muaj',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'nj muaj',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 muaj',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 muaj',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 muaj',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'nj muaj',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 muaj',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'nj vit',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 vite',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'nj vit',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 vite',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'n disa sekonda',  'prefix');
        assert.equal(moment(0).from(30000), 'disa sekonda m par', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'disa sekonda m par',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'n disa sekonda', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'n 5 dit', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Sot n 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Sot n 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Sot n 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Nesr n 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Sot n 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Dje n 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [n] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [n] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [n] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [e kaluar n] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [e kaluar n] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [e kaluar n] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sr-cyrl');

    test('parse', function (assert) {
        var tests = ' ._ ._ ._ ._ _ _ _ ._ ._ ._ ._ .'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      ', 14.  2010, 3:25:50 pm'],
                ['ddd, hA',                            '., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02  .'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0.  . '],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14.  2010'],
                ['LLL',                                '14.  2010 15:25'],
                ['LLLL',                               ', 14.  2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. . 2010'],
                ['lll',                                '14. . 2010 15:25'],
                ['llll',                               '., 14. . 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = ' ._ ._ ._ ._ _ _ _ ._ ._ ._ ._ .'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = ' . _ . _ . _ . _ . _ . _ . '.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ',  'prefix');
        assert.equal(moment(0).from(30000), '  ', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '  ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[] [] [] LT';
            case 3:
                return '[] [] [] LT';
            case 6:
                return '[] [] [] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[] dddd [] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            var lastWeekDay = [
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT',
                    '[] [] [] LT'
                ];

            return lastWeekDay[d.day()];
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sr');

    test('parse', function (assert) {
        var tests = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      'nedelja, 14. februar 2010, 3:25:50 pm'],
                ['ddd, hA',                            'ned., 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 februar feb.'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. nedelja ned. ne'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '7 7. 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14. 02. 2010'],
                ['LL',                                 '14. februar 2010'],
                ['LLL',                                '14. februar 2010 15:25'],
                ['LLLL',                               'nedelja, 14. februar 2010 15:25'],
                ['l',                                  '14. 2. 2010'],
                ['ll',                                 '14. feb. 2010'],
                ['lll',                                '14. feb. 2010 15:25'],
                ['llll',                               'ned., 14. feb. 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'januar jan._februar feb._mart mar._april apr._maj maj_jun jun_jul jul_avgust avg._septembar sep._oktobar okt._novembar nov._decembar dec.'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'nedelja ned. ne_ponedeljak pon. po_utorak uto. ut_sreda sre. sr_etvrtak et. e_petak pet. pe_subota sub. su'.split('_'),
            i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'nekoliko sekundi', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'jedan minut',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'jedan minut',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minute',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuta',     '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'jedan sat',      '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'jedan sat',      '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 sata',        '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 sati',         '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 sati',        '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'dan',       '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'dan',       '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dana',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'dan',       '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dana',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dana',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mesec',     '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mesec',     '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mesec',     '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 meseca',     '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 meseca',     '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 meseca',     '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mesec',     '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 meseci',    '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'godinu',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 godine',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'godinu',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 godina',        '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'za nekoliko sekundi',  'prefix');
        assert.equal(moment(0).from(30000), 'pre nekoliko sekundi', 'prefix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'pre nekoliko sekundi',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'za nekoliko sekundi', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'za 5 dana', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'danas u 2:00',  'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'danas u 2:25',  'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'danas u 3:00',  'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'sutra u 2:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'danas u 1:00',  'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'jue u 2:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
                return '[u] [nedelju] [u] LT';
            case 3:
                return '[u] [sredu] [u] LT';
            case 6:
                return '[u] [subotu] [u] LT';
            case 1:
            case 2:
            case 4:
            case 5:
                return '[u] dddd [u] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            var lastWeekDay = [
                    '[prole] [nedelje] [u] LT',
                    '[prolog] [ponedeljka] [u] LT',
                    '[prolog] [utorka] [u] LT',
                    '[prole] [srede] [u] LT',
                    '[prolog] [etvrtka] [u] LT',
                    '[prolog] [petka] [u] LT',
                    '[prole] [subote] [u] LT'
                ];

            return lastWeekDay[d.day()];
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1.', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1.', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2.', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2.', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3.', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('sv');

    test('parse', function (assert) {
        var tests = 'januari jan_februari feb_mars mar_april apr_maj maj_juni jun_juli jul_augusti aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'sndag, februari 14e 2010, 3:25:50 pm'],
                ['ddd, hA',                            'sn, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2a 02 februari feb'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14e 14'],
                ['d do dddd ddd dd',                   '0 0e sndag sn s'],
                ['DDD DDDo DDDD',                      '45 45e 045'],
                ['w wo ww',                            '6 6e 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45e day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '14 februari 2010'],
                ['LLL',                                '14 februari 2010 15:25'],
                ['LLLL',                               'sndag 14 februari 2010 15:25'],
                ['l',                                  '2010-2-14'],
                ['ll',                                 '14 feb 2010'],
                ['lll',                                '14 feb 2010 15:25'],
                ['llll',                               'sn 14 feb 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1a', '1a');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2a', '2a');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3e', '3e');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4e', '4e');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5e', '5e');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6e', '6e');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7e', '7e');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8e', '8e');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9e', '9e');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10e', '10e');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11e', '11e');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12e', '12e');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13e', '13e');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14e', '14e');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15e', '15e');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16e', '16e');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17e', '17e');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18e', '18e');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19e', '19e');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20e', '20e');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21a', '21a');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22a', '22a');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23e', '23e');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24e', '24e');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25e', '25e');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26e', '26e');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27e', '27e');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28e', '28e');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29e', '29e');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30e', '30e');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31a', '31a');
    });

    test('format month', function (assert) {
        var expected = 'januari jan_februari feb_mars mar_april apr_maj maj_juni jun_juli jul_augusti aug_september sep_oktober okt_november nov_december dec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'sndag sn s_mndag mn m_tisdag tis ti_onsdag ons on_torsdag tor to_fredag fre fr_lrdag lr l'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ngra sekunder', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'en minut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'en minut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuter',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuter',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'en timme',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'en timme',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 timmar',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 timmar',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 timmar',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'en dag',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'en dag',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 dagar',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'en dag',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 dagar',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 dagar',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'en mnad',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'en mnad',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'en mnad',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mnader',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mnader',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mnader',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'en mnad',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mnader',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'ett r',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 r',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'ett r',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 r',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'om ngra sekunder',  'prefix');
        assert.equal(moment(0).from(30000), 'fr ngra sekunder sedan', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'fr ngra sekunder sedan',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'om ngra sekunder', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'om 5 dagar', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Idag 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Idag 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Idag 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Imorgon 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Idag 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Igr 02:00',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[P] dddd LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[P] dddd LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[P] dddd LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[I] dddd[s] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52a', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1a', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1a', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2a', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2a', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('ta');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a', ',  14 2010, 3:25:50  '],
                ['ddd, hA',                       ', 3 '],
                ['M Mo MM MMMM MMM',              '2 2 02  '],
                ['YYYY YY',                       '2010 10'],
                ['D Do DD',                       '14 14 14'],
                ['d do dddd ddd dd',              '0 0   '],
                ['DDD DDDo DDDD',                 '45 45 045'],
                ['w wo ww',                       '8 8 08'],
                ['h hh',                          '3 03'],
                ['H HH',                          '15 15'],
                ['m mm',                          '25 25'],
                ['s ss',                          '50 50'],
                ['a A',                           '   '],
                ['[] DDDo  []', ' 45  '],
                ['LTS',                           '15:25:50'],
                ['L',                             '14/02/2010'],
                ['LL',                            '14  2010'],
                ['LLL',                           '14  2010, 15:25'],
                ['LLLL',                          ', 14  2010, 15:25'],
                ['l',                             '14/2/2010'],
                ['ll',                            '14  2010'],
                ['lll',                           '14  2010, 15:25'],
                ['llll',                          ', 14  2010, 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '  ', '44  =   ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',      '45  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',      '89  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',     '90  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',    '44  = 44 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '  ',       '45  =   ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '  ',       '89  =   ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2  ',       '90  = 2  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5  ',       '5   = 5  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21  ',      '21   = 21  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',         '22   =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',         '35   =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',        '36   = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',         '1  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',        '5  = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',       '25  = 25 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',       '26  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',       '30  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  ' ',       '45  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',      '46  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',      '75  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',      '76  = 3 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',       '1  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',      '5  = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',        '345  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',       '548  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',        '1  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',       '5  = 5 ');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '   ',  'prefix');
        assert.equal(moment(0).from(30000), '   ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '   ',  '     ');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '   ', '   ');
        assert.equal(moment().add({d: 5}).fromNow(), '5  ', '5  ');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),  ' 02:00', '  02:00');
        assert.equal(moment(a).add({m: 25}).calendar(), ' 02:25', '  02:25');
        assert.equal(moment(a).add({h: 1}).calendar(), ' 03:00', '  03:00');
        assert.equal(moment(a).add({d: 1}).calendar(), ' 02:00', '  02:00');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  ' 01:00',      '  01:00');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  ' 02:00',  '  02:00');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd, LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[ ] dddd, LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[ ] dddd, LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[ ] dddd, LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 30]).format('a'), ' ', '(after) midnight');
        assert.equal(moment([2011, 2, 23,  2, 30]).format('a'), ' ', 'before dawn');
        assert.equal(moment([2011, 2, 23,  9, 30]).format('a'), ' ', 'morning');
        assert.equal(moment([2011, 2, 23, 14, 30]).format('a'), ' ', 'during day');
        assert.equal(moment([2011, 2, 23, 17, 30]).format('a'), ' ', 'evening');
        assert.equal(moment([2011, 2, 23, 19, 30]).format('a'), ' ', 'late evening');
        assert.equal(moment([2011, 2, 23, 23, 30]).format('a'), ' ', '(before) midnight');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('th');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, h:mm:ss a',      ', 14  2010, 3:25:50 '],
                ['ddd, h A',                           ', 3 '],
                ['M Mo MM MMMM MMM',                   '2 2 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   .'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15  25  50 '],
                ['L',                                  '2010/02/14'],
                ['LL',                                 '14  2010'],
                ['LLL',                                '14  2010  15  25 '],
                ['LLLL',                               ' 14  2010  15  25 '],
                ['l',                                  '2010/2/14'],
                ['ll',                                 '14  2010'],
                ['lll',                                '14  2010  15  25 '],
                ['llll',                               ' 14  2010  15  25 ']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  ._  ._  ._  ._  ._  ._  .'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 ', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 ', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 ', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 ', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 ',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 ',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 ',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 ', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 ', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 ', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 ', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 ',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 ',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), ' ',  'prefix');
        assert.equal(moment(0).from(30000), '', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), ' ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  2  0 ',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  2  25 ',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  3  0 ',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  2  0 ', 'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  1  0 ',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  2  0 ', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd[ ] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd[ ] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd[ ] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[]dddd[ ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[]dddd[ ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[]dddd[ ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('tl-ph');

    test('parse', function (assert) {
        var tests = 'Enero Ene_Pebrero Peb_Marso Mar_Abril Abr_Mayo May_Hunyo Hun_Hulyo Hul_Agosto Ago_Setyembre Set_Oktubre Okt_Nobyembre Nob_Disyembre Dis'.split('_'),
            i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Linggo, Pebrero 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Lin, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 Pebrero Peb'],
                ['YYYY YY',                             '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 Linggo Lin Li'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '02/14/2010'],
                ['LL',                                 'Pebrero 14, 2010'],
                ['LLL',                                'Pebrero 14, 2010 15:25'],
                ['LLLL',                               'Linggo, Pebrero 14, 2010 15:25'],
                ['l',                                  '2/14/2010'],
                ['ll',                                 'Peb 14, 2010'],
                ['lll',                                'Peb 14, 2010 15:25'],
                ['llll',                               'Lin, Peb 14, 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'Enero Ene_Pebrero Peb_Marso Mar_Abril Abr_Mayo May_Hunyo Hun_Hulyo Hul_Agosto Ago_Setyembre Set_Oktubre Okt_Nobyembre Nob_Disyembre Dis'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Linggo Lin Li_Lunes Lun Lu_Martes Mar Ma_Miyerkules Miy Mi_Huwebes Huw Hu_Biyernes Biy Bi_Sabado Sab Sab'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'ilang segundo', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'isang minuto',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'isang minuto',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minuto',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minuto', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'isang oras',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'isang oras',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 oras',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 oras',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 oras',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'isang araw',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'isang araw',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 araw',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'isang araw',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 araw',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 araw',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'isang buwan',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'isang buwan',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'isang buwan',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 buwan',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 buwan',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 buwan',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'isang buwan',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 buwan',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'isang taon',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 taon',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'isang taon',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 taon',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'sa loob ng ilang segundo', 'prefix');
        assert.equal(moment(0).from(30000), 'ilang segundo ang nakalipas', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'sa loob ng ilang segundo', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'sa loob ng 5 araw', 'in 5 days');
    });

    test('same day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Ngayon sa 02:00',    'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Ngayon sa 02:25',    'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Ngayon sa 03:00',    'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Bukas sa 02:00',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Ngayon sa 01:00',    'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Kahapon sa 02:00',   'yesterday at the same time');
    });

    test('same next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [sa] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('same last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [huling linggo] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('same all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'), '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('tr');

    test('parse', function (assert) {
        var tests = 'Ocak Oca_ubat ub_Mart Mar_Nisan Nis_Mays May_Haziran Haz_Temmuz Tem_Austos Au_Eyll Eyl_Ekim Eki_Kasm Kas_Aralk Ara'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'Pazar, ubat 14\'nc 2010, 3:25:50 pm'],
                ['ddd, hA',                            'Paz, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2\'nci 02 ubat ub'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14\'nc 14'],
                ['d do dddd ddd dd',                   '0 0\'nc Pazar Paz Pz'],
                ['DDD DDDo DDDD',                      '45 45\'inci 045'],
                ['w wo ww',                            '7 7\'nci 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[yln] DDDo [gn]',                'yln 45\'inci gn'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14 ubat 2010'],
                ['LLL',                                '14 ubat 2010 15:25'],
                ['LLLL',                               'Pazar, 14 ubat 2010 15:25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14 ub 2010'],
                ['lll',                                '14 ub 2010 15:25'],
                ['llll',                               'Paz, 14 ub 2010 15:25']
            ],
            DDDo = [
                [359, '360\'nc'],
                [199, '200\'nc'],
                [149, '150\'nci']
            ],
            dt = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            DDDoDt,
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(dt.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
        for (i = 0; i < DDDo.length; i++) {
            DDDoDt = moment([2010]);
            assert.equal(DDDoDt.add(DDDo[i][0], 'days').format('DDDo'), DDDo[i][1], DDDo[i][0] + ' ---> ' + DDDo[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1\'inci', '1st');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2\'nci', '2nd');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3\'nc', '3rd');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4\'nc', '4th');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5\'inci', '5th');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6\'nc', '6th');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7\'nci', '7th');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8\'inci', '8th');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9\'uncu', '9th');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10\'uncu', '10th');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11\'inci', '11th');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12\'nci', '12th');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13\'nc', '13th');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14\'nc', '14th');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15\'inci', '15th');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16\'nc', '16th');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17\'nci', '17th');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18\'inci', '18th');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19\'uncu', '19th');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20\'nci', '20th');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21\'inci', '21th');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22\'nci', '22th');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23\'nc', '23th');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24\'nc', '24th');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25\'inci', '25th');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26\'nc', '26th');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27\'nci', '27th');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28\'inci', '28th');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29\'uncu', '29th');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30\'uncu', '30th');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31\'inci', '31st');
    });

    test('format month', function (assert) {
        var expected = 'Ocak Oca_ubat ub_Mart Mar_Nisan Nis_Mays May_Haziran Haz_Temmuz Tem_Austos Au_Eyll Eyl_Ekim Eki_Kasm Kas_Aralk Ara'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Pazar Paz Pz_Pazartesi Pts Pt_Sal Sal Sa_aramba ar a_Perembe Per Pe_Cuma Cum Cu_Cumartesi Cts Ct'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'birka saniye', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'bir dakika',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'bir dakika',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 dakika',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 dakika',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'bir saat',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'bir saat',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 saat',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 saat',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 saat',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'bir gn',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'bir gn',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 gn',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'bir gn',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 gn',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 gn',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'bir ay',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'bir ay',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'bir ay',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ay',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ay',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ay',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'bir ay',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ay',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'bir yl',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 yl',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'bir yl',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 yl',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'birka saniye sonra',  'prefix');
        assert.equal(moment(0).from(30000), 'birka saniye nce', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'birka saniye nce',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'birka saniye sonra', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 gn sonra', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'bugn saat 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'bugn saat 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'bugn saat 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'yarn saat 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'bugn saat 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'dn 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[haftaya] dddd [saat] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[geen hafta] dddd [saat] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[geen hafta] dddd [saat] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[geen hafta] dddd [saat] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1\'inci', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1\'inci', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2\'nci', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2\'nci', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3\'nc', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('tzl');

    test('parse', function (assert) {
        var tests = 'Januar Jan_Fevraglh Fev_Mar Mar_Avru Avr_Mai Mai_Gn Gn_Julia Jul_Guscht Gus_Setemvar Set_Listopts Lis_Noemvar Noe_Zecemvar Zec'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h.mm.ss a',      'Sladi, Fevraglh 14. 2010, 3.25.50 d\'o'],
                ['ddd, hA',                            'Sl, 3D\'O'],
                ['M Mo MM MMMM MMM',                   '2 2. 02 Fevraglh Fev'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14. 14'],
                ['d do dddd ddd dd',                   '0 0. Sladi Sl S'],
                ['DDD DDDo DDDD',                      '45 45. 045'],
                ['w wo ww',                            '6 6. 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'd\'o D\'O'],
                ['[the] DDDo [day of the year]',       'the 45. day of the year'],
                ['LTS',                                '15.25.50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14. Fevraglh dallas 2010'],
                ['LLL',                                '14. Fevraglh dallas 2010 15.25'],
                ['LLLL',                               'Sladi, li 14. Fevraglh dallas 2010 15.25'],
                ['l',                                  '14.2.2010'],
                ['ll',                                 '14. Fev dallas 2010'],
                ['lll',                                '14. Fev dallas 2010 15.25'],
                ['llll',                               'Sl, li 14. Fev dallas 2010 15.25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1.', '1.');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2.', '2.');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3.', '3.');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4.', '4.');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5.', '5.');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6.', '6.');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7.', '7.');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8.', '8.');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9.', '9.');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10.', '10.');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11.', '11.');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12.', '12.');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13.', '13.');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14.', '14.');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15.', '15.');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16.', '16.');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17.', '17.');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18.', '18.');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19.', '19.');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20.', '20.');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21.', '21.');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22.', '22.');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23.', '23.');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24.', '24.');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25.', '25.');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26.', '26.');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27.', '27.');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28.', '28.');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29.', '29.');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30.', '30.');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31.', '31.');
    });

    test('format month', function (assert) {
        var expected = 'Januar Jan_Fevraglh Fev_Mar Mar_Avru Avr_Mai Mai_Gn Gn_Julia Jul_Guscht Gus_Setemvar Set_Listopts Lis_Noemvar Noe_Zecemvar Zec'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'Sladi Sl S_Lnei Ln L_Maitzi Mai Ma_Mrcuri Mr M_Xhadi Xh Xh_Vineri Vi Vi_Sturi St S'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'viensas secunds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '\'n mut',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '\'n mut',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 muts',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 muts',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '\'n ora',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '\'n ora',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 oras',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 oras',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 oras',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '\'n ziua',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '\'n ziua',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ziuas',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '\'n ziua',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ziuas',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ziuas',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '\'n mes',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '\'n mes',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '\'n mes',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 mesen',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 mesen',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 mesen',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '\'n mes',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 mesen',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '\'n ar',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ars',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '\'n ar',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ars',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'osprei viensas secunds',  'prefix');
        assert.equal(moment(0).from(30000), 'ja\'iensas secunds', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'ja\'iensas secunds',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'osprei viensas secunds', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'osprei 5 ziuas', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'oxhi  02.00',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'oxhi  02.25',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'oxhi  03.00',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'dem  02.00',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'oxhi  01.00',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'ieiri  02.00',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[sr el] dddd [lasteu ] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[sr el] dddd [lasteu ] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[sr el] dddd [lasteu ] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    // Monday is the first day of the week.
    // The week that contains Jan 4th is the first week of the year.

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52.', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1.', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1.', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2.', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2.', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('tzm-latn');

    test('parse', function (assert) {
        var tests = 'innayr innayr_brayr brayr_mars mars_ibrir ibrir_mayyw mayyw_ywnyw ywnyw_ywlywz ywlywz_wt wt_wtanbir wtanbir_ktwbr ktwbr_nwwanbir nwwanbir_dwjnbir dwjnbir'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'asamas, brayr 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'asamas, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 brayr brayr'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 asamas asamas asamas'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 brayr 2010'],
                ['LLL',                                '14 brayr 2010 15:25'],
                ['LLLL',                               'asamas 14 brayr 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 brayr 2010'],
                ['lll',                                '14 brayr 2010 15:25'],
                ['llll',                               'asamas 14 brayr 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = 'innayr innayr_brayr brayr_mars mars_ibrir ibrir_mayyw mayyw_ywnyw ywnyw_ywlywz ywlywz_wt wt_wtanbir wtanbir_ktwbr ktwbr_nwwanbir nwwanbir_dwjnbir dwjnbir'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = 'asamas asamas asamas_aynas aynas aynas_asinas asinas asinas_akras akras akras_akwas akwas akwas_asimwas asimwas asimwas_asiyas asiyas asiyas'.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'imik', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'minu',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'minu',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 minu',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 minu',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'saa',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'saa',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 tassain',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 tassain',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 tassain',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'ass',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'ass',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ossan',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'ass',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ossan',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ossan',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'ayowr',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'ayowr',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'ayowr',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 iyyirn',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 iyyirn',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 iyyirn',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'ayowr',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 iyyirn',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'asgas',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 isgasn',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'asgas',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 isgasn',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'dadkh s yan imik',  'prefix');
        assert.equal(moment(0).from(30000), 'yan imik', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'yan imik',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'dadkh s yan imik', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), 'dadkh s yan 5 ossan', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'asdkh g 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'asdkh g 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'asdkh g 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'aska g 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'asdkh g 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'assant g 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [g] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('tzm');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      ',  14 2010, 3:25:50 pm'],
                ['ddd, hA',                            ', 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[the] DDDo [day of the year]',       'the 45 day of the year'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14  2010'],
                ['LLL',                                '14  2010 15:25'],
                ['LLLL',                               ' 14  2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14  2010'],
                ['lll',                                '14  2010 15:25'],
                ['llll',                               ' 14  2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 o',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 o',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 o',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'o',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'o',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'o',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'o',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '   ',  'prefix');
        assert.equal(moment(0).from(30000), ' ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), ' ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '   ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '   5 o', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 31]).week(), 1, 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).week(), 1, 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).week(), 2, 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).week(), 2, 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).week(), 3, 'Jan 14 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 30]).week(), 1, 'Dec 30 2006 should be week 1');
        assert.equal(moment([2007,  0,  5]).week(), 1, 'Jan  5 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 2, 'Jan  6 2007 should be week 2');
        assert.equal(moment([2007,  0, 12]).week(), 2, 'Jan 12 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 3, 'Jan 13 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 1, 'Dec 29 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  4]).week(), 1, 'Jan  4 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 2, 'Jan  5 2008 should be week 2');
        assert.equal(moment([2008,  0, 11]).week(), 2, 'Jan 11 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 3, 'Jan 12 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 28]).week(), 1, 'Dec 28 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  3]).week(), 1, 'Jan  3 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 2, 'Jan  4 2003 should be week 2');
        assert.equal(moment([2003,  0, 10]).week(), 2, 'Jan 10 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 3, 'Jan 11 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 27]).week(), 1, 'Dec 27 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  2]).week(), 1, 'Jan  2 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 2, 'Jan  3 2009 should be week 2');
        assert.equal(moment([2009,  0,  9]).week(), 2, 'Jan  9 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 3, 'Jan 10 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 26]).week(), 1, 'Dec 26 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 2, 'Jan  2 2010 should be week 2');
        assert.equal(moment([2010,  0,  8]).week(), 2, 'Jan  8 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 3, 'Jan  9 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011, 0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011, 0,  7]).week(), 1, 'Jan  7 2011 should be week 1');
        assert.equal(moment([2011, 0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011, 0, 14]).week(), 2, 'Jan 14 2011 should be week 2');
        assert.equal(moment([2011, 0, 15]).week(), 3, 'Jan 15 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 31]).format('w ww wo'), '1 01 1', 'Dec 31 2011 should be week 1');
        assert.equal(moment([2012,  0,  6]).format('w ww wo'), '1 01 1', 'Jan  6 2012 should be week 1');
        assert.equal(moment([2012,  0,  7]).format('w ww wo'), '2 02 2', 'Jan  7 2012 should be week 2');
        assert.equal(moment([2012,  0, 13]).format('w ww wo'), '2 02 2', 'Jan 13 2012 should be week 2');
        assert.equal(moment([2012,  0, 14]).format('w ww wo'), '3 03 3', 'Jan 14 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('uk');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do MMMM YYYY, HH:mm:ss',       ', 14-  2010, 15:25:50'],
                ['ddd, h A',                           ', 3 '],
                ['M Mo MM MMMM MMM',                   '2 2- 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14- 14'],
                ['d do dddd ddd dd',                   '0 0-   '],
                ['DDD DDDo DDDD',                      '45 45- 045'],
                ['w wo ww',                            '7 7- 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['DDDo [ ]',                  '45-  '],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14.02.2010'],
                ['LL',                                 '14  2010 .'],
                ['LLL',                                '14  2010 ., 15:25'],
                ['LLLL',                               ', 14  2010 ., 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format meridiem', function (assert) {
        assert.equal(moment([2012, 11, 28, 0, 0]).format('A'), '', 'night');
        assert.equal(moment([2012, 11, 28, 3, 59]).format('A'), '', 'night');
        assert.equal(moment([2012, 11, 28, 4, 0]).format('A'), '', 'morning');
        assert.equal(moment([2012, 11, 28, 11, 59]).format('A'), '', 'morning');
        assert.equal(moment([2012, 11, 28, 12, 0]).format('A'), '', 'afternoon');
        assert.equal(moment([2012, 11, 28, 16, 59]).format('A'), '', 'afternoon');
        assert.equal(moment([2012, 11, 28, 17, 0]).format('A'), '', 'evening');
        assert.equal(moment([2012, 11, 28, 23, 59]).format('A'), '', 'evening');
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1-', '1-');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2-', '2-');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3-', '3-');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4-', '4-');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5-', '5-');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6-', '6-');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7-', '7-');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8-', '8-');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9-', '9-');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10-', '10-');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11-', '11-');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12-', '12-');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13-', '13-');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14-', '14-');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15-', '15-');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16-', '16-');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17-', '17-');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18-', '18-');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19-', '19-');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20-', '20-');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21-', '21-');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22-', '22-');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23-', '23-');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24-', '24-');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25-', '25-');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26-', '26-');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27-', '27-');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28-', '28-');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29-', '29-');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30-', '30-');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31-', '31-');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format month case', function (assert) {
        var months = {
            'nominative': '___________'.split('_'),
            'accusative': '___________'.split('_')
        }, i;
        for (i = 0; i < 12; i++) {
            assert.equal(moment([2011, i, 1]).format('D MMMM'), '1 ' + months.accusative[i], '1 ' + months.accusative[i]);
            assert.equal(moment([2011, i, 1]).format('MMMM'), months.nominative[i], '1 ' + months.nominative[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  ' ',    '44 seconds = seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '',   '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '',   '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '',    '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '',    '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',    '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',    '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',   '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',      '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',      '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',     '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',      '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',     '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 11}), true),  '11 ',     '11 days = 11 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 21}), true),  '21 ',     '21 days = 21 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',    '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '',    '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '',    '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '',    '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',   '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',   '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',   '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '',    '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',   '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',     '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',    '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',     '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',    '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ', 'prefix');
        assert.equal(moment(0).from(30000), '  ', 'suffix');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '  02:00',      'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  02:00',       'yesterday at the same time');
        // A special case for Ukrainian since 11 hours have different preposition
        assert.equal(moment(a).add({h: 9}).calendar(),  '  11:00',       'same day at 11 o\'clock');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd [' + (m.hours() === 11 ? '' : '') + '] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd [] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd [] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        function makeFormat(d) {
            switch (d.day()) {
            case 0:
            case 3:
            case 5:
            case 6:
                return '[] dddd [' + (d.hours() === 11 ? '' : '') + '] LT';
            case 1:
            case 2:
            case 4:
                return '[] dddd [' + (d.hours() === 11 ? '' : '') + '] LT';
            }
        }

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format(makeFormat(m)),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2011, 11, 26]).week(), 1, 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).week(), 2, 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).week(), 3, 'Jan  9 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 12]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 1');
        assert.equal(moment([2010,  0,  4]).week(), 2, 'Jan  4 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 2, 'Jan 10 2010 should be week 2');
        assert.equal(moment([2010,  0, 11]).week(), 3, 'Jan 11 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 1');
        assert.equal(moment([2011,  0,  3]).week(), 2, 'Jan  3 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 2, 'Jan  9 2011 should be week 2');
        assert.equal(moment([2011,  0, 10]).week(), 3, 'Jan 10 2011 should be week 3');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2011, 11, 26]).format('w ww wo'), '1 01 1-', 'Dec 26 2011 should be week 1');
        assert.equal(moment([2012,  0,  1]).format('w ww wo'), '1 01 1-', 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012,  0,  2]).format('w ww wo'), '2 02 2-', 'Jan  2 2012 should be week 2');
        assert.equal(moment([2012,  0,  8]).format('w ww wo'), '2 02 2-', 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012,  0,  9]).format('w ww wo'), '3 03 3-', 'Jan  9 2012 should be week 3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('uz');

    test('parse', function (assert) {
        var tests = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, Do-MMMM YYYY, h:mm:ss',        ', 14- 2010, 3:25:50'],
                ['ddd, h:mm',                          ', 3:25'],
                ['M Mo MM MMMM MMM',                   '2 2 02  '],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '7 7 07'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[] DDDo-[]',             ' 45-'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14  2010'],
                ['LLL',                                '14  2010 15:25'],
                ['LLLL',                               '14  2010,  15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14  2010'],
                ['lll',                                '14  2010 15:25'],
                ['llll',                               '14  2010,  15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;
        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var expected = ' _ _ _ _ _ _ _ _ _ _ _ '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;
        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '', '44  = ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  ' ',      '45  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  ' ',      '89  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',     '90  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ',    '44  = 44 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  ' ',       '45  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  ' ',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',       '90  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',       '5  = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ',      '21  = 21 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  ' ',         '22  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  ' ',         '35  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',        '36  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   ' ',         '1  = 1 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',        '5  = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',       '25  = 25 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  ' ',       '26  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  ' ',       '30  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  ' ',       '45  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',      '46  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',      '75  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',      '76  = 3 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   ' ',       '  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',      '5  = 5 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), ' ',        '345  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',       '548  = 2 ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   ' ',        '1  =  ');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',       '5  = 5 ');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '  ',  'prefix');
        assert.equal(moment(0).from(30000), '   ', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '   ',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '  ', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), ' 5  ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     '  02:00 ',      'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '  02:25 ',      'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '  03:00 ',      'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       ' 02:00 ',   'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '  01:00 ',      'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '  02:00 ',  'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [ ] LT []'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT []'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [ ] LT []'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[] dddd [ ] LT []'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[] dddd [ ] LT []'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[] dddd [ ] LT []'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 1, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  2, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  2, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  3, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 1, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 1, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  2, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  2, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  3, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 1, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 1, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  2, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  2, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  3, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '2 02 2', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '2 02 2', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '3 03 3', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '3 03 3', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('vi');

    test('parse', function (assert) {
        var i,
            tests = 'thng 1,Th01_thng 2,Th02_thng 3,Th03_thng 4,Th04_thng 5,Th05_thng 6,Th06_thng 7,Th07_thng 8,Th08_thng 9,Th09_thng 10,Th10_thng 11,Th11_thng 12,Th12'.split('_');

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + i);
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(',');
            equalTest(tests[i][0], '[thng] M', i);
            equalTest(tests[i][1], '[Th]M', i);
            equalTest(tests[i][0], '[thng] MM', i);
            equalTest(tests[i][1], '[Th]MM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), '[THNG] M', i);
            equalTest(tests[i][1].toLocaleLowerCase(), '[TH]M', i);
            equalTest(tests[i][0].toLocaleUpperCase(), '[THNG] MM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), '[TH]MM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, h:mm:ss a',      'ch nht, thng 2 14 2010, 3:25:50 pm'],
                ['ddd, hA',                            'CN, 3PM'],
                ['M Mo MM MMMM MMM',                   '2 2 02 thng 2 Th02'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0 ch nht CN CN'],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                'pm PM'],
                ['[ngy th] DDDo [ca nm]',          'ngy th 45 ca nm'],
                ['LTS',                                '15:25:50'],
                ['L',                                  '14/02/2010'],
                ['LL',                                 '14 thng 2 nm 2010'],
                ['LLL',                                '14 thng 2 nm 2010 15:25'],
                ['LLLL',                               'ch nht, 14 thng 2 nm 2010 15:25'],
                ['l',                                  '14/2/2010'],
                ['ll',                                 '14 Th02 2010'],
                ['lll',                                '14 Th02 2010 15:25'],
                ['llll',                               'CN, 14 Th02 2010 15:25']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format ordinal', function (assert) {
        assert.equal(moment([2011, 0, 1]).format('DDDo'), '1', '1');
        assert.equal(moment([2011, 0, 2]).format('DDDo'), '2', '2');
        assert.equal(moment([2011, 0, 3]).format('DDDo'), '3', '3');
        assert.equal(moment([2011, 0, 4]).format('DDDo'), '4', '4');
        assert.equal(moment([2011, 0, 5]).format('DDDo'), '5', '5');
        assert.equal(moment([2011, 0, 6]).format('DDDo'), '6', '6');
        assert.equal(moment([2011, 0, 7]).format('DDDo'), '7', '7');
        assert.equal(moment([2011, 0, 8]).format('DDDo'), '8', '8');
        assert.equal(moment([2011, 0, 9]).format('DDDo'), '9', '9');
        assert.equal(moment([2011, 0, 10]).format('DDDo'), '10', '10');

        assert.equal(moment([2011, 0, 11]).format('DDDo'), '11', '11');
        assert.equal(moment([2011, 0, 12]).format('DDDo'), '12', '12');
        assert.equal(moment([2011, 0, 13]).format('DDDo'), '13', '13');
        assert.equal(moment([2011, 0, 14]).format('DDDo'), '14', '14');
        assert.equal(moment([2011, 0, 15]).format('DDDo'), '15', '15');
        assert.equal(moment([2011, 0, 16]).format('DDDo'), '16', '16');
        assert.equal(moment([2011, 0, 17]).format('DDDo'), '17', '17');
        assert.equal(moment([2011, 0, 18]).format('DDDo'), '18', '18');
        assert.equal(moment([2011, 0, 19]).format('DDDo'), '19', '19');
        assert.equal(moment([2011, 0, 20]).format('DDDo'), '20', '20');

        assert.equal(moment([2011, 0, 21]).format('DDDo'), '21', '21');
        assert.equal(moment([2011, 0, 22]).format('DDDo'), '22', '22');
        assert.equal(moment([2011, 0, 23]).format('DDDo'), '23', '23');
        assert.equal(moment([2011, 0, 24]).format('DDDo'), '24', '24');
        assert.equal(moment([2011, 0, 25]).format('DDDo'), '25', '25');
        assert.equal(moment([2011, 0, 26]).format('DDDo'), '26', '26');
        assert.equal(moment([2011, 0, 27]).format('DDDo'), '27', '27');
        assert.equal(moment([2011, 0, 28]).format('DDDo'), '28', '28');
        assert.equal(moment([2011, 0, 29]).format('DDDo'), '29', '29');
        assert.equal(moment([2011, 0, 30]).format('DDDo'), '30', '30');

        assert.equal(moment([2011, 0, 31]).format('DDDo'), '31', '31');
    });

    test('format month', function (assert) {
        var i,
            expected = 'thng 1,Th01_thng 2,Th02_thng 3,Th03_thng 4,Th04_thng 5,Th05_thng 6,Th06_thng 7,Th07_thng 8,Th08_thng 9,Th09_thng 10,Th10_thng 11,Th11_thng 12,Th12'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM,MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var i,
            expected = 'ch nht CN CN_th hai T2 T2_th ba T3 T3_th t T4 T4_th nm T5 T5_th su T6 T6_th by T7 T7'.split('_');

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  'vi giy', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  'mt pht',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  'mt pht',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 pht',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 pht',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  'mt gi',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  'mt gi',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 gi',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 gi',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 gi',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  'mt ngy',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  'mt ngy',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ngy',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   'mt ngy',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ngy',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ngy',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  'mt thng',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  'mt thng',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  'mt thng',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 thng',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 thng',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 thng',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   'mt thng',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 thng',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), 'mt nm',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 nm',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   'mt nm',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 nm',       '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), 'vi giy ti',  'prefix');
        assert.equal(moment(0).from(30000), 'vi giy trc', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), 'vi giy trc',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), 'vi giy ti', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ngy ti', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                     'Hm nay lc 02:00',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Hm nay lc 02:25',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Hm nay lc 03:00',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Ngy mai lc 02:00',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Hm nay lc 01:00',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Hm qua lc 02:00', 'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('dddd [tun ti lc] LT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [tun ti lc] LT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [tun ti lc] LT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;

        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('dddd [tun ri lc] LT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('dddd [tun ri lc] LT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('dddd [tun ri lc] LT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),  '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0, 2]).week(),  1, 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0, 8]).week(),  1, 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0, 9]).week(),  2, 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 2, 'Jan 15 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).week(),  1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007, 0, 7]).week(),  1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007, 0, 8]).week(),  2, 'Jan  8 2007 should be week 2');
        assert.equal(moment([2007, 0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
        assert.equal(moment([2007, 0, 15]).week(), 3, 'Jan 15 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).week(), 1, 'Dec 31 2007 should be week 1');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0,  7]).week(), 2, 'Jan  7 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
        assert.equal(moment([2008,  0, 14]).week(), 3, 'Jan 14 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).week(), 1, 'Dec 30 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0,  6]).week(), 2, 'Jan  6 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
        assert.equal(moment([2003,  0, 13]).week(), 3, 'Jan 13 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).week(), 1, 'Dec 29 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0,  5]).week(), 2, 'Jan  5 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
        assert.equal(moment([2009,  0, 13]).week(), 3, 'Jan 12 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).week(), 53, 'Dec 28 2009 should be week 53');
        assert.equal(moment([2010,  0,  1]).week(), 53, 'Jan  1 2010 should be week 53');
        assert.equal(moment([2010,  0,  3]).week(), 53, 'Jan  3 2010 should be week 53');
        assert.equal(moment([2010,  0,  4]).week(),  1, 'Jan  4 2010 should be week 1');
        assert.equal(moment([2010,  0, 10]).week(),  1, 'Jan 10 2010 should be week 1');
        assert.equal(moment([2010,  0, 11]).week(),  2, 'Jan 11 2010 should be week 2');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).week(), 52, 'Dec 27 2010 should be week 52');
        assert.equal(moment([2011,  0,  1]).week(), 52, 'Jan  1 2011 should be week 52');
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  3]).week(),  1, 'Jan  3 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(),  1, 'Jan  9 2011 should be week 1');
        assert.equal(moment([2011,  0, 10]).week(),  2, 'Jan 10 2011 should be week 2');
    });

    test('weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).format('w ww wo'),   '1 01 1', 'Jan  2 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'),   '1 01 1', 'Jan  8 2012 should be week 1');
        assert.equal(moment([2012, 0,  9]).format('w ww wo'),   '2 02 2', 'Jan  9 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'),   '2 02 2', 'Jan 15 2012 should be week 2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('zh-cn');

    test('parse', function (assert) {
        var tests = ' 1_ 2_ 3_ 4_ 5_ 6_ 7_ 8_ 9_ 10_ 11_ 12'.split('_'), i;

        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }

        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, a h:mm:ss',      ',  14 2010,  3:25:50'],
                ['ddd, Ah',                            ', 3'],
                ['M Mo MM MMMM MMM',                   '2 2 02  2'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '6 6 06'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['[] DDDo',                    ' 45'],
                ['LTS',                                '32550'],
                ['L',                                  '2010-02-14'],
                ['LL',                                 '2010214'],
                ['LLL',                                '2010214325'],
                ['LLLL',                               '2010214325'],
                ['l',                                  '2010-02-14'],
                ['ll',                                 '2010214'],
                ['lll',                                '2010214325'],
                ['llll',                               '2010214325']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = ' 1_ 2_ 3_ 4_ 5_ 6_ 7_ 8_ 9_ 10_ 11_ 12'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '1 ', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '1 ', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2 ',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44 ', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '1 ', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '1 ', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2 ',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5 ',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21 ', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '1 ',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '1 ',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2 ',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '1 ',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5 ',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25 ',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '1 ', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '1 ', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '1 ', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2 ',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2 ',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3 ',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '1 ', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5 ',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '1 ',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2 ',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '1 ',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5 ',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '',  'prefix');
        assert.equal(moment(0).from(30000), '', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5 ', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   '2',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '225',   'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '3',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '2',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '1',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '2',     'yesterday at the same time');
    });

    test('calendar current week', function (assert) {
        var i, m,
            today = moment().startOf('day');

        for (i = 0; i < 7; i++) {
            m = moment().startOf('week').add({d: i});
            if (Math.abs(m.diff(today, 'days')) <= 1) {
                continue; // skip today, yesterday, tomorrow
            }
            assert.equal(m.calendar(),       m.format('[]ddd12'),  'Monday + ' + i + ' days current time');
        }
    });

    test('calendar next week', function (assert) {
        var i, m,
            today = moment().startOf('day');

        for (i = 7; i < 14; i++) {
            m = moment().startOf('week').add({d: i});
            if (Math.abs(m.diff(today, 'days')) >= 7) {
                continue;
            }
            if (Math.abs(m.diff(today, 'days')) <= 1) {
                continue; // skip today, yesterday, tomorrow
            }
            assert.equal(m.calendar(),  m.format('[]ddd12'), 'Today + ' + i + ' days beginning of day');
        }
        assert.equal(42, 42, 'at least one assert');
    });

    test('calendar last week', function (assert) {
        var i, m,
            today = moment().startOf('day');

        for (i = 1; i < 8; i++) {
            m = moment().startOf('week').subtract({d: i});
            if ((Math.abs(m.diff(today, 'days')) >= 7) || (Math.abs(m.diff(today, 'days')) <= 1)) {
                continue;
            }
            assert.equal(m.calendar(),  m.format('[]ddd12'),  'Monday - ' + i + ' days next week');
        }
        assert.equal(42, 42, 'at least one assert');
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('LL'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('LL'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('LL'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('LL'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), '', 'before dawn');
        assert.equal(moment([2011, 2, 23,  6, 0]).format('A'), '', 'morning');
        assert.equal(moment([2011, 2, 23,  9, 0]).format('A'), '', 'before noon');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), '', 'noon');
        assert.equal(moment([2011, 2, 23, 13, 0]).format('A'), '', 'afternoon');
        assert.equal(moment([2011, 2, 23, 18, 0]).format('A'), '', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 52, 'Jan  1 2012 should be week 52');
        assert.equal(moment([2012, 0,  2]).week(), 1, 'Jan  2 2012 should be week 52');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 52, 'Dec 31 2006 should be week 52');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 1, 'Jan  7 2007 should be week 1');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 2, 'Jan 14 2007 should be week 2');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 1, 'Jan  6 2008 should be week 1');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 2, 'Jan 13 2008 should be week 2');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 52, 'Dec 29 2002 should be week 52');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 1, 'Jan  5 2003 should be week 1');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 2, 'Jan 12 2003 should be week 2');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 1, 'Jan  4 2009 should be week 1');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 2, 'Jan 11 2009 should be week 2');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2010,  0,  2]).week(), 53, 'Jan  2 2010 should be week 53');
        assert.equal(moment([2010,  0, 10]).week(), 1, 'Jan 10 2010 should be week 1');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2011,  0,  2]).week(), 52, 'Jan  2 2011 should be week 52');
        assert.equal(moment([2011,  0,  8]).week(), 1, 'Jan  8 2011 should be week 1');
        assert.equal(moment([2011,  0,  9]).week(), 1, 'Jan  9 2011 should be week 1');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '52 52 52', 'Jan  1 2012 52');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012  1');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012  2');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    localeModule('zh-tw');

    test('parse', function (assert) {
        var tests = ' 1_ 2_ 3_ 4_ 5_ 6_ 7_ 8_ 9_ 10_ 11_ 12'.split('_'), i;
        function equalTest(input, mmm, i) {
            assert.equal(moment(input, mmm).month(), i, input + ' should be month ' + (i + 1));
        }
        for (i = 0; i < 12; i++) {
            tests[i] = tests[i].split(' ');
            equalTest(tests[i][0], 'MMM', i);
            equalTest(tests[i][1], 'MMM', i);
            equalTest(tests[i][0], 'MMMM', i);
            equalTest(tests[i][1], 'MMMM', i);
            equalTest(tests[i][0].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleLowerCase(), 'MMMM', i);
            equalTest(tests[i][0].toLocaleUpperCase(), 'MMMM', i);
            equalTest(tests[i][1].toLocaleUpperCase(), 'MMMM', i);
        }
    });

    test('format', function (assert) {
        var a = [
                ['dddd, MMMM Do YYYY, a h:mm:ss',      ',  14 2010,  3:25:50'],
                ['ddd, Ah',                            ', 3'],
                ['M Mo MM MMMM MMM',                   '2 2 02  2'],
                ['YYYY YY',                            '2010 10'],
                ['D Do DD',                            '14 14 14'],
                ['d do dddd ddd dd',                   '0 0   '],
                ['DDD DDDo DDDD',                      '45 45 045'],
                ['w wo ww',                            '8 8 08'],
                ['h hh',                               '3 03'],
                ['H HH',                               '15 15'],
                ['m mm',                               '25 25'],
                ['s ss',                               '50 50'],
                ['a A',                                ' '],
                ['[] DDDo',                    ' 45'],
                ['LTS',                                '32550'],
                ['L',                                  '2010214'],
                ['LL',                                 '2010214'],
                ['LLL',                                '2010214325'],
                ['LLLL',                               '2010214325'],
                ['l',                                  '2010214'],
                ['ll',                                 '2010214'],
                ['lll',                                '2010214325'],
                ['llll',                               '2010214325']
            ],
            b = moment(new Date(2010, 1, 14, 15, 25, 50, 125)),
            i;

        for (i = 0; i < a.length; i++) {
            assert.equal(b.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('format month', function (assert) {
        var expected = ' 1_ 2_ 3_ 4_ 5_ 6_ 7_ 8_ 9_ 10_ 11_ 12'.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, i, 1]).format('MMMM MMM'), expected[i], expected[i]);
        }
    });

    test('format week', function (assert) {
        var expected = '  _  _  _  _  _  _  '.split('_'), i;

        for (i = 0; i < expected.length; i++) {
            assert.equal(moment([2011, 0, 2 + i]).format('dddd ddd dd'), expected[i], expected[i]);
        }
    });

    test('from', function (assert) {
        var start = moment([2007, 1, 28]);
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44}), true),  '',   '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45}), true),  '', '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89}), true),  '', '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true),  '2',  '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44}), true),  '44', '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45}), true),  '', '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89}), true),  '', '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90}), true),  '2',  '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5}), true),   '5',  '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21}), true),  '21', '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22}), true),  '',   '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35}), true),  '',   '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36}), true),  '2',   '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1}), true),   '',   '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5}), true),   '5',   '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25}), true),  '25',  '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26}), true),  '', '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30}), true),  '', '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43}), true),  '', '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46}), true),  '2',  '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74}), true),  '2',  '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76}), true),  '3',  '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1}), true),   '', '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5}), true),   '5',  '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345}), true), '',   '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548}), true), '2',   '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1}), true),   '',   '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5}), true),   '5',   '5 years = 5 years');
    });

    test('suffix', function (assert) {
        assert.equal(moment(30000).from(0), '',  'prefix');
        assert.equal(moment(0).from(30000), '', 'suffix');
    });

    test('now from now', function (assert) {
        assert.equal(moment().fromNow(), '',  'now from now should display as in the past');
    });

    test('fromNow', function (assert) {
        assert.equal(moment().add({s: 30}).fromNow(), '', 'in a few seconds');
        assert.equal(moment().add({d: 5}).fromNow(), '5', 'in 5 days');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   '200',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      '225',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       '300',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       '200',     'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  '100',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  '200',     'yesterday at the same time');
    });

    test('calendar next week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().add({d: i});
            assert.equal(m.calendar(),       m.format('[]ddddLT'),  'Today + ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[]ddddLT'),  'Today + ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[]ddddLT'),  'Today + ' + i + ' days end of day');
        }
    });

    test('calendar last week', function (assert) {
        var i, m;
        for (i = 2; i < 7; i++) {
            m = moment().subtract({d: i});
            assert.equal(m.calendar(),       m.format('[]ddddLT'),  'Today - ' + i + ' days current time');
            m.hours(0).minutes(0).seconds(0).milliseconds(0);
            assert.equal(m.calendar(),       m.format('[]ddddLT'),  'Today - ' + i + ' days beginning of day');
            m.hours(23).minutes(59).seconds(59).milliseconds(999);
            assert.equal(m.calendar(),       m.format('[]ddddLT'),  'Today - ' + i + ' days end of day');
        }
    });

    test('calendar all else', function (assert) {
        var weeksAgo = moment().subtract({w: 1}),
            weeksFromNow = moment().add({w: 1});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '1 week ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 1 week');

        weeksAgo = moment().subtract({w: 2});
        weeksFromNow = moment().add({w: 2});

        assert.equal(weeksAgo.calendar(),       weeksAgo.format('L'),      '2 weeks ago');
        assert.equal(weeksFromNow.calendar(),   weeksFromNow.format('L'),  'in 2 weeks');
    });

    test('meridiem', function (assert) {
        assert.equal(moment([2011, 2, 23,  0, 0]).format('a'), '', 'morning');
        assert.equal(moment([2011, 2, 23,  9, 0]).format('a'), '', 'before noon');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('a'), '', 'noon');
        assert.equal(moment([2011, 2, 23, 13, 0]).format('a'), '', 'after noon');
        assert.equal(moment([2011, 2, 23, 18, 0]).format('a'), '', 'night');

        assert.equal(moment([2011, 2, 23,  0, 0]).format('A'), '', 'morning');
        assert.equal(moment([2011, 2, 23,  9, 0]).format('A'), '', 'before noon');
        assert.equal(moment([2011, 2, 23, 12, 0]).format('A'), '', 'noon');
        assert.equal(moment([2011, 2, 23, 13, 0]).format('A'), '', 'afternoon');
        assert.equal(moment([2011, 2, 23, 18, 0]).format('A'), '', 'night');
    });

    test('weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).week(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).week(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).week(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).week(), 3, 'Jan 15 2012 should be week 3');
    });

    test('weeks year starting monday', function (assert) {
        assert.equal(moment([2006, 11, 31]).week(), 1, 'Dec 31 2006 should be week 1');
        assert.equal(moment([2007,  0,  1]).week(), 1, 'Jan  1 2007 should be week 1');
        assert.equal(moment([2007,  0,  6]).week(), 1, 'Jan  6 2007 should be week 1');
        assert.equal(moment([2007,  0,  7]).week(), 2, 'Jan  7 2007 should be week 2');
        assert.equal(moment([2007,  0, 13]).week(), 2, 'Jan 13 2007 should be week 2');
        assert.equal(moment([2007,  0, 14]).week(), 3, 'Jan 14 2007 should be week 3');
    });

    test('weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 29]).week(), 52, 'Dec 29 2007 should be week 52');
        assert.equal(moment([2008,  0,  1]).week(), 1, 'Jan  1 2008 should be week 1');
        assert.equal(moment([2008,  0,  5]).week(), 1, 'Jan  5 2008 should be week 1');
        assert.equal(moment([2008,  0,  6]).week(), 2, 'Jan  6 2008 should be week 2');
        assert.equal(moment([2008,  0, 12]).week(), 2, 'Jan 12 2008 should be week 2');
        assert.equal(moment([2008,  0, 13]).week(), 3, 'Jan 13 2008 should be week 3');
    });

    test('weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 29]).week(), 1, 'Dec 29 2002 should be week 1');
        assert.equal(moment([2003,  0,  1]).week(), 1, 'Jan  1 2003 should be week 1');
        assert.equal(moment([2003,  0,  4]).week(), 1, 'Jan  4 2003 should be week 1');
        assert.equal(moment([2003,  0,  5]).week(), 2, 'Jan  5 2003 should be week 2');
        assert.equal(moment([2003,  0, 11]).week(), 2, 'Jan 11 2003 should be week 2');
        assert.equal(moment([2003,  0, 12]).week(), 3, 'Jan 12 2003 should be week 3');
    });

    test('weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 28]).week(), 1, 'Dec 28 2008 should be week 1');
        assert.equal(moment([2009,  0,  1]).week(), 1, 'Jan  1 2009 should be week 1');
        assert.equal(moment([2009,  0,  3]).week(), 1, 'Jan  3 2009 should be week 1');
        assert.equal(moment([2009,  0,  4]).week(), 2, 'Jan  4 2009 should be week 2');
        assert.equal(moment([2009,  0, 10]).week(), 2, 'Jan 10 2009 should be week 2');
        assert.equal(moment([2009,  0, 11]).week(), 3, 'Jan 11 2009 should be week 3');
    });

    test('weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 27]).week(), 1, 'Dec 27 2009 should be week 1');
        assert.equal(moment([2010,  0,  1]).week(), 1, 'Jan  1 2010 should be week 1');
        assert.equal(moment([2010,  0,  2]).week(), 1, 'Jan  2 2010 should be week 1');
        assert.equal(moment([2010,  0,  3]).week(), 2, 'Jan  3 2010 should be week 2');
        assert.equal(moment([2010,  0,  9]).week(), 2, 'Jan  9 2010 should be week 2');
        assert.equal(moment([2010,  0, 10]).week(), 3, 'Jan 10 2010 should be week 3');
    });

    test('weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 26]).week(), 1, 'Dec 26 2010 should be week 1');
        assert.equal(moment([2011,  0,  1]).week(), 1, 'Jan  1 2011 should be week 1');
        assert.equal(moment([2011,  0,  2]).week(), 2, 'Jan  2 2011 should be week 2');
        assert.equal(moment([2011,  0,  8]).week(), 2, 'Jan  8 2011 should be week 2');
        assert.equal(moment([2011,  0,  9]).week(), 3, 'Jan  9 2011 should be week 3');
    });

    test('weeks year starting sunday format', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('w ww wo'), '1 01 1', 'Jan  1 2012  1');
        assert.equal(moment([2012, 0,  7]).format('w ww wo'), '1 01 1', 'Jan  7 2012  1');
        assert.equal(moment([2012, 0,  8]).format('w ww wo'), '2 02 2', 'Jan  8 2012  2');
        assert.equal(moment([2012, 0, 14]).format('w ww wo'), '2 02 2', 'Jan 14 2012  2');
        assert.equal(moment([2012, 0, 15]).format('w ww wo'), '3 03 3', 'Jan 15 2012  3');
    });

    test('lenient ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing ' + i + ' date check');
        }
    });

    test('lenient ordinal parsing of number', function (assert) {
        var i, testMoment;
        for (i = 1; i <= 31; ++i) {
            testMoment = moment('2014 01 ' + i, 'YYYY MM Do');
            assert.equal(testMoment.year(), 2014,
                    'lenient ordinal parsing of number ' + i + ' year check');
            assert.equal(testMoment.month(), 0,
                    'lenient ordinal parsing of number ' + i + ' month check');
            assert.equal(testMoment.date(), i,
                    'lenient ordinal parsing of number ' + i + ' date check');
        }
    });

    test('meridiem invariant', function (assert) {
        var h, m, t1, t2;
        for (h = 0; h < 24; ++h) {
            for (m = 0; m < 60; m += 15) {
                t1 = moment.utc([2000, 0, 1, h, m]);
                t2 = moment(t1.format('A h:mm'), 'A h:mm');
                assert.equal(t2.format('HH:mm'), t1.format('HH:mm'),
                        'meridiem at ' + t1.format('HH:mm'));
            }
        }
    });

    test('strict ordinal parsing', function (assert) {
        var i, ordinalStr, testMoment;
        for (i = 1; i <= 31; ++i) {
            ordinalStr = moment([2014, 0, i]).format('YYYY MM Do');
            testMoment = moment(ordinalStr, 'YYYY MM Do', true);
            assert.ok(testMoment.isValid(), 'strict ordinal parsing ' + i);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('add and subtract');

    test('add short reverse args', function (assert) {
        var a = moment(), b, c, d;
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add({ms: 50}).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add({s: 1}).seconds(), 9, 'Add seconds');
        assert.equal(a.add({m: 1}).minutes(), 8, 'Add minutes');
        assert.equal(a.add({h: 1}).hours(), 7, 'Add hours');
        assert.equal(a.add({d: 1}).date(), 13, 'Add date');
        assert.equal(a.add({w: 1}).date(), 20, 'Add week');
        assert.equal(a.add({M: 1}).month(), 10, 'Add month');
        assert.equal(a.add({y: 1}).year(), 2012, 'Add year');
        assert.equal(a.add({Q: 1}).month(), 1, 'Add quarter');

        b = moment([2010, 0, 31]).add({M: 1});
        c = moment([2010, 1, 28]).subtract({M: 1});
        d = moment([2010, 1, 28]).subtract({Q: 1});

        assert.equal(b.month(), 1, 'add month, jan 31st to feb 28th');
        assert.equal(b.date(), 28, 'add month, jan 31st to feb 28th');
        assert.equal(c.month(), 0, 'subtract month, feb 28th to jan 28th');
        assert.equal(c.date(), 28, 'subtract month, feb 28th to jan 28th');
        assert.equal(d.month(), 10, 'subtract quarter, feb 28th 2010 to nov 28th 2009');
        assert.equal(d.date(), 28, 'subtract quarter, feb 28th 2010 to nov 28th 2009');
        assert.equal(d.year(), 2009, 'subtract quarter, feb 28th 2010 to nov 28th 2009');
    });

    test('add long reverse args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add({milliseconds: 50}).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add({seconds: 1}).seconds(), 9, 'Add seconds');
        assert.equal(a.add({minutes: 1}).minutes(), 8, 'Add minutes');
        assert.equal(a.add({hours: 1}).hours(), 7, 'Add hours');
        assert.equal(a.add({days: 1}).date(), 13, 'Add date');
        assert.equal(a.add({weeks: 1}).date(), 20, 'Add week');
        assert.equal(a.add({months: 1}).month(), 10, 'Add month');
        assert.equal(a.add({years: 1}).year(), 2012, 'Add year');
        assert.equal(a.add({quarters: 1}).month(), 1, 'Add quarter');
    });

    test('add long singular reverse args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add({millisecond: 50}).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add({second: 1}).seconds(), 9, 'Add seconds');
        assert.equal(a.add({minute: 1}).minutes(), 8, 'Add minutes');
        assert.equal(a.add({hour: 1}).hours(), 7, 'Add hours');
        assert.equal(a.add({day: 1}).date(), 13, 'Add date');
        assert.equal(a.add({week: 1}).date(), 20, 'Add week');
        assert.equal(a.add({month: 1}).month(), 10, 'Add month');
        assert.equal(a.add({year: 1}).year(), 2012, 'Add year');
        assert.equal(a.add({quarter: 1}).month(), 1, 'Add quarter');
    });

    test('add string long reverse args', function (assert) {
        var a = moment(), b;
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        b = a.clone();

        assert.equal(a.add('millisecond', 50).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('second', 1).seconds(), 9, 'Add seconds');
        assert.equal(a.add('minute', 1).minutes(), 8, 'Add minutes');
        assert.equal(a.add('hour', 1).hours(), 7, 'Add hours');
        assert.equal(a.add('day', 1).date(), 13, 'Add date');
        assert.equal(a.add('week', 1).date(), 20, 'Add week');
        assert.equal(a.add('month', 1).month(), 10, 'Add month');
        assert.equal(a.add('year', 1).year(), 2012, 'Add year');
        assert.equal(b.add('day', '01').date(), 13, 'Add date');
        assert.equal(a.add('quarter', 1).month(), 1, 'Add quarter');
    });

    test('add string long singular reverse args', function (assert) {
        var a = moment(), b;
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        b = a.clone();

        assert.equal(a.add('milliseconds', 50).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('seconds', 1).seconds(), 9, 'Add seconds');
        assert.equal(a.add('minutes', 1).minutes(), 8, 'Add minutes');
        assert.equal(a.add('hours', 1).hours(), 7, 'Add hours');
        assert.equal(a.add('days', 1).date(), 13, 'Add date');
        assert.equal(a.add('weeks', 1).date(), 20, 'Add week');
        assert.equal(a.add('months', 1).month(), 10, 'Add month');
        assert.equal(a.add('years', 1).year(), 2012, 'Add year');
        assert.equal(b.add('days', '01').date(), 13, 'Add date');
        assert.equal(a.add('quarters', 1).month(), 1, 'Add quarter');
    });

    test('add string short reverse args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add('ms', 50).milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('s', 1).seconds(), 9, 'Add seconds');
        assert.equal(a.add('m', 1).minutes(), 8, 'Add minutes');
        assert.equal(a.add('h', 1).hours(), 7, 'Add hours');
        assert.equal(a.add('d', 1).date(), 13, 'Add date');
        assert.equal(a.add('w', 1).date(), 20, 'Add week');
        assert.equal(a.add('M', 1).month(), 10, 'Add month');
        assert.equal(a.add('y', 1).year(), 2012, 'Add year');
        assert.equal(a.add('Q', 1).month(), 1, 'Add quarter');
    });

    test('add string long', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add(50, 'millisecond').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add(1, 'second').seconds(), 9, 'Add seconds');
        assert.equal(a.add(1, 'minute').minutes(), 8, 'Add minutes');
        assert.equal(a.add(1, 'hour').hours(), 7, 'Add hours');
        assert.equal(a.add(1, 'day').date(), 13, 'Add date');
        assert.equal(a.add(1, 'week').date(), 20, 'Add week');
        assert.equal(a.add(1, 'month').month(), 10, 'Add month');
        assert.equal(a.add(1, 'year').year(), 2012, 'Add year');
        assert.equal(a.add(1, 'quarter').month(), 1, 'Add quarter');
    });

    test('add string long singular', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add(50, 'milliseconds').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add(1, 'seconds').seconds(), 9, 'Add seconds');
        assert.equal(a.add(1, 'minutes').minutes(), 8, 'Add minutes');
        assert.equal(a.add(1, 'hours').hours(), 7, 'Add hours');
        assert.equal(a.add(1, 'days').date(), 13, 'Add date');
        assert.equal(a.add(1, 'weeks').date(), 20, 'Add week');
        assert.equal(a.add(1, 'months').month(), 10, 'Add month');
        assert.equal(a.add(1, 'years').year(), 2012, 'Add year');
        assert.equal(a.add(1, 'quarters').month(), 1, 'Add quarter');
    });

    test('add string short', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add(50, 'ms').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add(1, 's').seconds(), 9, 'Add seconds');
        assert.equal(a.add(1, 'm').minutes(), 8, 'Add minutes');
        assert.equal(a.add(1, 'h').hours(), 7, 'Add hours');
        assert.equal(a.add(1, 'd').date(), 13, 'Add date');
        assert.equal(a.add(1, 'w').date(), 20, 'Add week');
        assert.equal(a.add(1, 'M').month(), 10, 'Add month');
        assert.equal(a.add(1, 'y').year(), 2012, 'Add year');
        assert.equal(a.add(1, 'Q').month(), 1, 'Add quarter');
    });

    test('add strings string short args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add('ms', '50').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('s', '1').seconds(), 9, 'Add seconds');
        assert.equal(a.add('m', '1').minutes(), 8, 'Add minutes');
        assert.equal(a.add('h', '1').hours(), 7, 'Add hours');
        assert.equal(a.add('d', '1').date(), 13, 'Add date');
        assert.equal(a.add('w', '1').date(), 20, 'Add week');
        assert.equal(a.add('M', '1').month(), 10, 'Add month');
        assert.equal(a.add('y', '1').year(), 2012, 'Add year');
        assert.equal(a.add('Q', '1').month(), 1, 'Add quarter');
    });

    test('subtract strings string short args', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.subtract('ms', '50').milliseconds(), 450, 'Subtract milliseconds');
        assert.equal(a.subtract('s', '1').seconds(), 7, 'Subtract seconds');
        assert.equal(a.subtract('m', '1').minutes(), 6, 'Subtract minutes');
        assert.equal(a.subtract('h', '1').hours(), 5, 'Subtract hours');
        assert.equal(a.subtract('d', '1').date(), 11, 'Subtract date');
        assert.equal(a.subtract('w', '1').date(), 4, 'Subtract week');
        assert.equal(a.subtract('M', '1').month(), 8, 'Subtract month');
        assert.equal(a.subtract('y', '1').year(), 2010, 'Subtract year');
        assert.equal(a.subtract('Q', '1').month(), 5, 'Subtract quarter');
    });

    test('add strings string short', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.add('50', 'ms').milliseconds(), 550, 'Add milliseconds');
        assert.equal(a.add('1', 's').seconds(), 9, 'Add seconds');
        assert.equal(a.add('1', 'm').minutes(), 8, 'Add minutes');
        assert.equal(a.add('1', 'h').hours(), 7, 'Add hours');
        assert.equal(a.add('1', 'd').date(), 13, 'Add date');
        assert.equal(a.add('1', 'w').date(), 20, 'Add week');
        assert.equal(a.add('1', 'M').month(), 10, 'Add month');
        assert.equal(a.add('1', 'y').year(), 2012, 'Add year');
        assert.equal(a.add('1', 'Q').month(), 1, 'Add quarter');
    });

    test('subtract strings string short', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(500);

        assert.equal(a.subtract('50', 'ms').milliseconds(), 450, 'Subtract milliseconds');
        assert.equal(a.subtract('1', 's').seconds(), 7, 'Subtract seconds');
        assert.equal(a.subtract('1', 'm').minutes(), 6, 'Subtract minutes');
        assert.equal(a.subtract('1', 'h').hours(), 5, 'Subtract hours');
        assert.equal(a.subtract('1', 'd').date(), 11, 'Subtract date');
        assert.equal(a.subtract('1', 'w').date(), 4, 'Subtract week');
        assert.equal(a.subtract('1', 'M').month(), 8, 'Subtract month');
        assert.equal(a.subtract('1', 'y').year(), 2010, 'Subtract year');
        assert.equal(a.subtract('1', 'Q').month(), 5, 'Subtract quarter');
    });

    test('add across DST', function (assert) {
        // Detect Safari bug and bail. Hours on 13th March 2011 are shifted
        // with 1 ahead.
        if (new Date(2011, 2, 13, 5, 0, 0).getHours() !== 5) {
            assert.expect(0);
            return;
        }

        var a = moment(new Date(2011, 2, 12, 5, 0, 0)),
            b = moment(new Date(2011, 2, 12, 5, 0, 0)),
            c = moment(new Date(2011, 2, 12, 5, 0, 0)),
            d = moment(new Date(2011, 2, 12, 5, 0, 0)),
            e = moment(new Date(2011, 2, 12, 5, 0, 0));
        a.add(1, 'days');
        b.add(24, 'hours');
        c.add(1, 'months');
        e.add(1, 'quarter');

        assert.equal(a.hours(), 5, 'adding days over DST difference should result in the same hour');
        if (b.isDST() && !d.isDST()) {
            assert.equal(b.hours(), 6, 'adding hours over DST difference should result in a different hour');
        } else if (!b.isDST() && d.isDST()) {
            assert.equal(b.hours(), 4, 'adding hours over DST difference should result in a different hour');
        } else {
            assert.equal(b.hours(), 5, 'adding hours over DST difference should result in a same hour if the timezone does not have daylight savings time');
        }
        assert.equal(c.hours(), 5, 'adding months over DST difference should result in the same hour');
        assert.equal(e.hours(), 5, 'adding quarters over DST difference should result in the same hour');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('create');

    test('array', function (assert) {
        assert.ok(moment([2010]).toDate() instanceof Date, '[2010]');
        assert.ok(moment([2010, 1]).toDate() instanceof Date, '[2010, 1]');
        assert.ok(moment([2010, 1, 12]).toDate() instanceof Date, '[2010, 1, 12]');
        assert.ok(moment([2010, 1, 12, 1]).toDate() instanceof Date, '[2010, 1, 12, 1]');
        assert.ok(moment([2010, 1, 12, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1]');
        assert.ok(moment([2010, 1, 12, 1, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1, 1]');
        assert.ok(moment([2010, 1, 12, 1, 1, 1, 1]).toDate() instanceof Date, '[2010, 1, 12, 1, 1, 1, 1]');
        assert.equal(+moment(new Date(2010, 1, 14, 15, 25, 50, 125)), +moment([2010, 1, 14, 15, 25, 50, 125]), 'constructing with array === constructing with new Date()');
    });

    test('array copying', function (assert) {
        var importantArray = [2009, 11];
        moment(importantArray);
        assert.deepEqual(importantArray, [2009, 11], 'initializer should not mutate the original array');
    });

    test('object', function (assert) {
        var fmt = 'YYYY-MM-DD HH:mm:ss.SSS',
            tests = [
                [{year: 2010}, '2010-01-01 00:00:00.000'],
                [{year: 2010, month: 1}, '2010-02-01 00:00:00.000'],
                [{year: 2010, month: 1, day: 12}, '2010-02-12 00:00:00.000'],
                [{year: 2010, month: 1, date: 12}, '2010-02-12 00:00:00.000'],
                [{year: 2010, month: 1, day: 12, hours: 1}, '2010-02-12 01:00:00.000'],
                [{year: 2010, month: 1, date: 12, hours: 1}, '2010-02-12 01:00:00.000'],
                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1}, '2010-02-12 01:01:00.000'],
                [{year: 2010, month: 1, date: 12, hours: 1, minutes: 1}, '2010-02-12 01:01:00.000'],
                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1, seconds: 1}, '2010-02-12 01:01:01.000'],
                [{year: 2010, month: 1, day: 12, hours: 1, minutes: 1, seconds: 1, milliseconds: 1}, '2010-02-12 01:01:01.001'],
                [{years: 2010, months: 1, days: 14, hours: 15, minutes: 25, seconds: 50, milliseconds: 125}, '2010-02-14 15:25:50.125'],
                [{year: 2010, month: 1, day: 14, hour: 15, minute: 25, second: 50, millisecond: 125}, '2010-02-14 15:25:50.125'],
                [{y: 2010, M: 1, d: 14, h: 15, m: 25, s: 50, ms: 125}, '2010-02-14 15:25:50.125']
            ], i;
        for (i = 0; i < tests.length; ++i) {
            assert.equal(moment(tests[i][0]).format(fmt), tests[i][1]);
        }
    });

    test('multi format array copying', function (assert) {
        var importantArray = ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY'];
        moment('1999-02-13', importantArray);
        assert.deepEqual(importantArray, ['MM/DD/YYYY', 'YYYY-MM-DD', 'MM-DD-YYYY'], 'initializer should not mutate the original array');
    });

    test('number', function (assert) {
        assert.ok(moment(1000).toDate() instanceof Date, '1000');
        assert.equal(moment(1000).valueOf(), 1000, 'asserting valueOf');
        assert.equal(moment.utc(1000).valueOf(), 1000, 'asserting valueOf');
    });

    test('unix', function (assert) {
        assert.equal(moment.unix(1).valueOf(), 1000, '1 unix timestamp == 1000 Date.valueOf');
        assert.equal(moment(1000).unix(), 1, '1000 Date.valueOf == 1 unix timestamp');
        assert.equal(moment.unix(1000).valueOf(), 1000000, '1000 unix timestamp == 1000000 Date.valueOf');
        assert.equal(moment(1500).unix(), 1, '1500 Date.valueOf == 1 unix timestamp');
        assert.equal(moment(1900).unix(), 1, '1900 Date.valueOf == 1 unix timestamp');
        assert.equal(moment(2100).unix(), 2, '2100 Date.valueOf == 2 unix timestamp');
        assert.equal(moment(1333129333524).unix(), 1333129333, '1333129333524 Date.valueOf == 1333129333 unix timestamp');
        assert.equal(moment(1333129333524000).unix(), 1333129333524, '1333129333524000 Date.valueOf == 1333129333524 unix timestamp');
    });

    test('date', function (assert) {
        assert.ok(moment(new Date()).toDate() instanceof Date, 'new Date()');
    });

    test('date mutation', function (assert) {
        var a = new Date();
        assert.ok(moment(a).toDate() !== a, 'the date moment uses should not be the date passed in');
    });

    test('moment', function (assert) {
        assert.ok(moment(moment()).toDate() instanceof Date, 'moment(moment())');
        assert.ok(moment(moment(moment())).toDate() instanceof Date, 'moment(moment(moment()))');
    });

    test('cloning moment should only copy own properties', function (assert) {
        assert.ok(!moment().clone().hasOwnProperty('month'), 'Should not clone prototype methods');
    });

    test('cloning moment works with weird clones', function (assert) {
        var extend = function (a, b) {
            var i;
            for (i in b) {
                a[i] = b[i];
            }
            return a;
        },
        now = moment(),
        nowu = moment.utc();

        assert.equal(+extend({}, now).clone(), +now, 'cloning extend-ed now is now');
        assert.equal(+extend({}, nowu).clone(), +nowu, 'cloning extend-ed utc now is utc now');
    });

    test('cloning respects moment.momentProperties', function (assert) {
        var m = moment();

        assert.equal(m.clone()._special, undefined, 'cloning ignores extra properties');
        m._special = 'bacon';
        moment.momentProperties.push('_special');
        assert.equal(m.clone()._special, 'bacon', 'cloning respects momentProperties');
        moment.momentProperties.pop();
    });

    test('undefined', function (assert) {
        assert.ok(moment().toDate() instanceof Date, 'undefined');
    });

    test('iso with bad input', function (assert) {
        assert.ok(!moment('a', moment.ISO_8601).isValid(), 'iso parsing with invalid string');
        assert.ok(!moment('a', moment.ISO_8601, true).isValid(), 'iso parsing with invalid string, strict');
    });

    test('iso format 24hrs', function (assert) {
        assert.equal(moment('2014-01-01T24:00:00.000').format('YYYY-MM-DD[T]HH:mm:ss.SSS'),
                '2014-01-02T00:00:00.000', 'iso format with 24:00 localtime');
        assert.equal(moment.utc('2014-01-01T24:00:00.000').format('YYYY-MM-DD[T]HH:mm:ss.SSS'),
                '2014-01-02T00:00:00.000', 'iso format with 24:00 utc');
    });

    test('string without format - json', function (assert) {
        assert.equal(moment('Date(1325132654000)').valueOf(), 1325132654000, 'Date(1325132654000)');
        assert.equal(moment('Date(-1325132654000)').valueOf(), -1325132654000, 'Date(-1325132654000)');
        assert.equal(moment('/Date(1325132654000)/').valueOf(), 1325132654000, '/Date(1325132654000)/');
        assert.equal(moment('/Date(1325132654000+0700)/').valueOf(), 1325132654000, '/Date(1325132654000+0700)/');
        assert.equal(moment('/Date(1325132654000-0700)/').valueOf(), 1325132654000, '/Date(1325132654000-0700)/');
    });

    test('string with format dropped am/pm bug', function (assert) {
        moment.locale('en');

        assert.equal(moment('05/1/2012 12:25:00', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');
        assert.equal(moment('05/1/2012 12:25:00 am', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');
        assert.equal(moment('05/1/2012 12:25:00 pm', 'MM/DD/YYYY h:m:s a').format('MM/DD/YYYY'), '05/01/2012', 'should not break if am/pm is left off from the parsing tokens');

        assert.ok(moment('05/1/2012 12:25:00', 'MM/DD/YYYY h:m:s a').isValid());
        assert.ok(moment('05/1/2012 12:25:00 am', 'MM/DD/YYYY h:m:s a').isValid());
        assert.ok(moment('05/1/2012 12:25:00 pm', 'MM/DD/YYYY h:m:s a').isValid());
    });

    test('empty string with formats', function (assert) {
        assert.equal(moment('', 'MM').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');
        assert.equal(moment(' ', 'MM').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');
        assert.equal(moment(' ', 'DD').format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');
        assert.equal(moment(' ', ['MM', 'DD']).format('YYYY-MM-DD HH:mm:ss'), 'Invalid date');

        assert.ok(!moment('', 'MM').isValid());
        assert.ok(!moment(' ', 'MM').isValid());
        assert.ok(!moment(' ', 'DD').isValid());
        assert.ok(!moment(' ', ['MM', 'DD']).isValid());
    });

    test('defaulting to current date', function (assert) {
        var now = moment();
        assert.equal(moment('12:13:14', 'hh:mm:ss').format('YYYY-MM-DD hh:mm:ss'),
                     now.clone().hour(12).minute(13).second(14).format('YYYY-MM-DD hh:mm:ss'),
                     'given only time default to current date');
        assert.equal(moment('05', 'DD').format('YYYY-MM-DD'),
                     now.clone().date(5).format('YYYY-MM-DD'),
                     'given day of month default to current month, year');
        assert.equal(moment('05', 'MM').format('YYYY-MM-DD'),
                     now.clone().month(4).date(1).format('YYYY-MM-DD'),
                     'given month default to current year');
        assert.equal(moment('1996', 'YYYY').format('YYYY-MM-DD'),
                     now.clone().year(1996).month(0).date(1).format('YYYY-MM-DD'),
                     'given year do not default');
    });

    test('matching am/pm', function (assert) {
        assert.equal(moment('2012-09-03T03:00PM',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for PM');
        assert.equal(moment('2012-09-03T03:00P.M.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for P.M.');
        assert.equal(moment('2012-09-03T03:00P',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for P');
        assert.equal(moment('2012-09-03T03:00pm',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for pm');
        assert.equal(moment('2012-09-03T03:00p.m.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for p.m.');
        assert.equal(moment('2012-09-03T03:00p',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00PM', 'am/pm should parse correctly for p');

        assert.equal(moment('2012-09-03T03:00AM',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for AM');
        assert.equal(moment('2012-09-03T03:00A.M.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for A.M.');
        assert.equal(moment('2012-09-03T03:00A',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for A');
        assert.equal(moment('2012-09-03T03:00am',   'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for am');
        assert.equal(moment('2012-09-03T03:00a.m.', 'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for a.m.');
        assert.equal(moment('2012-09-03T03:00a',    'YYYY-MM-DDThh:mmA').format('YYYY-MM-DDThh:mmA'), '2012-09-03T03:00AM', 'am/pm should parse correctly for a');

        assert.equal(moment('5:00p.m.March 4 2012', 'h:mmAMMMM D YYYY').format('YYYY-MM-DDThh:mmA'), '2012-03-04T05:00PM', 'am/pm should parse correctly before month names');
    });

    test('string with format', function (assert) {
        moment.locale('en');
        var a = [
            ['YYYY-Q',              '2014-4'],
            ['MM-DD-YYYY',          '12-02-1999'],
            ['DD-MM-YYYY',          '12-02-1999'],
            ['DD/MM/YYYY',          '12/02/1999'],
            ['DD_MM_YYYY',          '12_02_1999'],
            ['DD:MM:YYYY',          '12:02:1999'],
            ['D-M-YY',              '2-2-99'],
            ['YY',                  '99'],
            ['DDD-YYYY',            '300-1999'],
            ['DD-MM-YYYY h:m:s',    '12-02-1999 2:45:10'],
            ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 am'],
            ['DD-MM-YYYY h:m:s a',  '12-02-1999 2:45:10 pm'],
            ['h:mm a',              '12:00 pm'],
            ['h:mm a',              '12:30 pm'],
            ['h:mm a',              '12:00 am'],
            ['h:mm a',              '12:30 am'],
            ['HH:mm',               '12:00'],
            ['YYYY-MM-DDTHH:mm:ss', '2011-11-11T11:11:11'],
            ['MM-DD-YYYY [M]',      '12-02-1999 M'],
            ['ddd MMM DD HH:mm:ss YYYY', 'Tue Apr 07 22:52:51 2009'],
            ['HH:mm:ss',            '12:00:00'],
            ['HH:mm:ss',            '12:30:00'],
            ['HH:mm:ss',            '00:00:00'],
            ['HH:mm:ss S',          '00:30:00 1'],
            ['HH:mm:ss SS',         '00:30:00 12'],
            ['HH:mm:ss SSS',        '00:30:00 123'],
            ['HH:mm:ss S',          '00:30:00 7'],
            ['HH:mm:ss SS',         '00:30:00 78'],
            ['HH:mm:ss SSS',        '00:30:00 789'],
            ['X',                   '1234567890'],
            ['x',                   '1234567890123'],
            ['LT',                  '12:30 AM'],
            ['LTS',                 '12:30:29 AM'],
            ['L',                   '09/02/1999'],
            ['l',                   '9/2/1999'],
            ['LL',                  'September 2, 1999'],
            ['ll',                  'Sep 2, 1999'],
            ['LLL',                 'September 2, 1999 12:30 AM'],
            ['lll',                 'Sep 2, 1999 12:30 AM'],
            ['LLLL',                'Thursday, September 2, 1999 12:30 AM'],
            ['llll',                'Thu, Sep 2, 1999 12:30 AM']
        ],
        m,
        i;

        for (i = 0; i < a.length; i++) {
            m = moment(a[i][1], a[i][0]);
            assert.ok(m.isValid());
            assert.equal(m.format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('2 digit year with YYYY format', function (assert) {
        assert.equal(moment('9/2/99', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/1999', 'D/M/YYYY ---> 9/2/99');
        assert.equal(moment('9/2/1999', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/1999', 'D/M/YYYY ---> 9/2/1999');
        assert.equal(moment('9/2/68', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/2068', 'D/M/YYYY ---> 9/2/68');
        assert.equal(moment('9/2/69', 'D/M/YYYY').format('DD/MM/YYYY'), '09/02/1969', 'D/M/YYYY ---> 9/2/69');
    });

    test('unix timestamp format', function (assert) {
        var formats = ['X', 'X.S', 'X.SS', 'X.SSS'], i, format;

        for (i = 0; i < formats.length; i++) {
            format = formats[i];
            assert.equal(moment('1234567890',     format).valueOf(), 1234567890 * 1000,       format + ' matches timestamp without milliseconds');
            assert.equal(moment('1234567890.1',   format).valueOf(), 1234567890 * 1000 + 100, format + ' matches timestamp with deciseconds');
            assert.equal(moment('1234567890.12',  format).valueOf(), 1234567890 * 1000 + 120, format + ' matches timestamp with centiseconds');
            assert.equal(moment('1234567890.123', format).valueOf(), 1234567890 * 1000 + 123, format + ' matches timestamp with milliseconds');
        }
    });

    test('unix offset milliseconds', function (assert) {
        assert.equal(moment('1234567890123', 'x').valueOf(), 1234567890123, 'x matches unix offset in milliseconds');
    });

    test('milliseconds format', function (assert) {
        assert.equal(moment('1', 'S').get('ms'), 100, 'deciseconds');
        // assert.equal(moment('10', 'S', true).isValid(), false, 'deciseconds with two digits');
        // assert.equal(moment('1', 'SS', true).isValid(), false, 'centiseconds with one digits');
        assert.equal(moment('12', 'SS').get('ms'), 120, 'centiseconds');
        // assert.equal(moment('123', 'SS', true).isValid(), false, 'centiseconds with three digits');
        assert.equal(moment('123', 'SSS').get('ms'), 123, 'milliseconds');
        assert.equal(moment('1234', 'SSSS').get('ms'), 123, 'milliseconds with SSSS');
        assert.equal(moment('123456789101112', 'SSSS').get('ms'), 123, 'milliseconds with SSSS');
    });

    test('string with format no separators', function (assert) {
        moment.locale('en');
        var a = [
            ['MMDDYYYY',          '12021999'],
            ['DDMMYYYY',          '12021999'],
            ['YYYYMMDD',          '19991202'],
            ['DDMMMYYYY',         '10Sep2001']
        ], i;

        for (i = 0; i < a.length; i++) {
            assert.equal(moment(a[i][1], a[i][0]).format(a[i][0]), a[i][1], a[i][0] + ' ---> ' + a[i][1]);
        }
    });

    test('string with format (timezone)', function (assert) {
        assert.equal(moment('5 -0700', 'H ZZ').toDate().getUTCHours(), 12, 'parse hours \'5 -0700\' ---> \'H ZZ\'');
        assert.equal(moment('5 -07:00', 'H Z').toDate().getUTCHours(), 12, 'parse hours \'5 -07:00\' ---> \'H Z\'');
        assert.equal(moment('5 -0730', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \'5 -0730\' ---> \'H ZZ\'');
        assert.equal(moment('5 -07:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \'5 -07:0\' ---> \'H Z\'');
        assert.equal(moment('5 +0100', 'H ZZ').toDate().getUTCHours(), 4, 'parse hours \'5 +0100\' ---> \'H ZZ\'');
        assert.equal(moment('5 +01:00', 'H Z').toDate().getUTCHours(), 4, 'parse hours \'5 +01:00\' ---> \'H Z\'');
        assert.equal(moment('5 +0130', 'H ZZ').toDate().getUTCMinutes(), 30, 'parse hours \'5 +0130\' ---> \'H ZZ\'');
        assert.equal(moment('5 +01:30', 'H Z').toDate().getUTCMinutes(), 30, 'parse hours \'5 +01:30\' ---> \'H Z\'');
    });

    test('string with format (timezone offset)', function (assert) {
        var a, b, c, d, e, f;
        a = new Date(Date.UTC(2011, 0, 1, 1));
        b = moment('2011 1 1 0 -01:00', 'YYYY MM DD HH Z');
        assert.equal(a.getHours(), b.hours(), 'date created with utc == parsed string with timezone offset');
        assert.equal(+a, +b, 'date created with utc == parsed string with timezone offset');
        c = moment('2011 2 1 10 -05:00', 'YYYY MM DD HH Z');
        d = moment('2011 2 1 8 -07:00', 'YYYY MM DD HH Z');
        assert.equal(c.hours(), d.hours(), '10 am central time == 8 am pacific time');
        e = moment.utc('Fri, 20 Jul 2012 17:15:00', 'ddd, DD MMM YYYY HH:mm:ss');
        f = moment.utc('Fri, 20 Jul 2012 10:15:00 -0700', 'ddd, DD MMM YYYY HH:mm:ss ZZ');
        assert.equal(e.hours(), f.hours(), 'parse timezone offset in utc');
    });

    test('string with timezone around start of year', function (assert) {
        assert.equal(moment('2000-01-01T00:00:00.000+01:00').toISOString(), '1999-12-31T23:00:00.000Z', '+1:00 around 2000');
        assert.equal(moment('2000-01-01T00:00:00.000-01:00').toISOString(), '2000-01-01T01:00:00.000Z', '-1:00 around 2000');
        assert.equal(moment('1970-01-01T00:00:00.000+01:00').toISOString(), '1969-12-31T23:00:00.000Z', '+1:00 around 1970');
        assert.equal(moment('1970-01-01T00:00:00.000-01:00').toISOString(), '1970-01-01T01:00:00.000Z', '-1:00 around 1970');
        assert.equal(moment('1200-01-01T00:00:00.000+01:00').toISOString(), '1199-12-31T23:00:00.000Z', '+1:00 around 1200');
        assert.equal(moment('1200-01-01T00:00:00.000-01:00').toISOString(), '1200-01-01T01:00:00.000Z', '-1:00 around 1200');
    });

    test('string with array of formats', function (assert) {
        assert.equal(moment('11-02-1999', ['MM-DD-YYYY', 'DD-MM-YYYY']).format('MM DD YYYY'), '11 02 1999', 'switching month and day');
        assert.equal(moment('02-11-1999', ['MM/DD/YYYY', 'YYYY MM DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 11 1999', 'year last');
        assert.equal(moment('1999-02-11', ['MM/DD/YYYY', 'YYYY MM DD', 'MM-DD-YYYY']).format('MM DD YYYY'), '02 11 1999', 'year first');

        assert.equal(moment('02-11-1999', ['MM/DD/YYYY', 'YYYY MM DD']).format('MM DD YYYY'), '02 11 1999', 'year last');
        assert.equal(moment('1999-02-11', ['MM/DD/YYYY', 'YYYY MM DD']).format('MM DD YYYY'), '02 11 1999', 'year first');
        assert.equal(moment('02-11-1999', ['YYYY MM DD', 'MM/DD/YYYY']).format('MM DD YYYY'), '02 11 1999', 'year last');
        assert.equal(moment('1999-02-11', ['YYYY MM DD', 'MM/DD/YYYY']).format('MM DD YYYY'), '02 11 1999', 'year first');

        assert.equal(moment('13-11-1999', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '11 13 1999', 'second must be month');
        assert.equal(moment('11-13-1999', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '11 13 1999', 'first must be month');
        assert.equal(moment('01-02-2000', ['MM/DD/YYYY', 'DD/MM/YYYY']).format('MM DD YYYY'), '01 02 2000', 'either can be a month, month first format');
        assert.equal(moment('02-01-2000', ['DD/MM/YYYY', 'MM/DD/YYYY']).format('MM DD YYYY'), '01 02 2000', 'either can be a month, day first format');

        assert.equal(moment('11-02-10', ['MM/DD/YY', 'YY MM DD', 'DD-MM-YY']).format('MM DD YYYY'), '02 11 2010', 'all unparsed substrings have influence on format penalty');
        assert.equal(moment('11-02-10', ['MM-DD-YY HH:mm', 'YY MM DD']).format('MM DD YYYY'), '02 10 2011', 'prefer formats without extra tokens');
        assert.equal(moment('11-02-10 junk', ['MM-DD-YY', 'YY.MM.DD junk']).format('MM DD YYYY'), '02 10 2011', 'prefer formats that dont result in extra characters');
        assert.equal(moment('11-22-10', ['YY-MM-DD', 'YY-DD-MM']).format('MM DD YYYY'), '10 22 2011', 'prefer valid results');

        assert.equal(moment('gibberish', ['YY-MM-DD', 'YY-DD-MM']).format('MM DD YYYY'), 'Invalid date', 'doest throw for invalid strings');
        assert.equal(moment('gibberish', []).format('MM DD YYYY'), 'Invalid date', 'doest throw for an empty array');

        //https://github.com/moment/moment/issues/1143
        assert.equal(moment(
            'System Administrator and Database Assistant (7/1/2011), System Administrator and Database Assistant (7/1/2011), Database Coordinator (7/1/2011), Vice President (7/1/2011), System Administrator and Database Assistant (5/31/2012), Database Coordinator (7/1/2012), System Administrator and Database Assistant (7/1/2013)',
            ['MM/DD/YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD', 'YYYY-MM-DDTHH:mm:ssZ'])
            .format('YYYY-MM-DD'), '2011-07-01', 'Works for long strings');

        assert.equal(moment('11-02-10', ['MM.DD.YY', 'DD-MM-YY']).format('MM DD YYYY'), '02 11 2010', 'escape RegExp special characters on comparing');

        assert.equal(moment('13-10-98', ['DD MM YY', 'DD MM YYYY'])._f, 'DD MM YY', 'use two digit year');
        assert.equal(moment('13-10-1998', ['DD MM YY', 'DD MM YYYY'])._f, 'DD MM YYYY', 'use four digit year');

        assert.equal(moment('01', ['MM', 'DD'])._f, 'MM', 'Should use first valid format');
    });

    test('string with array of formats + ISO', function (assert) {
        assert.equal(moment('1994', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).year(), 1994, 'iso: assert parse YYYY');
        assert.equal(moment('17:15', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).hour(), 17, 'iso: assert parse HH:mm (1)');
        assert.equal(moment('17:15', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).minutes(), 15, 'iso: assert parse HH:mm (2)');
        assert.equal(moment('06', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).month(), 6 - 1, 'iso: assert parse MM');
        assert.equal(moment('2012-06-01', [moment.ISO_8601, 'MM', 'HH:mm', 'YYYY']).parsingFlags().iso, true, 'iso: assert parse iso');
        assert.equal(moment('2014-05-05', [moment.ISO_8601, 'YYYY-MM-DD']).parsingFlags().iso, true, 'iso: edge case array precedence iso');
        assert.equal(moment('2014-05-05', ['YYYY-MM-DD', moment.ISO_8601]).parsingFlags().iso, false, 'iso: edge case array precedence not iso');
    });

    test('string with format - years', function (assert) {
        assert.equal(moment('67', 'YY').format('YYYY'), '2067', '67 > 2067');
        assert.equal(moment('68', 'YY').format('YYYY'), '2068', '68 > 2068');
        assert.equal(moment('69', 'YY').format('YYYY'), '1969', '69 > 1969');
        assert.equal(moment('70', 'YY').format('YYYY'), '1970', '70 > 1970');
    });

    test('implicit cloning', function (assert) {
        var momentA = moment([2011, 10, 10]),
        momentB = moment(momentA);
        momentA.month(5);
        assert.equal(momentB.month(), 10, 'Calling moment() on a moment will create a clone');
        assert.equal(momentA.month(), 5, 'Calling moment() on a moment will create a clone');
    });

    test('explicit cloning', function (assert) {
        var momentA = moment([2011, 10, 10]),
        momentB = momentA.clone();
        momentA.month(5);
        assert.equal(momentB.month(), 10, 'Calling moment() on a moment will create a clone');
        assert.equal(momentA.month(), 5, 'Calling moment() on a moment will create a clone');
    });

    test('cloning carrying over utc mode', function (assert) {
        assert.equal(moment().local().clone()._isUTC, false, 'An explicit cloned local moment should have _isUTC == false');
        assert.equal(moment().utc().clone()._isUTC, true, 'An cloned utc moment should have _isUTC == true');
        assert.equal(moment().clone()._isUTC, false, 'An explicit cloned local moment should have _isUTC == false');
        assert.equal(moment.utc().clone()._isUTC, true, 'An explicit cloned utc moment should have _isUTC == true');
        assert.equal(moment(moment().local())._isUTC, false, 'An implicit cloned local moment should have _isUTC == false');
        assert.equal(moment(moment().utc())._isUTC, true, 'An implicit cloned utc moment should have _isUTC == true');
        assert.equal(moment(moment())._isUTC, false, 'An implicit cloned local moment should have _isUTC == false');
        assert.equal(moment(moment.utc())._isUTC, true, 'An implicit cloned utc moment should have _isUTC == true');
    });

    test('parsing iso', function (assert) {
        var offset = moment([2011, 9, 8]).utcOffset(),
        pad = function (input) {
            if (input < 10) {
                return '0' + input;
            }
            return '' + input;
        },
        hourOffset = (offset > 0 ? Math.floor(offset / 60) : Math.ceil(offset / 60)),
        minOffset = offset - (hourOffset * 60),
        tz = (offset >= 0) ?
            '+' + pad(hourOffset) + ':' + pad(minOffset) :
            '-' + pad(-hourOffset) + ':' + pad(-minOffset),
        tz2 = tz.replace(':', ''),
        tz3 = tz2.slice(0, 3),
        formats = [
            ['2011-10-08',                    '2011-10-08T00:00:00.000' + tz],
            ['2011-10-08T18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-10-08T18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04' + tz3,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08T18:04:20' + tz3,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08T18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-10-08T18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-10-08T18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-10-08 18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-10-08 18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04' + tz3,        '2011-10-08T18:04:00.000' + tz],
            ['2011-10-08 18:04:20' + tz3,     '2011-10-08T18:04:20.000' + tz],
            ['2011-10-08 18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-10-08 18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-10-08 18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-W40',                      '2011-10-03T00:00:00.000' + tz],
            ['2011-W40-6',                    '2011-10-08T00:00:00.000' + tz],
            ['2011-W40-6T18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-W40-6T18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04' + tz3,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6T18:04:20' + tz3,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6T18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-W40-6T18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-W40-6T18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-W40-6 18',                 '2011-10-08T18:00:00.000' + tz],
            ['2011-W40-6 18:04',              '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20',           '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04' + tz,         '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20' + tz,      '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04' + tz2,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20' + tz2,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04' + tz3,        '2011-10-08T18:04:00.000' + tz],
            ['2011-W40-6 18:04:20' + tz3,     '2011-10-08T18:04:20.000' + tz],
            ['2011-W40-6 18:04:20.1' + tz2,   '2011-10-08T18:04:20.100' + tz],
            ['2011-W40-6 18:04:20.11' + tz2,  '2011-10-08T18:04:20.110' + tz],
            ['2011-W40-6 18:04:20.111' + tz2, '2011-10-08T18:04:20.111' + tz],
            ['2011-281',                      '2011-10-08T00:00:00.000' + tz],
            ['2011-281T18',                   '2011-10-08T18:00:00.000' + tz],
            ['2011-281T18:04',                '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20',             '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04' + tz,           '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20' + tz,        '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04' + tz2,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20' + tz2,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04' + tz3,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281T18:04:20' + tz3,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281T18:04:20.1' + tz2,     '2011-10-08T18:04:20.100' + tz],
            ['2011-281T18:04:20.11' + tz2,    '2011-10-08T18:04:20.110' + tz],
            ['2011-281T18:04:20.111' + tz2,   '2011-10-08T18:04:20.111' + tz],
            ['2011-281 18',                   '2011-10-08T18:00:00.000' + tz],
            ['2011-281 18:04',                '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20',             '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04' + tz,           '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20' + tz,        '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04' + tz2,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20' + tz2,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04' + tz3,          '2011-10-08T18:04:00.000' + tz],
            ['2011-281 18:04:20' + tz3,       '2011-10-08T18:04:20.000' + tz],
            ['2011-281 18:04:20.1' + tz2,     '2011-10-08T18:04:20.100' + tz],
            ['2011-281 18:04:20.11' + tz2,    '2011-10-08T18:04:20.110' + tz],
            ['2011-281 18:04:20.111' + tz2,   '2011-10-08T18:04:20.111' + tz]
        ], i;
        for (i = 0; i < formats.length; i++) {
            assert.equal(moment(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'), formats[i][1], 'moment should be able to parse ISO ' + formats[i][0]);
        }
    });

    test('parsing iso week year/week/weekday', function (assert) {
        assert.equal(moment.utc('2007-W01').format(), '2007-01-01T00:00:00+00:00', '2008 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-W01').format(), '2007-12-31T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-W01').format(), '2002-12-30T00:00:00+00:00', '2008 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-W01').format(), '2008-12-29T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-W01').format(), '2010-01-04T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-W01').format(), '2011-01-03T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-W01').format(), '2012-01-02T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');
    });

    test('parsing week year/week/weekday (dow 1, doy 4)', function (assert) {
        moment.locale('dow:1,doy:4', {week: {dow: 1, doy: 4}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2007-01-01T00:00:00+00:00', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-31T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-30T00:00:00+00:00', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-29T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2010-01-04T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2011-01-03T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2012-01-02T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');

        moment.defineLocale('dow:1,doy:4', null);
    });

    test('parsing week year/week/weekday (dow 1, doy 7)', function (assert) {
        moment.locale('dow:1,doy:7', {week: {dow: 1, doy: 7}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2007-01-01T00:00:00+00:00', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-31T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-30T00:00:00+00:00', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-29T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-28T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2010-12-27T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2011-12-26T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');
        moment.defineLocale('dow:1,doy:7', null);
    });

    test('parsing week year/week/weekday (dow 0, doy 6)', function (assert) {
        moment.locale('dow:0,doy:6', {week: {dow: 0, doy: 6}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2006-12-31T00:00:00+00:00', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-30T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-29T00:00:00+00:00', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-28T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-27T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2010-12-26T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2012-01-01T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');
        moment.defineLocale('dow:0,doy:6', null);
    });

    test('parsing week year/week/weekday (dow 6, doy 12)', function (assert) {
        moment.locale('dow:6,doy:12', {week: {dow: 6, doy: 12}});

        assert.equal(moment.utc('2007-01', 'gggg-ww').format(), '2006-12-30T00:00:00+00:00', '2007 week 1 (1st Jan Mon)');
        assert.equal(moment.utc('2008-01', 'gggg-ww').format(), '2007-12-29T00:00:00+00:00', '2008 week 1 (1st Jan Tue)');
        assert.equal(moment.utc('2003-01', 'gggg-ww').format(), '2002-12-28T00:00:00+00:00', '2003 week 1 (1st Jan Wed)');
        assert.equal(moment.utc('2009-01', 'gggg-ww').format(), '2008-12-27T00:00:00+00:00', '2009 week 1 (1st Jan Thu)');
        assert.equal(moment.utc('2010-01', 'gggg-ww').format(), '2009-12-26T00:00:00+00:00', '2010 week 1 (1st Jan Fri)');
        assert.equal(moment.utc('2011-01', 'gggg-ww').format(), '2011-01-01T00:00:00+00:00', '2011 week 1 (1st Jan Sat)');
        assert.equal(moment.utc('2012-01', 'gggg-ww').format(), '2011-12-31T00:00:00+00:00', '2012 week 1 (1st Jan Sun)');
    });

    test('parsing ISO with Z', function (assert) {
        var i, mom, formats = [
            ['2011-10-08T18:04',             '2011-10-08T18:04:00.000'],
            ['2011-10-08T18:04:20',          '2011-10-08T18:04:20.000'],
            ['2011-10-08T18:04:20.1',        '2011-10-08T18:04:20.100'],
            ['2011-10-08T18:04:20.11',       '2011-10-08T18:04:20.110'],
            ['2011-10-08T18:04:20.111',      '2011-10-08T18:04:20.111'],
            ['2011-W40-6T18',                '2011-10-08T18:00:00.000'],
            ['2011-W40-6T18:04',             '2011-10-08T18:04:00.000'],
            ['2011-W40-6T18:04:20',          '2011-10-08T18:04:20.000'],
            ['2011-W40-6T18:04:20.1',        '2011-10-08T18:04:20.100'],
            ['2011-W40-6T18:04:20.11',       '2011-10-08T18:04:20.110'],
            ['2011-W40-6T18:04:20.111',      '2011-10-08T18:04:20.111'],
            ['2011-281T18',                  '2011-10-08T18:00:00.000'],
            ['2011-281T18:04',               '2011-10-08T18:04:00.000'],
            ['2011-281T18:04:20',            '2011-10-08T18:04:20.000'],
            ['2011-281T18:04:20',            '2011-10-08T18:04:20.000'],
            ['2011-281T18:04:20.1',          '2011-10-08T18:04:20.100'],
            ['2011-281T18:04:20.11',         '2011-10-08T18:04:20.110'],
            ['2011-281T18:04:20.111',        '2011-10-08T18:04:20.111']
        ];

        for (i = 0; i < formats.length; i++) {
            mom = moment(formats[i][0] + 'Z').utc();
            assert.equal(mom.format('YYYY-MM-DDTHH:mm:ss.SSS'), formats[i][1], 'moment should be able to parse ISO in UTC ' + formats[i][0] + 'Z');

            mom = moment(formats[i][0] + ' Z').utc();
            assert.equal(mom.format('YYYY-MM-DDTHH:mm:ss.SSS'), formats[i][1], 'moment should be able to parse ISO in UTC ' + formats[i][0] + ' Z');
        }
    });

    test('parsing iso with T', function (assert) {
        assert.equal(moment('2011-10-08T18')._f, 'YYYY-MM-DDTHH', 'should include \'T\' in the format');
        assert.equal(moment('2011-10-08T18:20')._f, 'YYYY-MM-DDTHH:mm', 'should include \'T\' in the format');
        assert.equal(moment('2011-10-08T18:20:13')._f, 'YYYY-MM-DDTHH:mm:ss', 'should include \'T\' in the format');
        assert.equal(moment('2011-10-08T18:20:13.321')._f, 'YYYY-MM-DDTHH:mm:ss.SSSS', 'should include \'T\' in the format');

        assert.equal(moment('2011-10-08 18')._f, 'YYYY-MM-DD HH', 'should not include \'T\' in the format');
        assert.equal(moment('2011-10-08 18:20')._f, 'YYYY-MM-DD HH:mm', 'should not include \'T\' in the format');
        assert.equal(moment('2011-10-08 18:20:13')._f, 'YYYY-MM-DD HH:mm:ss', 'should not include \'T\' in the format');
        assert.equal(moment('2011-10-08 18:20:13.321')._f, 'YYYY-MM-DD HH:mm:ss.SSSS', 'should not include \'T\' in the format');
    });

    test('parsing iso Z timezone', function (assert) {
        var i,
        formats = [
            ['2011-10-08T18:04Z',             '2011-10-08T18:04:00.000+00:00'],
            ['2011-10-08T18:04:20Z',          '2011-10-08T18:04:20.000+00:00'],
            ['2011-10-08T18:04:20.111Z',      '2011-10-08T18:04:20.111+00:00']
        ];
        for (i = 0; i < formats.length; i++) {
            assert.equal(moment.utc(formats[i][0]).format('YYYY-MM-DDTHH:mm:ss.SSSZ'), formats[i][1], 'moment should be able to parse ISO ' + formats[i][0]);
        }
    });

    test('parsing iso Z timezone into local', function (assert) {
        var m = moment('2011-10-08T18:04:20.111Z');

        assert.equal(m.utc().format('YYYY-MM-DDTHH:mm:ss.SSS'), '2011-10-08T18:04:20.111', 'moment should be able to parse ISO 2011-10-08T18:04:20.111Z');
    });

    test('parsing iso with more subsecond precision digits', function (assert) {
        assert.equal(moment.utc('2013-07-31T22:00:00.0000000Z').format(), '2013-07-31T22:00:00+00:00', 'more than 3 subsecond digits');
    });

    test('null or empty', function (assert) {
        assert.equal(moment('').isValid(), false, 'moment(\'\') is not valid');
        assert.equal(moment(null).isValid(), false, 'moment(null) is not valid');
        assert.equal(moment(null, 'YYYY-MM-DD').isValid(), false, 'moment(\'\', \'format\') is not valid');
        assert.equal(moment('', 'YYYY-MM-DD').isValid(), false, 'moment(\'\', \'format\') is not valid');
        assert.equal(moment.utc('').isValid(), false, 'moment.utc(\'\') is not valid');
        assert.equal(moment.utc(null).isValid(), false, 'moment.utc(null) is not valid');
        assert.equal(moment.utc(null, 'YYYY-MM-DD').isValid(), false, 'moment.utc(null) is not valid');
        assert.equal(moment.utc('', 'YYYY-MM-DD').isValid(), false, 'moment.utc(\'\', \'YYYY-MM-DD\') is not valid');
    });

    test('first century', function (assert) {
        assert.equal(moment([0, 0, 1]).format('YYYY-MM-DD'), '0000-01-01', 'Year AD 0');
        assert.equal(moment([99, 0, 1]).format('YYYY-MM-DD'), '0099-01-01', 'Year AD 99');
        assert.equal(moment([999, 0, 1]).format('YYYY-MM-DD'), '0999-01-01', 'Year AD 999');
        assert.equal(moment('0 1 1', 'YYYY MM DD').format('YYYY-MM-DD'), '0000-01-01', 'Year AD 0');
        assert.equal(moment('999 1 1', 'YYYY MM DD').format('YYYY-MM-DD'), '0999-01-01', 'Year AD 999');
        assert.equal(moment('0 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00000-01-01', 'Year AD 0');
        assert.equal(moment('99 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00099-01-01', 'Year AD 99');
        assert.equal(moment('999 1 1', 'YYYYY MM DD').format('YYYYY-MM-DD'), '00999-01-01', 'Year AD 999');
    });

    test('six digit years', function (assert) {
        assert.equal(moment([-270000, 0, 1]).format('YYYYY-MM-DD'), '-270000-01-01', 'format BC 270,001');
        assert.equal(moment([270000, 0, 1]).format('YYYYY-MM-DD'), '270000-01-01', 'format AD 270,000');
        assert.equal(moment('-270000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), -270000, 'parse BC 270,001');
        assert.equal(moment('270000-01-01',  'YYYYY-MM-DD').toDate().getFullYear(), 270000, 'parse AD 270,000');
        assert.equal(moment('+270000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), 270000, 'parse AD +270,000');
        assert.equal(moment.utc('-270000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), -270000, 'parse utc BC 270,001');
        assert.equal(moment.utc('270000-01-01',  'YYYYY-MM-DD').toDate().getUTCFullYear(), 270000, 'parse utc AD 270,000');
        assert.equal(moment.utc('+270000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), 270000, 'parse utc AD +270,000');
    });

    test('negative four digit years', function (assert) {
        assert.equal(moment('-1000-01-01', 'YYYYY-MM-DD').toDate().getFullYear(), -1000, 'parse BC 1,001');
        assert.equal(moment.utc('-1000-01-01', 'YYYYY-MM-DD').toDate().getUTCFullYear(), -1000, 'parse utc BC 1,001');
    });

    test('strict parsing', function (assert) {
        assert.equal(moment('2014-', 'YYYY-Q', true).isValid(), false, 'fail missing quarter');

        assert.equal(moment('2012-05', 'YYYY-MM', true).format('YYYY-MM'), '2012-05', 'parse correct string');
        assert.equal(moment(' 2012-05', 'YYYY-MM', true).isValid(), false, 'fail on extra whitespace');
        assert.equal(moment('foo 2012-05', '[foo] YYYY-MM', true).format('YYYY-MM'), '2012-05', 'handle fixed text');
        assert.equal(moment('2012 05', 'YYYY-MM', true).isValid(), false, 'fail on different separator');
        assert.equal(moment('2012 05', 'YYYY MM DD', true).isValid(), false, 'fail on too many tokens');

        assert.equal(moment('05 30 2010', ['DD MM YYYY', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with bad date');
        assert.equal(moment('05 30 2010', ['', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with invalid format');
        assert.equal(moment('05 30 2010', [' DD MM YYYY', 'MM DD YYYY'], true).format('MM DD YYYY'), '05 30 2010', 'array with non-matching format');

        assert.equal(moment('2010.*...', 'YYYY.*', true).isValid(), false, 'invalid format with regex chars');
        assert.equal(moment('2010.*', 'YYYY.*', true).year(), 2010, 'valid format with regex chars');
        assert.equal(moment('.*2010.*', '.*YYYY.*', true).year(), 2010, 'valid format with regex chars on both sides');

        //strict tokens
        assert.equal(moment('-5-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid negative year');
        assert.equal(moment('2-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit year');
        assert.equal(moment('20-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid two-digit year');
        assert.equal(moment('201-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid three-digit year');
        assert.equal(moment('2010-05-25', 'YYYY-MM-DD', true).isValid(), true, 'valid four-digit year');
        assert.equal(moment('22010-05-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid five-digit year');

        assert.equal(moment('12-05-25', 'YY-MM-DD', true).isValid(), true, 'valid two-digit year');
        assert.equal(moment('2012-05-25', 'YY-MM-DD', true).isValid(), false, 'invalid four-digit year');

        assert.equal(moment('-5-05-25', 'Y-MM-DD', true).isValid(), true, 'valid negative year');
        assert.equal(moment('2-05-25', 'Y-MM-DD', true).isValid(), true, 'valid one-digit year');
        assert.equal(moment('20-05-25', 'Y-MM-DD', true).isValid(), true, 'valid two-digit year');
        assert.equal(moment('201-05-25', 'Y-MM-DD', true).isValid(), true, 'valid three-digit year');

        assert.equal(moment('2012-5-25', 'YYYY-M-DD', true).isValid(), true, 'valid one-digit month');
        assert.equal(moment('2012-5-25', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit month');
        assert.equal(moment('2012-05-25', 'YYYY-M-DD', true).isValid(), true, 'valid one-digit month');
        assert.equal(moment('2012-05-25', 'YYYY-MM-DD', true).isValid(), true, 'valid one-digit month');

        assert.equal(moment('2012-05-2', 'YYYY-MM-D', true).isValid(), true, 'valid one-digit day');
        assert.equal(moment('2012-05-2', 'YYYY-MM-DD', true).isValid(), false, 'invalid one-digit day');
        assert.equal(moment('2012-05-02', 'YYYY-MM-D', true).isValid(), true, 'valid two-digit day');
        assert.equal(moment('2012-05-02', 'YYYY-MM-DD', true).isValid(), true, 'valid two-digit day');

        assert.equal(moment('+002012-05-25', 'YYYYY-MM-DD', true).isValid(), true, 'valid six-digit year');
        assert.equal(moment('+2012-05-25', 'YYYYY-MM-DD', true).isValid(), false, 'invalid four-digit year');

        //thse are kinda pointless, but they should work as expected
        assert.equal(moment('1', 'S', true).isValid(), true, 'valid one-digit milisecond');
        assert.equal(moment('12', 'S', true).isValid(), false, 'invalid two-digit milisecond');
        assert.equal(moment('123', 'S', true).isValid(), false, 'invalid three-digit milisecond');

        assert.equal(moment('1', 'SS', true).isValid(), false, 'invalid one-digit milisecond');
        assert.equal(moment('12', 'SS', true).isValid(), true, 'valid two-digit milisecond');
        assert.equal(moment('123', 'SS', true).isValid(), false, 'invalid three-digit milisecond');

        assert.equal(moment('1', 'SSS', true).isValid(), false, 'invalid one-digit milisecond');
        assert.equal(moment('12', 'SSS', true).isValid(), false, 'invalid two-digit milisecond');
        assert.equal(moment('123', 'SSS', true).isValid(), true, 'valid three-digit milisecond');

        // strict parsing respects month length
        assert.ok(moment('1 January 2000', 'D MMMM YYYY', true).isValid(), 'capital long-month + MMMM');
        assert.ok(!moment('1 January 2000', 'D MMM YYYY', true).isValid(), 'capital long-month + MMM');
        assert.ok(!moment('1 Jan 2000', 'D MMMM YYYY', true).isValid(), 'capital short-month + MMMM');
        assert.ok(moment('1 Jan 2000', 'D MMM YYYY', true).isValid(), 'capital short-month + MMM');
        assert.ok(moment('1 january 2000', 'D MMMM YYYY', true).isValid(), 'lower long-month + MMMM');
        assert.ok(!moment('1 january 2000', 'D MMM YYYY', true).isValid(), 'lower long-month + MMM');
        assert.ok(!moment('1 jan 2000', 'D MMMM YYYY', true).isValid(), 'lower short-month + MMMM');
        assert.ok(moment('1 jan 2000', 'D MMM YYYY', true).isValid(), 'lower short-month + MMM');
    });

    test('parsing into a locale', function (assert) {
        moment.defineLocale('parselocale', {
            months : 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),
            monthsShort : 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_')
        });

        moment.locale('en');

        assert.equal(moment('2012 seven', 'YYYY MMM', 'parselocale').month(), 6, 'should be able to parse in a specific locale');

        moment.locale('parselocale');

        assert.equal(moment('2012 july', 'YYYY MMM', 'en').month(), 6, 'should be able to parse in a specific locale');

        moment.defineLocale('parselocale', null);
    });

    function getVerifier(test) {
        return function (input, format, expected, description, asymetrical) {
            var m = moment(input, format);
            test.equal(m.format('YYYY MM DD'), expected, 'compare: ' + description);

            //test round trip
            if (!asymetrical) {
                test.equal(m.format(format), input, 'round trip: ' + description);
            }
        };
    }

    test('parsing week and weekday information', function (assert) {
        var ver = getVerifier(assert);

        // year
        ver('12', 'gg', '2012 01 01', 'week-year two digits');
        ver('2012', 'gggg', '2012 01 01', 'week-year four digits');

        ver('99', 'gg', '1998 12 27', 'week-year two digits previous year');
        ver('1999', 'gggg', '1998 12 27', 'week-year four digits previous year');

        ver('99', 'GG', '1999 01 04', 'iso week-year two digits');
        ver('1999', 'GGGG', '1999 01 04', 'iso week-year four digits');

        ver('13', 'GG', '2012 12 31', 'iso week-year two digits previous year');
        ver('2013', 'GGGG', '2012 12 31', 'iso week-year four digits previous year');

        // year + week
        ver('1999 37', 'gggg w', '1999 09 05', 'week');
        ver('1999 37', 'gggg ww', '1999 09 05', 'week double');
        ver('1999 37', 'GGGG W', '1999 09 13', 'iso week');
        ver('1999 37', 'GGGG WW', '1999 09 13', 'iso week double');

        ver('1999 37 4', 'GGGG WW E', '1999 09 16', 'iso day');
        ver('1999 37 04', 'GGGG WW E', '1999 09 16', 'iso day wide', true);

        ver('1999 37 4', 'gggg ww e', '1999 09 09', 'day');
        ver('1999 37 04', 'gggg ww e', '1999 09 09', 'day wide', true);

        // year + week + day
        ver('1999 37 4', 'gggg ww d', '1999 09 09', 'd');
        ver('1999 37 Th', 'gggg ww dd', '1999 09 09', 'dd');
        ver('1999 37 Thu', 'gggg ww ddd', '1999 09 09', 'ddd');
        ver('1999 37 Thursday', 'gggg ww dddd', '1999 09 09', 'dddd');

        // lower-order only
        assert.equal(moment('22', 'ww').week(), 22, 'week sets the week by itself');
        assert.equal(moment('22', 'ww').weekYear(), moment().weekYear(), 'week keeps this year');
        assert.equal(moment('2012 22', 'YYYY ww').weekYear(), 2012, 'week keeps parsed year');

        assert.equal(moment('22', 'WW').isoWeek(), 22, 'iso week sets the week by itself');
        assert.equal(moment('2012 22', 'YYYY WW').weekYear(), 2012, 'iso week keeps parsed year');
        assert.equal(moment('22', 'WW').isoWeekYear(), moment().isoWeekYear(), 'iso week keeps this year');

        // order
        ver('6 2013 2', 'e gggg w', '2013 01 12', 'order doesn\'t matter');
        ver('6 2013 2', 'E GGGG W', '2013 01 12', 'iso order doesn\'t matter');

        //can parse other stuff too
        assert.equal(moment('1999-W37-4 3:30', 'GGGG-[W]WW-E HH:mm').format('YYYY MM DD HH:mm'), '1999 09 16 03:30', 'parsing weeks and hours');

        // In safari, all years before 1300 are shifted back with one day.
        // http://stackoverflow.com/questions/20768975/safari-subtracts-1-day-from-dates-before-1300
        if (new Date('1300-01-01').getUTCFullYear() === 1300) {
            // Years less than 100
            ver('0098-06', 'GGGG-WW', '0098 02 03', 'small years work', true);
        }
    });

    test('parsing localized weekdays', function (assert) {
        var ver = getVerifier(assert);
        try {
            moment.locale('dow:1,doy:4', {
                weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
                weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
                weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
                week: {dow: 1, doy: 4}
            });
            ver('1999 37 4', 'GGGG WW E', '1999 09 16', 'iso ignores locale');
            ver('1999 37 7', 'GGGG WW E', '1999 09 19', 'iso ignores locale');

            ver('1999 37 0', 'gggg ww e', '1999 09 13', 'localized e uses local doy and dow: 0 = monday');
            ver('1999 37 4', 'gggg ww e', '1999 09 17', 'localized e uses local doy and dow: 4 = friday');

            ver('1999 37 1', 'gggg ww d', '1999 09 13', 'localized d uses 0-indexed days: 1 = monday');
            ver('1999 37 Lu', 'gggg ww dd', '1999 09 13', 'localized d uses 0-indexed days: Mo');
            ver('1999 37 lun.', 'gggg ww ddd', '1999 09 13', 'localized d uses 0-indexed days: Mon');
            ver('1999 37 lundi', 'gggg ww dddd', '1999 09 13', 'localized d uses 0-indexed days: Monday');
            ver('1999 37 4', 'gggg ww d', '1999 09 16', 'localized d uses 0-indexed days: 4');

            //sunday goes at the end of the week
            ver('1999 37 0', 'gggg ww d', '1999 09 19', 'localized d uses 0-indexed days: 0 = sund');
            ver('1999 37 Di', 'gggg ww dd', '1999 09 19', 'localized d uses 0-indexed days: 0 = sund');
        }
        finally {
            moment.locale('en');
        }
    });

    test('parsing with customized two-digit year', function (assert) {
        var original = moment.parseTwoDigitYear;
        try {
            assert.equal(moment('68', 'YY').year(), 2068);
            assert.equal(moment('69', 'YY').year(), 1969);
            moment.parseTwoDigitYear = function (input) {
                return +input + (+input > 30 ? 1900 : 2000);
            };
            assert.equal(moment('68', 'YY').year(), 1968);
            assert.equal(moment('67', 'YY').year(), 1967);
            assert.equal(moment('31', 'YY').year(), 1931);
            assert.equal(moment('30', 'YY').year(), 2030);
        }
        finally {
            moment.parseTwoDigitYear = original;
        }
    });

    test('array with strings', function (assert) {
        assert.equal(moment(['2014', '7', '31']).isValid(), true, 'string array + isValid');
    });

    test('utc with array of formats', function (assert) {
        assert.equal(moment.utc('2014-01-01', ['YYYY-MM-DD', 'YYYY-MM']).format(), '2014-01-01T00:00:00+00:00', 'moment.utc works with array of formats');
    });

    test('parsing invalid string weekdays', function (assert) {
        assert.equal(false, moment('a', 'dd').isValid(),
                'dd with invalid weekday, non-strict');
        assert.equal(false, moment('a', 'dd', true).isValid(),
                'dd with invalid weekday, strict');
        assert.equal(false, moment('a', 'ddd').isValid(),
                'ddd with invalid weekday, non-strict');
        assert.equal(false, moment('a', 'ddd', true).isValid(),
                'ddd with invalid weekday, strict');
        assert.equal(false, moment('a', 'dddd').isValid(),
                'dddd with invalid weekday, non-strict');
        assert.equal(false, moment('a', 'dddd', true).isValid(),
                'dddd with invalid weekday, strict');
    });

    test('milliseconds', function (assert) {
        assert.equal(moment('1', 'S').millisecond(), 100);
        assert.equal(moment('12', 'SS').millisecond(), 120);
        assert.equal(moment('123', 'SSS').millisecond(), 123);
        assert.equal(moment('1234', 'SSSS').millisecond(), 123);
        assert.equal(moment('12345', 'SSSSS').millisecond(), 123);
        assert.equal(moment('123456', 'SSSSSS').millisecond(), 123);
        assert.equal(moment('1234567', 'SSSSSSS').millisecond(), 123);
        assert.equal(moment('12345678', 'SSSSSSSS').millisecond(), 123);
        assert.equal(moment('123456789', 'SSSSSSSSS').millisecond(), 123);
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    module('days in month');

    test('days in month', function (assert) {
        each([31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], function (days, i) {
            var firstDay = moment([2012, i]),
                lastDay  = moment([2012, i, days]);
            assert.equal(firstDay.daysInMonth(), days, firstDay.format('L') + ' should have ' + days + ' days.');
            assert.equal(lastDay.daysInMonth(), days, lastDay.format('L') + ' should have ' + days + ' days.');
        });
    });

    test('days in month leap years', function (assert) {
        assert.equal(moment([2010, 1]).daysInMonth(), 28, 'Feb 2010 should have 28 days');
        assert.equal(moment([2100, 1]).daysInMonth(), 28, 'Feb 2100 should have 28 days');
        assert.equal(moment([2008, 1]).daysInMonth(), 29, 'Feb 2008 should have 29 days');
        assert.equal(moment([2000, 1]).daysInMonth(), 29, 'Feb 2000 should have 29 days');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function equal(assert, a, b, message) {
        assert.ok(Math.abs(a - b) < 0.00000001, '(' + a + ' === ' + b + ') ' + message);
    }

    function dstForYear(year) {
        var start = moment([year]),
            end = moment([year + 1]),
            current = start.clone(),
            last;

        while (current < end) {
            last = current.clone();
            current.add(24, 'hour');
            if (last.utcOffset() !== current.utcOffset()) {
                end = current.clone();
                current = last.clone();
                break;
            }
        }

        while (current < end) {
            last = current.clone();
            current.add(1, 'hour');
            if (last.utcOffset() !== current.utcOffset()) {
                return {
                    moment : last,
                    diff : -(current.utcOffset() - last.utcOffset()) / 60
                };
            }
        }
    }

    module('diff');

    test('diff', function (assert) {
        assert.equal(moment(1000).diff(0), 1000, '1 second - 0 = 1000');
        assert.equal(moment(1000).diff(500), 500, '1 second - 0.5 seconds = 500');
        assert.equal(moment(0).diff(1000), -1000, '0 - 1 second = -1000');
        assert.equal(moment(new Date(1000)).diff(1000), 0, '1 second - 1 second = 0');
        var oneHourDate = new Date(),
        nowDate = new Date(+oneHourDate);
        oneHourDate.setHours(oneHourDate.getHours() + 1);
        assert.equal(moment(oneHourDate).diff(nowDate), 60 * 60 * 1000, '1 hour from now = 3600000');
    });

    test('diff key after', function (assert) {
        assert.equal(moment([2010]).diff([2011], 'years'), -1, 'year diff');
        assert.equal(moment([2010]).diff([2010, 2], 'months'), -2, 'month diff');
        assert.equal(moment([2010]).diff([2010, 0, 7], 'weeks'), 0, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 8], 'weeks'), -1, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 21], 'weeks'), -2, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 22], 'weeks'), -3, 'week diff');
        assert.equal(moment([2010]).diff([2010, 0, 4], 'days'), -3, 'day diff');
        assert.equal(moment([2010]).diff([2010, 0, 1, 4], 'hours'), -4, 'hour diff');
        assert.equal(moment([2010]).diff([2010, 0, 1, 0, 5], 'minutes'), -5, 'minute diff');
        assert.equal(moment([2010]).diff([2010, 0, 1, 0, 0, 6], 'seconds'), -6, 'second diff');
    });

    test('diff key before', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'years'), 1, 'year diff');
        assert.equal(moment([2010, 2]).diff([2010], 'months'), 2, 'month diff');
        assert.equal(moment([2010, 0, 4]).diff([2010], 'days'), 3, 'day diff');
        assert.equal(moment([2010, 0, 7]).diff([2010], 'weeks'), 0, 'week diff');
        assert.equal(moment([2010, 0, 8]).diff([2010], 'weeks'), 1, 'week diff');
        assert.equal(moment([2010, 0, 21]).diff([2010], 'weeks'), 2, 'week diff');
        assert.equal(moment([2010, 0, 22]).diff([2010], 'weeks'), 3, 'week diff');
        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'hours'), 4, 'hour diff');
        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'minutes'), 5, 'minute diff');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 'seconds'), 6, 'second diff');
    });

    test('diff key before singular', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'year'), 1, 'year diff singular');
        assert.equal(moment([2010, 2]).diff([2010], 'month'), 2, 'month diff singular');
        assert.equal(moment([2010, 0, 4]).diff([2010], 'day'), 3, 'day diff singular');
        assert.equal(moment([2010, 0, 7]).diff([2010], 'week'), 0, 'week diff singular');
        assert.equal(moment([2010, 0, 8]).diff([2010], 'week'), 1, 'week diff singular');
        assert.equal(moment([2010, 0, 21]).diff([2010], 'week'), 2, 'week diff singular');
        assert.equal(moment([2010, 0, 22]).diff([2010], 'week'), 3, 'week diff singular');
        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'hour'), 4, 'hour diff singular');
        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'minute'), 5, 'minute diff singular');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 'second'), 6, 'second diff singular');
    });

    test('diff key before abbreviated', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'y'), 1, 'year diff abbreviated');
        assert.equal(moment([2010, 2]).diff([2010], 'M'), 2, 'month diff abbreviated');
        assert.equal(moment([2010, 0, 4]).diff([2010], 'd'), 3, 'day diff abbreviated');
        assert.equal(moment([2010, 0, 7]).diff([2010], 'w'), 0, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 8]).diff([2010], 'w'), 1, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 21]).diff([2010], 'w'), 2, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 22]).diff([2010], 'w'), 3, 'week diff abbreviated');
        assert.equal(moment([2010, 0, 1, 4]).diff([2010], 'h'), 4, 'hour diff abbreviated');
        assert.equal(moment([2010, 0, 1, 0, 5]).diff([2010], 'm'), 5, 'minute diff abbreviated');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).diff([2010], 's'), 6, 'second diff abbreviated');
    });

    test('diff month', function (assert) {
        assert.equal(moment([2011, 0, 31]).diff([2011, 2, 1], 'months'), -1, 'month diff');
    });

    test('diff across DST', function (assert) {
        var dst = dstForYear(2012), a, b, daysInMonth;
        if (!dst) {
            assert.equal(42, 42, 'at least one assertion');
            return;
        }

        a = dst.moment;
        b = a.clone().utc().add(12, 'hours').local();
        daysInMonth = (a.daysInMonth() + b.daysInMonth()) / 2;
        assert.equal(b.diff(a, 'milliseconds', true), 12 * 60 * 60 * 1000,
                'ms diff across DST');
        assert.equal(b.diff(a, 'seconds', true), 12 * 60 * 60,
                'second diff across DST');
        assert.equal(b.diff(a, 'minutes', true), 12 * 60,
                'minute diff across DST');
        assert.equal(b.diff(a, 'hours', true), 12,
                'hour diff across DST');
        assert.equal(b.diff(a, 'days', true), (12 - dst.diff) / 24,
                'day diff across DST');
        equal(assert, b.diff(a, 'weeks', true),  (12 - dst.diff) / 24 / 7,
                'week diff across DST');
        assert.ok(0.95 / (2 * 31) < b.diff(a, 'months', true),
                'month diff across DST, lower bound');
        assert.ok(b.diff(a, 'month', true) < 1.05 / (2 * 28),
                'month diff across DST, upper bound');
        assert.ok(0.95 / (2 * 31 * 12) < b.diff(a, 'years', true),
                'year diff across DST, lower bound');
        assert.ok(b.diff(a, 'year', true) < 1.05 / (2 * 28 * 12),
                'year diff across DST, upper bound');

        a = dst.moment;
        b = a.clone().utc().add(12 + dst.diff, 'hours').local();
        daysInMonth = (a.daysInMonth() + b.daysInMonth()) / 2;

        assert.equal(b.diff(a, 'milliseconds', true),
                (12 + dst.diff) * 60 * 60 * 1000,
                'ms diff across DST');
        assert.equal(b.diff(a, 'seconds', true),  (12 + dst.diff) * 60 * 60,
                'second diff across DST');
        assert.equal(b.diff(a, 'minutes', true),  (12 + dst.diff) * 60,
                'minute diff across DST');
        assert.equal(b.diff(a, 'hours', true),  (12 + dst.diff),
                'hour diff across DST');
        assert.equal(b.diff(a, 'days', true),  12 / 24, 'day diff across DST');
        equal(assert, b.diff(a, 'weeks', true),  12 / 24 / 7,
                'week diff across DST');
        assert.ok(0.95 / (2 * 31) < b.diff(a, 'months', true),
                'month diff across DST, lower bound');
        assert.ok(b.diff(a, 'month', true) < 1.05 / (2 * 28),
                'month diff across DST, upper bound');
        assert.ok(0.95 / (2 * 31 * 12) < b.diff(a, 'years', true),
                'year diff across DST, lower bound');
        assert.ok(b.diff(a, 'year', true) < 1.05 / (2 * 28 * 12),
                'year diff across DST, upper bound');
    });

    test('diff overflow', function (assert) {
        assert.equal(moment([2011]).diff([2010], 'months'), 12, 'month diff');
        assert.equal(moment([2010, 0, 2]).diff([2010], 'hours'), 24, 'hour diff');
        assert.equal(moment([2010, 0, 1, 2]).diff([2010], 'minutes'), 120, 'minute diff');
        assert.equal(moment([2010, 0, 1, 0, 4]).diff([2010], 'seconds'), 240, 'second diff');
    });

    test('diff between utc and local', function (assert) {
        if (moment([2012]).utcOffset() === moment([2011]).utcOffset()) {
            // Russia's utc offset on 1st of Jan 2012 vs 2011 is different
            assert.equal(moment([2012]).utc().diff([2011], 'years'), 1, 'year diff');
        }
        assert.equal(moment([2010, 2, 2]).utc().diff([2010, 0, 2], 'months'), 2, 'month diff');
        assert.equal(moment([2010, 0, 4]).utc().diff([2010], 'days'), 3, 'day diff');
        assert.equal(moment([2010, 0, 22]).utc().diff([2010], 'weeks'), 3, 'week diff');
        assert.equal(moment([2010, 0, 1, 4]).utc().diff([2010], 'hours'), 4, 'hour diff');
        assert.equal(moment([2010, 0, 1, 0, 5]).utc().diff([2010], 'minutes'), 5, 'minute diff');
        assert.equal(moment([2010, 0, 1, 0, 0, 6]).utc().diff([2010], 'seconds'), 6, 'second diff');
    });

    test('diff floored', function (assert) {
        assert.equal(moment([2010, 0, 1, 23]).diff([2010], 'day'), 0, '23 hours = 0 days');
        assert.equal(moment([2010, 0, 1, 23, 59]).diff([2010], 'day'), 0, '23:59 hours = 0 days');
        assert.equal(moment([2010, 0, 1, 24]).diff([2010], 'day'), 1, '24 hours = 1 day');
        assert.equal(moment([2010, 0, 2]).diff([2011, 0, 1], 'year'), 0, 'year rounded down');
        assert.equal(moment([2011, 0, 1]).diff([2010, 0, 2], 'year'), 0, 'year rounded down');
        assert.equal(moment([2010, 0, 2]).diff([2011, 0, 2], 'year'), -1, 'year rounded down');
        assert.equal(moment([2011, 0, 2]).diff([2010, 0, 2], 'year'), 1, 'year rounded down');
    });

    test('year diffs include dates', function (assert) {
        assert.ok(moment([2012, 1, 19]).diff(moment([2002, 1, 20]), 'years', true) < 10, 'year diff should include date of month');
    });

    test('month diffs', function (assert) {
        // due to floating point math errors, these tests just need to be accurate within 0.00000001
        assert.equal(moment([2012, 0, 1]).diff([2012, 1, 1], 'months', true), -1, 'Jan 1 to Feb 1 should be 1 month');
        equal(assert, moment([2012, 0, 1]).diff([2012, 0, 1, 12], 'months', true), -0.5 / 31, 'Jan 1 to Jan 1 noon should be 0.5 / 31 months');
        assert.equal(moment([2012, 0, 15]).diff([2012, 1, 15], 'months', true), -1, 'Jan 15 to Feb 15 should be 1 month');
        assert.equal(moment([2012, 0, 28]).diff([2012, 1, 28], 'months', true), -1, 'Jan 28 to Feb 28 should be 1 month');
        assert.ok(moment([2012, 0, 31]).diff([2012, 1, 29], 'months', true), -1, 'Jan 31 to Feb 29 should be 1 month');
        assert.ok(-1 > moment([2012, 0, 31]).diff([2012, 2, 1], 'months', true), 'Jan 31 to Mar 1 should be more than 1 month');
        assert.ok(-30 / 28 < moment([2012, 0, 31]).diff([2012, 2, 1], 'months', true), 'Jan 31 to Mar 1 should be less than 1 month and 1 day');
        equal(assert, moment([2012, 0, 1]).diff([2012, 0, 31], 'months', true), -(30 / 31), 'Jan 1 to Jan 31 should be 30 / 31 months');
        assert.ok(0 < moment('2014-02-01').diff(moment('2014-01-31'), 'months', true), 'jan-31 to feb-1 diff is positive');
    });

    test('exact month diffs', function (assert) {
        // generate all pairs of months and compute month diff, with fixed day
        // of month = 15.

        var m1, m2;
        for (m1 = 0; m1 < 12; ++m1) {
            for (m2 = m1; m2 < 12; ++m2) {
                assert.equal(moment([2013, m2, 15]).diff(moment([2013, m1, 15]), 'months', true), m2 - m1,
                             'month diff from 2013-' + m1 + '-15 to 2013-' + m2 + '-15');
            }
        }
    });

    test('year diffs', function (assert) {
        // due to floating point math errors, these tests just need to be accurate within 0.00000001
        equal(assert, moment([2012, 0, 1]).diff([2013, 0, 1], 'years', true), -1, 'Jan 1 2012 to Jan 1 2013 should be 1 year');
        equal(assert, moment([2012, 1, 28]).diff([2013, 1, 28], 'years', true), -1, 'Feb 28 2012 to Feb 28 2013 should be 1 year');
        equal(assert, moment([2012, 2, 1]).diff([2013, 2, 1], 'years', true), -1, 'Mar 1 2012 to Mar 1 2013 should be 1 year');
        equal(assert, moment([2012, 11, 1]).diff([2013, 11, 1], 'years', true), -1, 'Dec 1 2012 to Dec 1 2013 should be 1 year');
        equal(assert, moment([2012, 11, 31]).diff([2013, 11, 31], 'years', true), -1, 'Dec 31 2012 to Dec 31 2013 should be 1 year');
        equal(assert, moment([2012, 0, 1]).diff([2013, 6, 1], 'years', true), -1.5, 'Jan 1 2012 to Jul 1 2013 should be 1.5 years');
        equal(assert, moment([2012, 0, 31]).diff([2013, 6, 31], 'years', true), -1.5, 'Jan 31 2012 to Jul 31 2013 should be 1.5 years');
        equal(assert, moment([2012, 0, 1]).diff([2013, 0, 1, 12], 'years', true), -1 - (0.5 / 31) / 12, 'Jan 1 2012 to Jan 1 2013 noon should be 1+(0.5 / 31) / 12 years');
        equal(assert, moment([2012, 0, 1]).diff([2013, 6, 1, 12], 'years', true), -1.5 - (0.5 / 31) / 12, 'Jan 1 2012 to Jul 1 2013 noon should be 1.5+(0.5 / 31) / 12 years');
        equal(assert, moment([2012, 1, 29]).diff([2013, 1, 28], 'years', true), -1, 'Feb 29 2012 to Feb 28 2013 should be 1-(1 / 28.5) / 12 years');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('duration');

    test('object instantiation', function (assert) {
        var d = moment.duration({
            years: 2,
            months: 3,
            weeks: 2,
            days: 1,
            hours: 8,
            minutes: 9,
            seconds: 20,
            milliseconds: 12
        });

        assert.equal(d.years(),        2,  'years');
        assert.equal(d.months(),       3,  'months');
        assert.equal(d.weeks(),        2,  'weeks');
        assert.equal(d.days(),         15, 'days'); // two weeks + 1 day
        assert.equal(d.hours(),        8,  'hours');
        assert.equal(d.minutes(),      9,  'minutes');
        assert.equal(d.seconds(),      20, 'seconds');
        assert.equal(d.milliseconds(), 12, 'milliseconds');
    });

    test('object instantiation with strings', function (assert) {
        var d = moment.duration({
            years: '2',
            months: '3',
            weeks: '2',
            days: '1',
            hours: '8',
            minutes: '9',
            seconds: '20',
            milliseconds: '12'
        });

        assert.equal(d.years(),        2,  'years');
        assert.equal(d.months(),       3,  'months');
        assert.equal(d.weeks(),        2,  'weeks');
        assert.equal(d.days(),         15, 'days'); // two weeks + 1 day
        assert.equal(d.hours(),        8,  'hours');
        assert.equal(d.minutes(),      9,  'minutes');
        assert.equal(d.seconds(),      20, 'seconds');
        assert.equal(d.milliseconds(), 12, 'milliseconds');
    });

    test('milliseconds instantiation', function (assert) {
        assert.equal(moment.duration(72).milliseconds(), 72, 'milliseconds');
    });

    test('undefined instantiation', function (assert) {
        assert.equal(moment.duration(undefined).milliseconds(), 0, 'milliseconds');
    });

    test('null instantiation', function (assert) {
        assert.equal(moment.duration(null).milliseconds(), 0, 'milliseconds');
    });

    test('instantiation by type', function (assert) {
        assert.equal(moment.duration(1, 'years').years(),                 1, 'years');
        assert.equal(moment.duration(1, 'y').years(),                     1, 'y');
        assert.equal(moment.duration(2, 'months').months(),               2, 'months');
        assert.equal(moment.duration(2, 'M').months(),                    2, 'M');
        assert.equal(moment.duration(3, 'weeks').weeks(),                 3, 'weeks');
        assert.equal(moment.duration(3, 'w').weeks(),                     3, 'weeks');
        assert.equal(moment.duration(4, 'days').days(),                   4, 'days');
        assert.equal(moment.duration(4, 'd').days(),                      4, 'd');
        assert.equal(moment.duration(5, 'hours').hours(),                 5, 'hours');
        assert.equal(moment.duration(5, 'h').hours(),                     5, 'h');
        assert.equal(moment.duration(6, 'minutes').minutes(),             6, 'minutes');
        assert.equal(moment.duration(6, 'm').minutes(),                   6, 'm');
        assert.equal(moment.duration(7, 'seconds').seconds(),             7, 'seconds');
        assert.equal(moment.duration(7, 's').seconds(),                   7, 's');
        assert.equal(moment.duration(8, 'milliseconds').milliseconds(),   8, 'milliseconds');
        assert.equal(moment.duration(8, 'ms').milliseconds(),             8, 'ms');
    });

    test('shortcuts', function (assert) {
        assert.equal(moment.duration({y: 1}).years(),         1, 'years = y');
        assert.equal(moment.duration({M: 2}).months(),        2, 'months = M');
        assert.equal(moment.duration({w: 3}).weeks(),         3, 'weeks = w');
        assert.equal(moment.duration({d: 4}).days(),          4, 'days = d');
        assert.equal(moment.duration({h: 5}).hours(),         5, 'hours = h');
        assert.equal(moment.duration({m: 6}).minutes(),       6, 'minutes = m');
        assert.equal(moment.duration({s: 7}).seconds(),       7, 'seconds = s');
        assert.equal(moment.duration({ms: 8}).milliseconds(), 8, 'milliseconds = ms');
    });

    test('generic getter', function (assert) {
        assert.equal(moment.duration(1, 'years').get('years'),                1, 'years');
        assert.equal(moment.duration(1, 'years').get('year'),                 1, 'years = year');
        assert.equal(moment.duration(1, 'years').get('y'),                    1, 'years = y');
        assert.equal(moment.duration(2, 'months').get('months'),              2, 'months');
        assert.equal(moment.duration(2, 'months').get('month'),               2, 'months = month');
        assert.equal(moment.duration(2, 'months').get('M'),                   2, 'months = M');
        assert.equal(moment.duration(3, 'weeks').get('weeks'),                3, 'weeks');
        assert.equal(moment.duration(3, 'weeks').get('week'),                 3, 'weeks = week');
        assert.equal(moment.duration(3, 'weeks').get('w'),                    3, 'weeks = w');
        assert.equal(moment.duration(4, 'days').get('days'),                  4, 'days');
        assert.equal(moment.duration(4, 'days').get('day'),                   4, 'days = day');
        assert.equal(moment.duration(4, 'days').get('d'),                     4, 'days = d');
        assert.equal(moment.duration(5, 'hours').get('hours'),                5, 'hours');
        assert.equal(moment.duration(5, 'hours').get('hour'),                 5, 'hours = hour');
        assert.equal(moment.duration(5, 'hours').get('h'),                    5, 'hours = h');
        assert.equal(moment.duration(6, 'minutes').get('minutes'),            6, 'minutes');
        assert.equal(moment.duration(6, 'minutes').get('minute'),             6, 'minutes = minute');
        assert.equal(moment.duration(6, 'minutes').get('m'),                  6, 'minutes = m');
        assert.equal(moment.duration(7, 'seconds').get('seconds'),            7, 'seconds');
        assert.equal(moment.duration(7, 'seconds').get('second'),             7, 'seconds = second');
        assert.equal(moment.duration(7, 'seconds').get('s'),                  7, 'seconds = s');
        assert.equal(moment.duration(8, 'milliseconds').get('milliseconds'),  8, 'milliseconds');
        assert.equal(moment.duration(8, 'milliseconds').get('millisecond'),   8, 'milliseconds = millisecond');
        assert.equal(moment.duration(8, 'milliseconds').get('ms'),            8, 'milliseconds = ms');
    });

    test('instantiation from another duration', function (assert) {
        var simple = moment.duration(1234),
            lengthy = moment.duration(60 * 60 * 24 * 360 * 1e3),
            complicated = moment.duration({
                years: 2,
                months: 3,
                weeks: 4,
                days: 1,
                hours: 8,
                minutes: 9,
                seconds: 20,
                milliseconds: 12
            }),
            modified = moment.duration(1, 'day').add(moment.duration(1, 'day'));

        assert.deepEqual(moment.duration(simple), simple, 'simple clones are equal');
        assert.deepEqual(moment.duration(lengthy), lengthy, 'lengthy clones are equal');
        assert.deepEqual(moment.duration(complicated), complicated, 'complicated clones are equal');
        assert.deepEqual(moment.duration(modified), modified, 'cloning modified duration works');
    });

    test('instantiation from 24-hour time zero', function (assert) {
        assert.equal(moment.duration('00:00').years(), 0, '0 years');
        assert.equal(moment.duration('00:00').days(), 0, '0 days');
        assert.equal(moment.duration('00:00').hours(), 0, '0 hours');
        assert.equal(moment.duration('00:00').minutes(), 0, '0 minutes');
        assert.equal(moment.duration('00:00').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('00:00').milliseconds(), 0, '0 milliseconds');
    });

    test('instantiation from 24-hour time <24 hours', function (assert) {
        assert.equal(moment.duration('06:45').years(), 0, '0 years');
        assert.equal(moment.duration('06:45').days(), 0, '0 days');
        assert.equal(moment.duration('06:45').hours(), 6, '6 hours');
        assert.equal(moment.duration('06:45').minutes(), 45, '45 minutes');
        assert.equal(moment.duration('06:45').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('06:45').milliseconds(), 0, '0 milliseconds');
    });

    test('instantiation from 24-hour time >24 hours', function (assert) {
        assert.equal(moment.duration('26:45').years(), 0, '0 years');
        assert.equal(moment.duration('26:45').days(), 1, '0 days');
        assert.equal(moment.duration('26:45').hours(), 2, '2 hours');
        assert.equal(moment.duration('26:45').minutes(), 45, '45 minutes');
        assert.equal(moment.duration('26:45').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('26:45').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan zero', function (assert) {
        assert.equal(moment.duration('00:00:00').years(), 0, '0 years');
        assert.equal(moment.duration('00:00:00').days(), 0, '0 days');
        assert.equal(moment.duration('00:00:00').hours(), 0, '0 hours');
        assert.equal(moment.duration('00:00:00').minutes(), 0, '0 minutes');
        assert.equal(moment.duration('00:00:00').seconds(), 0, '0 seconds');
        assert.equal(moment.duration('00:00:00').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan with days', function (assert) {
        assert.equal(moment.duration('1.02:03:04.9999999').years(), 0, '0 years');
        assert.equal(moment.duration('1.02:03:04.9999999').days(), 1, '1 day');
        assert.equal(moment.duration('1.02:03:04.9999999').hours(), 2, '2 hours');
        assert.equal(moment.duration('1.02:03:04.9999999').minutes(), 3, '3 minutes');
        assert.equal(moment.duration('1.02:03:04.9999999').seconds(), 4, '4 seconds');
        assert.equal(moment.duration('1.02:03:04.9999999').milliseconds(), 999, '999 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan without days', function (assert) {
        assert.equal(moment.duration('01:02:03.9999999').years(), 0, '0 years');
        assert.equal(moment.duration('01:02:03.9999999').days(), 0, '0 days');
        assert.equal(moment.duration('01:02:03.9999999').hours(), 1, '1 hour');
        assert.equal(moment.duration('01:02:03.9999999').minutes(), 2, '2 minutes');
        assert.equal(moment.duration('01:02:03.9999999').seconds(), 3, '3 seconds');
        assert.equal(moment.duration('01:02:03.9999999').milliseconds(), 999, '999 milliseconds');

        assert.equal(moment.duration('23:59:59.9999999').days(), 0, '0 days');
        assert.equal(moment.duration('23:59:59.9999999').hours(), 23, '23 hours');

        assert.equal(moment.duration('500:59:59.9999999').days(), 20, '500 hours overflows to 20 days');
        assert.equal(moment.duration('500:59:59.9999999').hours(), 20, '500 hours overflows to 20 hours');
    });

    test('instatiation from serialized C# TimeSpan without days or milliseconds', function (assert) {
        assert.equal(moment.duration('01:02:03').years(), 0, '0 years');
        assert.equal(moment.duration('01:02:03').days(), 0, '0 days');
        assert.equal(moment.duration('01:02:03').hours(), 1, '1 hour');
        assert.equal(moment.duration('01:02:03').minutes(), 2, '2 minutes');
        assert.equal(moment.duration('01:02:03').seconds(), 3, '3 seconds');
        assert.equal(moment.duration('01:02:03').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan without milliseconds', function (assert) {
        assert.equal(moment.duration('1.02:03:04').years(), 0, '0 years');
        assert.equal(moment.duration('1.02:03:04').days(), 1, '1 day');
        assert.equal(moment.duration('1.02:03:04').hours(), 2, '2 hours');
        assert.equal(moment.duration('1.02:03:04').minutes(), 3, '3 minutes');
        assert.equal(moment.duration('1.02:03:04').seconds(), 4, '4 seconds');
        assert.equal(moment.duration('1.02:03:04').milliseconds(), 0, '0 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan maxValue', function (assert) {
        var d = moment.duration('10675199.02:48:05.4775807');

        assert.equal(d.years(), 29227, '29227 years');
        assert.equal(d.months(), 8, '8 months');
        assert.equal(d.days(), 12, '12 day');  // if you have to change this value -- just do it

        assert.equal(d.hours(), 2, '2 hours');
        assert.equal(d.minutes(), 48, '48 minutes');
        assert.equal(d.seconds(), 5, '5 seconds');
        assert.equal(d.milliseconds(), 477, '477 milliseconds');
    });

    test('instatiation from serialized C# TimeSpan minValue', function (assert) {
        var d = moment.duration('-10675199.02:48:05.4775808');

        assert.equal(d.years(), -29227, '29653 years');
        assert.equal(d.months(), -8, '8 day');
        assert.equal(d.days(), -12, '12 day');  // if you have to change this value -- just do it

        assert.equal(d.hours(), -2, '2 hours');
        assert.equal(d.minutes(), -48, '48 minutes');
        assert.equal(d.seconds(), -5, '5 seconds');
        assert.equal(d.milliseconds(), -477, '477 milliseconds');
    });

    test('instantiation from ISO 8601 duration', function (assert) {
        assert.equal(moment.duration('P1Y2M3DT4H5M6S').asSeconds(), moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).asSeconds(), 'all fields');
        assert.equal(moment.duration('P1M').asSeconds(), moment.duration({M: 1}).asSeconds(), 'single month field');
        assert.equal(moment.duration('PT1M').asSeconds(), moment.duration({m: 1}).asSeconds(), 'single minute field');
        assert.equal(moment.duration('P1MT2H').asSeconds(), moment.duration({M: 1, h: 2}).asSeconds(), 'random fields missing');
        assert.equal(moment.duration('-P60D').asSeconds(), moment.duration({d: -60}).asSeconds(), 'negative days');
        assert.equal(moment.duration('PT0.5S').asSeconds(), moment.duration({s: 0.5}).asSeconds(), 'fractional seconds');
        assert.equal(moment.duration('PT0,5S').asSeconds(), moment.duration({s: 0.5}).asSeconds(), 'fractional seconds (comma)');
    });

    test('serialization to ISO 8601 duration strings', function (assert) {
        assert.equal(moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).toISOString(), 'P1Y2M3DT4H5M6S', 'all fields');
        assert.equal(moment.duration({M: -1}).toISOString(), '-P1M', 'one month ago');
        assert.equal(moment.duration({m: -1}).toISOString(), '-PT1M', 'one minute ago');
        assert.equal(moment.duration({s: -0.5}).toISOString(), '-PT0.5S', 'one half second ago');
        assert.equal(moment.duration({y: -0.5, M: 1}).toISOString(), '-P5M', 'a month after half a year ago');
        assert.equal(moment.duration({}).toISOString(), 'P0D', 'zero duration');
        assert.equal(moment.duration({M: 16, d:40, s: 86465}).toISOString(), 'P1Y4M40DT24H1M5S', 'all fields');
    });

    test('toString acts as toISOString', function (assert) {
        assert.equal(moment.duration({y: 1, M: 2, d: 3, h: 4, m: 5, s: 6}).toString(), 'P1Y2M3DT4H5M6S', 'all fields');
        assert.equal(moment.duration({M: -1}).toString(), '-P1M', 'one month ago');
        assert.equal(moment.duration({m: -1}).toString(), '-PT1M', 'one minute ago');
        assert.equal(moment.duration({s: -0.5}).toString(), '-PT0.5S', 'one half second ago');
        assert.equal(moment.duration({y: -0.5, M: 1}).toString(), '-P5M', 'a month after half a year ago');
        assert.equal(moment.duration({}).toString(), 'P0D', 'zero duration');
        assert.equal(moment.duration({M: 16, d:40, s: 86465}).toString(), 'P1Y4M40DT24H1M5S', 'all fields');
    });

    test('toIsoString deprecation', function (assert) {
        assert.equal(moment.duration({}).toIsoString(), moment.duration({}).toISOString(), 'toIsoString delegates to toISOString');
    });

    test('`isodate` (python) test cases', function (assert) {
        assert.equal(moment.duration('P18Y9M4DT11H9M8S').asSeconds(), moment.duration({y: 18, M: 9, d: 4, h: 11, m: 9, s: 8}).asSeconds(), 'python isodate 1');
        assert.equal(moment.duration('P2W').asSeconds(), moment.duration({w: 2}).asSeconds(), 'python isodate 2');
        assert.equal(moment.duration('P3Y6M4DT12H30M5S').asSeconds(), moment.duration({y: 3, M: 6, d: 4, h: 12, m: 30, s: 5}).asSeconds(), 'python isodate 3');
        assert.equal(moment.duration('P23DT23H').asSeconds(), moment.duration({d: 23, h: 23}).asSeconds(), 'python isodate 4');
        assert.equal(moment.duration('P4Y').asSeconds(), moment.duration({y: 4}).asSeconds(), 'python isodate 5');
        assert.equal(moment.duration('P1M').asSeconds(), moment.duration({M: 1}).asSeconds(), 'python isodate 6');
        assert.equal(moment.duration('PT1M').asSeconds(), moment.duration({m: 1}).asSeconds(), 'python isodate 7');
        assert.equal(moment.duration('P0.5Y').asSeconds(), moment.duration({y: 0.5}).asSeconds(), 'python isodate 8');
        assert.equal(moment.duration('PT36H').asSeconds(), moment.duration({h: 36}).asSeconds(), 'python isodate 9');
        assert.equal(moment.duration('P1DT12H').asSeconds(), moment.duration({d: 1, h: 12}).asSeconds(), 'python isodate 10');
        assert.equal(moment.duration('-P2W').asSeconds(), moment.duration({w: -2}).asSeconds(), 'python isodate 11');
        assert.equal(moment.duration('-P2.2W').asSeconds(), moment.duration({w: -2.2}).asSeconds(), 'python isodate 12');
        assert.equal(moment.duration('P1DT2H3M4S').asSeconds(), moment.duration({d: 1, h: 2, m: 3, s: 4}).asSeconds(), 'python isodate 13');
        assert.equal(moment.duration('P1DT2H3M').asSeconds(), moment.duration({d: 1, h: 2, m: 3}).asSeconds(), 'python isodate 14');
        assert.equal(moment.duration('P1DT2H').asSeconds(), moment.duration({d: 1, h: 2}).asSeconds(), 'python isodate 15');
        assert.equal(moment.duration('PT2H').asSeconds(), moment.duration({h: 2}).asSeconds(), 'python isodate 16');
        assert.equal(moment.duration('PT2.3H').asSeconds(), moment.duration({h: 2.3}).asSeconds(), 'python isodate 17');
        assert.equal(moment.duration('PT2H3M4S').asSeconds(), moment.duration({h: 2, m: 3, s: 4}).asSeconds(), 'python isodate 18');
        assert.equal(moment.duration('PT3M4S').asSeconds(), moment.duration({m: 3, s: 4}).asSeconds(), 'python isodate 19');
        assert.equal(moment.duration('PT22S').asSeconds(), moment.duration({s: 22}).asSeconds(), 'python isodate 20');
        assert.equal(moment.duration('PT22.22S').asSeconds(), moment.duration({s: 22.22}).asSeconds(), 'python isodate 21');
        assert.equal(moment.duration('-P2Y').asSeconds(), moment.duration({y: -2}).asSeconds(), 'python isodate 22');
        assert.equal(moment.duration('-P3Y6M4DT12H30M5S').asSeconds(), moment.duration({y: -3, M: -6, d: -4, h: -12, m: -30, s: -5}).asSeconds(), 'python isodate 23');
        assert.equal(moment.duration('-P1DT2H3M4S').asSeconds(), moment.duration({d: -1, h: -2, m: -3, s: -4}).asSeconds(), 'python isodate 24');
    });

    test('ISO 8601 misuse cases', function (assert) {
        assert.equal(moment.duration('P').asSeconds(), 0, 'lonely P');
        assert.equal(moment.duration('PT').asSeconds(), 0, 'just P and T');
        assert.equal(moment.duration('P1H').asSeconds(), 0, 'missing T');
        assert.equal(moment.duration('P1D1Y').asSeconds(), 0, 'out of order');
        assert.equal(moment.duration('PT.5S').asSeconds(), 0.5, 'accept no leading zero for decimal');
        assert.equal(moment.duration('PT1,S').asSeconds(), 1, 'accept trailing decimal separator');
        assert.equal(moment.duration('PT1M0,,5S').asSeconds(), 60, 'extra decimal separators are ignored as 0');
        assert.equal(moment.duration('P-1DS').asSeconds(), 0, 'wrong position of negative');
    });

    test('humanize', function (assert) {
        moment.locale('en');
        assert.equal(moment.duration({seconds: 44}).humanize(),  'a few seconds', '44 seconds = a few seconds');
        assert.equal(moment.duration({seconds: 45}).humanize(),  'a minute',      '45 seconds = a minute');
        assert.equal(moment.duration({seconds: 89}).humanize(),  'a minute',      '89 seconds = a minute');
        assert.equal(moment.duration({seconds: 90}).humanize(),  '2 minutes',     '90 seconds = 2 minutes');
        assert.equal(moment.duration({minutes: 44}).humanize(),  '44 minutes',    '44 minutes = 44 minutes');
        assert.equal(moment.duration({minutes: 45}).humanize(),  'an hour',       '45 minutes = an hour');
        assert.equal(moment.duration({minutes: 89}).humanize(),  'an hour',       '89 minutes = an hour');
        assert.equal(moment.duration({minutes: 90}).humanize(),  '2 hours',       '90 minutes = 2 hours');
        assert.equal(moment.duration({hours: 5}).humanize(),     '5 hours',       '5 hours = 5 hours');
        assert.equal(moment.duration({hours: 21}).humanize(),    '21 hours',      '21 hours = 21 hours');
        assert.equal(moment.duration({hours: 22}).humanize(),    'a day',         '22 hours = a day');
        assert.equal(moment.duration({hours: 35}).humanize(),    'a day',         '35 hours = a day');
        assert.equal(moment.duration({hours: 36}).humanize(),    '2 days',        '36 hours = 2 days');
        assert.equal(moment.duration({days: 1}).humanize(),      'a day',         '1 day = a day');
        assert.equal(moment.duration({days: 5}).humanize(),      '5 days',        '5 days = 5 days');
        assert.equal(moment.duration({weeks: 1}).humanize(),     '7 days',        '1 week = 7 days');
        assert.equal(moment.duration({days: 25}).humanize(),     '25 days',       '25 days = 25 days');
        assert.equal(moment.duration({days: 26}).humanize(),     'a month',       '26 days = a month');
        assert.equal(moment.duration({days: 30}).humanize(),     'a month',       '30 days = a month');
        assert.equal(moment.duration({days: 45}).humanize(),     'a month',       '45 days = a month');
        assert.equal(moment.duration({days: 46}).humanize(),     '2 months',      '46 days = 2 months');
        assert.equal(moment.duration({days: 74}).humanize(),     '2 months',      '74 days = 2 months');
        assert.equal(moment.duration({days: 77}).humanize(),     '3 months',      '77 days = 3 months');
        assert.equal(moment.duration({months: 1}).humanize(),    'a month',       '1 month = a month');
        assert.equal(moment.duration({months: 5}).humanize(),    '5 months',      '5 months = 5 months');
        assert.equal(moment.duration({days: 344}).humanize(),    'a year',        '344 days = a year');
        assert.equal(moment.duration({days: 345}).humanize(),    'a year',        '345 days = a year');
        assert.equal(moment.duration({days: 547}).humanize(),    'a year',        '547 days = a year');
        assert.equal(moment.duration({days: 548}).humanize(),    '2 years',       '548 days = 2 years');
        assert.equal(moment.duration({years: 1}).humanize(),     'a year',        '1 year = a year');
        assert.equal(moment.duration({years: 5}).humanize(),     '5 years',       '5 years = 5 years');
        assert.equal(moment.duration(7200000).humanize(),        '2 hours',       '7200000 = 2 minutes');
    });

    test('humanize duration with suffix', function (assert) {
        moment.locale('en');
        assert.equal(moment.duration({seconds:  44}).humanize(true),  'in a few seconds', '44 seconds = a few seconds');
        assert.equal(moment.duration({seconds: -44}).humanize(true),  'a few seconds ago', '44 seconds = a few seconds');
    });

    test('bubble value up', function (assert) {
        assert.equal(moment.duration({milliseconds: 61001}).milliseconds(), 1, '61001 milliseconds has 1 millisecond left over');
        assert.equal(moment.duration({milliseconds: 61001}).seconds(),      1, '61001 milliseconds has 1 second left over');
        assert.equal(moment.duration({milliseconds: 61001}).minutes(),      1, '61001 milliseconds has 1 minute left over');

        assert.equal(moment.duration({minutes: 350}).minutes(), 50, '350 minutes has 50 minutes left over');
        assert.equal(moment.duration({minutes: 350}).hours(),   5,  '350 minutes has 5 hours left over');
    });

    test('clipping', function (assert) {
        assert.equal(moment.duration({months: 11}).months(), 11, '11 months is 11 months');
        assert.equal(moment.duration({months: 11}).years(),  0,  '11 months makes no year');
        assert.equal(moment.duration({months: 12}).months(), 0,  '12 months is 0 months left over');
        assert.equal(moment.duration({months: 12}).years(),  1,  '12 months makes 1 year');
        assert.equal(moment.duration({months: 13}).months(), 1,  '13 months is 1 month left over');
        assert.equal(moment.duration({months: 13}).years(),  1,  '13 months makes 1 year');

        assert.equal(moment.duration({days: 30}).days(),   30, '30 days is 30 days');
        assert.equal(moment.duration({days: 30}).months(), 0,  '30 days makes no month');
        assert.equal(moment.duration({days: 31}).days(),   0,  '31 days is 0 days left over');
        assert.equal(moment.duration({days: 31}).months(), 1,  '31 days is a month');
        assert.equal(moment.duration({days: 32}).days(),   1,  '32 days is 1 day left over');
        assert.equal(moment.duration({days: 32}).months(), 1,  '32 days is a month');

        assert.equal(moment.duration({hours: 23}).hours(), 23, '23 hours is 23 hours');
        assert.equal(moment.duration({hours: 23}).days(),  0,  '23 hours makes no day');
        assert.equal(moment.duration({hours: 24}).hours(), 0,  '24 hours is 0 hours left over');
        assert.equal(moment.duration({hours: 24}).days(),  1,  '24 hours makes 1 day');
        assert.equal(moment.duration({hours: 25}).hours(), 1,  '25 hours is 1 hour left over');
        assert.equal(moment.duration({hours: 25}).days(),  1,  '25 hours makes 1 day');
    });

    test('bubbling consistency', function (assert) {
        var days = 0, months = 0, newDays, newMonths, totalDays, d;
        for (totalDays = 1; totalDays <= 500; ++totalDays) {
            d = moment.duration(totalDays, 'days');
            newDays = d.days();
            newMonths = d.months() + d.years() * 12;
            assert.ok(
                    (months === newMonths && days + 1 === newDays) ||
                    (months + 1 === newMonths && newDays === 0),
                    'consistent total days ' + totalDays +
                    ' was ' + months + ' ' + days +
                    ' now ' + newMonths + ' ' + newDays);
            days = newDays;
            months = newMonths;
        }
    });

    test('effective equivalency', function (assert) {
        assert.deepEqual(moment.duration({seconds: 1})._data,  moment.duration({milliseconds: 1000})._data, '1 second is the same as 1000 milliseconds');
        assert.deepEqual(moment.duration({seconds: 60})._data, moment.duration({minutes: 1})._data,         '1 minute is the same as 60 seconds');
        assert.deepEqual(moment.duration({minutes: 60})._data, moment.duration({hours: 1})._data,           '1 hour is the same as 60 minutes');
        assert.deepEqual(moment.duration({hours: 24})._data,   moment.duration({days: 1})._data,            '1 day is the same as 24 hours');
        assert.deepEqual(moment.duration({days: 7})._data,     moment.duration({weeks: 1})._data,           '1 week is the same as 7 days');
        assert.deepEqual(moment.duration({days: 31})._data,    moment.duration({months: 1})._data,          '1 month is the same as 30 days');
        assert.deepEqual(moment.duration({months: 12})._data,  moment.duration({years: 1})._data,           '1 years is the same as 12 months');
    });

    test('asGetters', function (assert) {
        // 400 years have exactly 146097 days

        // years
        assert.equal(moment.duration(1, 'year').asYears(),            1,           '1 year as years');
        assert.equal(moment.duration(1, 'year').asMonths(),           12,          '1 year as months');
        assert.equal(moment.duration(400, 'year').asMonths(),         4800,        '400 years as months');
        assert.equal(moment.duration(1, 'year').asWeeks().toFixed(3), 52.143,      '1 year as weeks');
        assert.equal(moment.duration(1, 'year').asDays(),             365,         '1 year as days');
        assert.equal(moment.duration(2, 'year').asDays(),             730,         '2 years as days');
        assert.equal(moment.duration(3, 'year').asDays(),             1096,        '3 years as days');
        assert.equal(moment.duration(4, 'year').asDays(),             1461,        '4 years as days');
        assert.equal(moment.duration(400, 'year').asDays(),           146097,      '400 years as days');
        assert.equal(moment.duration(1, 'year').asHours(),            8760,        '1 year as hours');
        assert.equal(moment.duration(1, 'year').asMinutes(),          525600,      '1 year as minutes');
        assert.equal(moment.duration(1, 'year').asSeconds(),          31536000,    '1 year as seconds');
        assert.equal(moment.duration(1, 'year').asMilliseconds(),     31536000000, '1 year as milliseconds');

        // months
        assert.equal(moment.duration(1, 'month').asYears().toFixed(4), 0.0833,     '1 month as years');
        assert.equal(moment.duration(1, 'month').asMonths(),           1,          '1 month as months');
        assert.equal(moment.duration(1, 'month').asWeeks().toFixed(3), 4.286,      '1 month as weeks');
        assert.equal(moment.duration(1, 'month').asDays(),             30,         '1 month as days');
        assert.equal(moment.duration(2, 'month').asDays(),             61,         '2 months as days');
        assert.equal(moment.duration(3, 'month').asDays(),             91,         '3 months as days');
        assert.equal(moment.duration(4, 'month').asDays(),             122,        '4 months as days');
        assert.equal(moment.duration(5, 'month').asDays(),             152,        '5 months as days');
        assert.equal(moment.duration(6, 'month').asDays(),             183,        '6 months as days');
        assert.equal(moment.duration(7, 'month').asDays(),             213,        '7 months as days');
        assert.equal(moment.duration(8, 'month').asDays(),             243,        '8 months as days');
        assert.equal(moment.duration(9, 'month').asDays(),             274,        '9 months as days');
        assert.equal(moment.duration(10, 'month').asDays(),            304,        '10 months as days');
        assert.equal(moment.duration(11, 'month').asDays(),            335,        '11 months as days');
        assert.equal(moment.duration(12, 'month').asDays(),            365,        '12 months as days');
        assert.equal(moment.duration(24, 'month').asDays(),            730,        '24 months as days');
        assert.equal(moment.duration(36, 'month').asDays(),            1096,       '36 months as days');
        assert.equal(moment.duration(48, 'month').asDays(),            1461,       '48 months as days');
        assert.equal(moment.duration(4800, 'month').asDays(),          146097,     '4800 months as days');
        assert.equal(moment.duration(1, 'month').asHours(),            720,        '1 month as hours');
        assert.equal(moment.duration(1, 'month').asMinutes(),          43200,      '1 month as minutes');
        assert.equal(moment.duration(1, 'month').asSeconds(),          2592000,    '1 month as seconds');
        assert.equal(moment.duration(1, 'month').asMilliseconds(),     2592000000, '1 month as milliseconds');

        // weeks
        assert.equal(moment.duration(1, 'week').asYears().toFixed(4),  0.0192,    '1 week as years');
        assert.equal(moment.duration(1, 'week').asMonths().toFixed(3), 0.230,     '1 week as months');
        assert.equal(moment.duration(1, 'week').asWeeks(),             1,         '1 week as weeks');
        assert.equal(moment.duration(1, 'week').asDays(),              7,         '1 week as days');
        assert.equal(moment.duration(1, 'week').asHours(),             168,       '1 week as hours');
        assert.equal(moment.duration(1, 'week').asMinutes(),           10080,     '1 week as minutes');
        assert.equal(moment.duration(1, 'week').asSeconds(),           604800,    '1 week as seconds');
        assert.equal(moment.duration(1, 'week').asMilliseconds(),      604800000, '1 week as milliseconds');

        // days
        assert.equal(moment.duration(1, 'day').asYears().toFixed(4),  0.0027,   '1 day as years');
        assert.equal(moment.duration(1, 'day').asMonths().toFixed(3), 0.033,    '1 day as months');
        assert.equal(moment.duration(1, 'day').asWeeks().toFixed(3),  0.143,    '1 day as weeks');
        assert.equal(moment.duration(1, 'day').asDays(),              1,        '1 day as days');
        assert.equal(moment.duration(1, 'day').asHours(),             24,       '1 day as hours');
        assert.equal(moment.duration(1, 'day').asMinutes(),           1440,     '1 day as minutes');
        assert.equal(moment.duration(1, 'day').asSeconds(),           86400,    '1 day as seconds');
        assert.equal(moment.duration(1, 'day').asMilliseconds(),      86400000, '1 day as milliseconds');

        // hours
        assert.equal(moment.duration(1, 'hour').asYears().toFixed(6),  0.000114, '1 hour as years');
        assert.equal(moment.duration(1, 'hour').asMonths().toFixed(5), 0.00137,  '1 hour as months');
        assert.equal(moment.duration(1, 'hour').asWeeks().toFixed(5),  0.00595,  '1 hour as weeks');
        assert.equal(moment.duration(1, 'hour').asDays().toFixed(4),   0.0417,   '1 hour as days');
        assert.equal(moment.duration(1, 'hour').asHours(),             1,        '1 hour as hours');
        assert.equal(moment.duration(1, 'hour').asMinutes(),           60,       '1 hour as minutes');
        assert.equal(moment.duration(1, 'hour').asSeconds(),           3600,     '1 hour as seconds');
        assert.equal(moment.duration(1, 'hour').asMilliseconds(),      3600000,  '1 hour as milliseconds');

        // minutes
        assert.equal(moment.duration(1, 'minute').asYears().toFixed(8),  0.00000190, '1 minute as years');
        assert.equal(moment.duration(1, 'minute').asMonths().toFixed(7), 0.0000228,  '1 minute as months');
        assert.equal(moment.duration(1, 'minute').asWeeks().toFixed(7),  0.0000992,  '1 minute as weeks');
        assert.equal(moment.duration(1, 'minute').asDays().toFixed(6),   0.000694,   '1 minute as days');
        assert.equal(moment.duration(1, 'minute').asHours().toFixed(4),  0.0167,     '1 minute as hours');
        assert.equal(moment.duration(1, 'minute').asMinutes(),           1,          '1 minute as minutes');
        assert.equal(moment.duration(1, 'minute').asSeconds(),           60,         '1 minute as seconds');
        assert.equal(moment.duration(1, 'minute').asMilliseconds(),      60000,      '1 minute as milliseconds');

        // seconds
        assert.equal(moment.duration(1, 'second').asYears().toFixed(10),  0.0000000317, '1 second as years');
        assert.equal(moment.duration(1, 'second').asMonths().toFixed(9),  0.000000380,  '1 second as months');
        assert.equal(moment.duration(1, 'second').asWeeks().toFixed(8),   0.00000165,   '1 second as weeks');
        assert.equal(moment.duration(1, 'second').asDays().toFixed(7),    0.0000116,    '1 second as days');
        assert.equal(moment.duration(1, 'second').asHours().toFixed(6),   0.000278,     '1 second as hours');
        assert.equal(moment.duration(1, 'second').asMinutes().toFixed(4), 0.0167,       '1 second as minutes');
        assert.equal(moment.duration(1, 'second').asSeconds(),            1,            '1 second as seconds');
        assert.equal(moment.duration(1, 'second').asMilliseconds(),       1000,         '1 second as milliseconds');

        // milliseconds
        assert.equal(moment.duration(1, 'millisecond').asYears().toFixed(13),  0.0000000000317, '1 millisecond as years');
        assert.equal(moment.duration(1, 'millisecond').asMonths().toFixed(12), 0.000000000380,  '1 millisecond as months');
        assert.equal(moment.duration(1, 'millisecond').asWeeks().toFixed(11),  0.00000000165,   '1 millisecond as weeks');
        assert.equal(moment.duration(1, 'millisecond').asDays().toFixed(10),   0.0000000116,    '1 millisecond as days');
        assert.equal(moment.duration(1, 'millisecond').asHours().toFixed(9),   0.000000278,     '1 millisecond as hours');
        assert.equal(moment.duration(1, 'millisecond').asMinutes().toFixed(7), 0.0000167,       '1 millisecond as minutes');
        assert.equal(moment.duration(1, 'millisecond').asSeconds(),            0.001,           '1 millisecond as seconds');
        assert.equal(moment.duration(1, 'millisecond').asMilliseconds(),       1,               '1 millisecond as milliseconds');
    });

    test('as getters for small units', function (assert) {
        var dS = moment.duration(1, 'milliseconds'),
            ds = moment.duration(3, 'seconds'),
            dm = moment.duration(13, 'minutes');

        // Tests for issue #1867.
        // Floating point errors for small duration units were introduced in version 2.8.0.
        assert.equal(dS.as('milliseconds'), 1, 'as("milliseconds")');
        assert.equal(dS.asMilliseconds(),   1, 'asMilliseconds()');
        assert.equal(ds.as('seconds'),      3, 'as("seconds")');
        assert.equal(ds.asSeconds(),        3, 'asSeconds()');
        assert.equal(dm.as('minutes'),      13, 'as("minutes")');
        assert.equal(dm.asMinutes(),        13, 'asMinutes()');
    });

    test('isDuration', function (assert) {
        assert.ok(moment.isDuration(moment.duration(12345678)), 'correctly says true');
        assert.ok(!moment.isDuration(moment()), 'moment object is not a duration');
        assert.ok(!moment.isDuration({milliseconds: 1}), 'plain object is not a duration');
    });

    test('add', function (assert) {
        var d = moment.duration({months: 4, weeks: 3, days: 2});
        // for some reason, d._data._months does not get updated; use d._months instead.
        assert.equal(d.add(1, 'month')._months, 5, 'Add months');
        assert.equal(d.add(5, 'days')._days, 28, 'Add days');
        assert.equal(d.add(10000)._milliseconds, 10000, 'Add milliseconds');
        assert.equal(d.add({h: 23, m: 59})._milliseconds, 23 * 60 * 60 * 1000 + 59 * 60 * 1000 + 10000, 'Add hour:minute');
    });

    test('add and bubble', function (assert) {
        var d;

        assert.equal(moment.duration(1, 'second').add(1000, 'milliseconds').seconds(), 2, 'Adding milliseconds should bubble up to seconds');
        assert.equal(moment.duration(1, 'minute').add(60, 'second').minutes(), 2, 'Adding seconds should bubble up to minutes');
        assert.equal(moment.duration(1, 'hour').add(60, 'minutes').hours(), 2, 'Adding minutes should bubble up to hours');
        assert.equal(moment.duration(1, 'day').add(24, 'hours').days(), 2, 'Adding hours should bubble up to days');

        d = moment.duration(-1, 'day').add(1, 'hour');
        assert.equal(d.hours(), -23, '-1 day + 1 hour == -23 hour (component)');
        assert.equal(d.asHours(), -23, '-1 day + 1 hour == -23 hours');

        d = moment.duration(-1, 'year').add(1, 'day');
        assert.equal(d.days(), -30, '- 1 year + 1 day == -30 days (component)');
        assert.equal(d.months(), -11, '- 1 year + 1 day == -11 months (component)');
        assert.equal(d.years(), 0, '- 1 year + 1 day == 0 years (component)');
        assert.equal(d.asDays(), -364, '- 1 year + 1 day == -364 days');

        d = moment.duration(-1, 'year').add(1, 'hour');
        assert.equal(d.hours(), -23, '- 1 year + 1 hour == -23 hours (component)');
        assert.equal(d.days(), -30, '- 1 year + 1 hour == -30 days (component)');
        assert.equal(d.months(), -11, '- 1 year + 1 hour == -11 months (component)');
        assert.equal(d.years(), 0, '- 1 year + 1 hour == 0 years (component)');
    });

    test('subtract and bubble', function (assert) {
        var d;

        assert.equal(moment.duration(2, 'second').subtract(1000, 'milliseconds').seconds(), 1, 'Subtracting milliseconds should bubble up to seconds');
        assert.equal(moment.duration(2, 'minute').subtract(60, 'second').minutes(), 1, 'Subtracting seconds should bubble up to minutes');
        assert.equal(moment.duration(2, 'hour').subtract(60, 'minutes').hours(), 1, 'Subtracting minutes should bubble up to hours');
        assert.equal(moment.duration(2, 'day').subtract(24, 'hours').days(), 1, 'Subtracting hours should bubble up to days');

        d = moment.duration(1, 'day').subtract(1, 'hour');
        assert.equal(d.hours(), 23, '1 day - 1 hour == 23 hour (component)');
        assert.equal(d.asHours(), 23, '1 day - 1 hour == 23 hours');

        d = moment.duration(1, 'year').subtract(1, 'day');
        assert.equal(d.days(), 30, '1 year - 1 day == 30 days (component)');
        assert.equal(d.months(), 11, '1 year - 1 day == 11 months (component)');
        assert.equal(d.years(), 0, '1 year - 1 day == 0 years (component)');
        assert.equal(d.asDays(), 364, '1 year - 1 day == 364 days');

        d = moment.duration(1, 'year').subtract(1, 'hour');
        assert.equal(d.hours(), 23, '1 year - 1 hour == 23 hours (component)');
        assert.equal(d.days(), 30, '1 year - 1 hour == 30 days (component)');
        assert.equal(d.months(), 11, '1 year - 1 hour == 11 months (component)');
        assert.equal(d.years(), 0, '1 year - 1 hour == 0 years (component)');
    });

    test('subtract', function (assert) {
        var d = moment.duration({months: 2, weeks: 2, days: 0, hours: 5});
        // for some reason, d._data._months does not get updated; use d._months instead.
        assert.equal(d.subtract(1, 'months')._months, 1, 'Subtract months');
        assert.equal(d.subtract(14, 'days')._days, 0, 'Subtract days');
        assert.equal(d.subtract(10000)._milliseconds, 5 * 60 * 60 * 1000 - 10000, 'Subtract milliseconds');
        assert.equal(d.subtract({h: 1, m: 59})._milliseconds, 3 * 60 * 60 * 1000 + 1 * 60 * 1000 - 10000, 'Subtract hour:minute');
    });

    test('JSON.stringify duration', function (assert) {
        var d = moment.duration(1024, 'h');

        assert.equal(JSON.stringify(d), '"' + d.toISOString() + '"', 'JSON.stringify on duration should return ISO string');
    });

    test('duration plugins', function (assert) {
        var durationObject = moment.duration();
        moment.duration.fn.foo = function (arg) {
            assert.equal(this, durationObject);
            assert.equal(arg, 5);
        };
        durationObject.foo(5);
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('duration from moments');

    test('pure year diff', function (assert) {
        var m1 = moment('2012-01-01T00:00:00.000Z'),
            m2 = moment('2013-01-01T00:00:00.000Z');

        assert.equal(moment.duration({from: m1, to: m2}).as('years'), 1, 'year moment difference');
        assert.equal(moment.duration({from: m2, to: m1}).as('years'), -1, 'negative year moment difference');
    });

    test('month and day diff', function (assert) {
        var m1 = moment('2012-01-15T00:00:00.000Z'),
            m2 = moment('2012-02-17T00:00:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.get('days'), 2);
        assert.equal(d.get('months'), 1);
    });

    test('day diff, separate months', function (assert) {
        var m1 = moment('2012-01-15T00:00:00.000Z'),
            m2 = moment('2012-02-13T00:00:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.as('days'), 29);
    });

    test('hour diff', function (assert) {
        var m1 = moment('2012-01-15T17:00:00.000Z'),
            m2 = moment('2012-01-16T03:00:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.as('hours'), 10);
    });

    test('minute diff', function (assert) {
        var m1 = moment('2012-01-15T17:45:00.000Z'),
            m2 = moment('2012-01-16T03:15:00.000Z'),
            d = moment.duration({from: m1, to: m2});

        assert.equal(d.as('hours'), 9.5);
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('format');

    test('format YY', function (assert) {
        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));
        assert.equal(b.format('YY'), '09', 'YY ---> 09');
    });

    test('format escape brackets', function (assert) {
        moment.locale('en');

        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 125));
        assert.equal(b.format('[day]'), 'day', 'Single bracket');
        assert.equal(b.format('[day] YY [YY]'), 'day 09 YY', 'Double bracket');
        assert.equal(b.format('[YY'), '[09', 'Un-ended bracket');
        assert.equal(b.format('[[YY]]'), '[YY]', 'Double nested brackets');
        assert.equal(b.format('[[]'), '[', 'Escape open bracket');
        assert.equal(b.format('[Last]'), 'Last', 'localized tokens');
        assert.equal(b.format('[L] L'), 'L 02/14/2009', 'localized tokens with escaped localized tokens');
        assert.equal(b.format('[L LL LLL LLLL aLa]'), 'L LL LLL LLLL aLa', 'localized tokens with escaped localized tokens');
        assert.equal(b.format('[LLL] LLL'), 'LLL February 14, 2009 3:25 PM', 'localized tokens with escaped localized tokens (recursion)');
        assert.equal(b.format('YYYY[\n]DD[\n]'), '2009\n14\n', 'Newlines');
    });

    test('handle negative years', function (assert) {
        moment.locale('en');
        assert.equal(moment.utc().year(-1).format('YY'), '-01', 'YY with negative year');
        assert.equal(moment.utc().year(-1).format('YYYY'), '-0001', 'YYYY with negative year');
        assert.equal(moment.utc().year(-12).format('YY'), '-12', 'YY with negative year');
        assert.equal(moment.utc().year(-12).format('YYYY'), '-0012', 'YYYY with negative year');
        assert.equal(moment.utc().year(-123).format('YY'), '-23', 'YY with negative year');
        assert.equal(moment.utc().year(-123).format('YYYY'), '-0123', 'YYYY with negative year');
        assert.equal(moment.utc().year(-1234).format('YY'), '-34', 'YY with negative year');
        assert.equal(moment.utc().year(-1234).format('YYYY'), '-1234', 'YYYY with negative year');
        assert.equal(moment.utc().year(-12345).format('YY'), '-45', 'YY with negative year');
        assert.equal(moment.utc().year(-12345).format('YYYY'), '-12345', 'YYYY with negative year');
    });

    test('format milliseconds', function (assert) {
        var b = moment(new Date(2009, 1, 14, 15, 25, 50, 123));
        assert.equal(b.format('S'), '1', 'Deciseconds');
        assert.equal(b.format('SS'), '12', 'Centiseconds');
        assert.equal(b.format('SSS'), '123', 'Milliseconds');
        b.milliseconds(789);
        assert.equal(b.format('S'), '7', 'Deciseconds');
        assert.equal(b.format('SS'), '78', 'Centiseconds');
        assert.equal(b.format('SSS'), '789', 'Milliseconds');
    });

    test('format timezone', function (assert) {
        var b = moment(new Date(2010, 1, 14, 15, 25, 50, 125));
        assert.ok(b.format('Z').match(/^[\+\-]\d\d:\d\d$/), b.format('Z') + ' should be something like \'+07:30\'');
        assert.ok(b.format('ZZ').match(/^[\+\-]\d{4}$/), b.format('ZZ') + ' should be something like \'+0700\'');
    });

    test('format multiple with utc offset', function (assert) {
        var b = moment('2012-10-08 -1200', ['YYYY-MM-DD HH:mm ZZ', 'YYYY-MM-DD ZZ', 'YYYY-MM-DD']);
        assert.equal(b.format('YYYY-MM'), '2012-10', 'Parsing multiple formats should not crash with different sized formats');
    });

    test('isDST', function (assert) {
        var janOffset = new Date(2011, 0, 1).getTimezoneOffset(),
            julOffset = new Date(2011, 6, 1).getTimezoneOffset(),
            janIsDst = janOffset < julOffset,
            julIsDst = julOffset < janOffset,
            jan1 = moment([2011]),
            jul1 = moment([2011, 6]);

        if (janIsDst && julIsDst) {
            assert.ok(0, 'January and July cannot both be in DST');
            assert.ok(0, 'January and July cannot both be in DST');
        } else if (janIsDst) {
            assert.ok(jan1.isDST(), 'January 1 is DST');
            assert.ok(!jul1.isDST(), 'July 1 is not DST');
        } else if (julIsDst) {
            assert.ok(!jan1.isDST(), 'January 1 is not DST');
            assert.ok(jul1.isDST(), 'July 1 is DST');
        } else {
            assert.ok(!jan1.isDST(), 'January 1 is not DST');
            assert.ok(!jul1.isDST(), 'July 1 is not DST');
        }
    });

    test('unix timestamp', function (assert) {
        var m = moment('1234567890.123', 'X');
        assert.equal(m.format('X'), '1234567890', 'unix timestamp without milliseconds');
        assert.equal(m.format('X.S'), '1234567890.1', 'unix timestamp with deciseconds');
        assert.equal(m.format('X.SS'), '1234567890.12', 'unix timestamp with centiseconds');
        assert.equal(m.format('X.SSS'), '1234567890.123', 'unix timestamp with milliseconds');

        m = moment(1234567890.123, 'X');
        assert.equal(m.format('X'), '1234567890', 'unix timestamp as integer');
    });

    test('unix offset milliseconds', function (assert) {
        var m = moment('1234567890123', 'x');
        assert.equal(m.format('x'), '1234567890123', 'unix offset in milliseconds');

        m = moment(1234567890123, 'x');
        assert.equal(m.format('x'), '1234567890123', 'unix offset in milliseconds as integer');
    });

    test('utcOffset sanity checks', function (assert) {
        assert.equal(moment().utcOffset() % 15, 0,
                'utc offset should be a multiple of 15 (was ' + moment().utcOffset() + ')');

        assert.equal(moment().utcOffset(), -(new Date()).getTimezoneOffset(),
            'utcOffset should return the opposite of getTimezoneOffset');
    });

    test('default format', function (assert) {
        var isoRegex = /\d{4}.\d\d.\d\dT\d\d.\d\d.\d\d[\+\-]\d\d:\d\d/;
        assert.ok(isoRegex.exec(moment().format()), 'default format (' + moment().format() + ') should match ISO');
    });

    test('toJSON', function (assert) {
        var supportsJson = typeof JSON !== 'undefined' && JSON.stringify && JSON.stringify.call,
            date = moment('2012-10-09T21:30:40.678+0100');

        assert.equal(date.toJSON(), '2012-10-09T20:30:40.678Z', 'should output ISO8601 on moment.fn.toJSON');

        if (supportsJson) {
            assert.equal(JSON.stringify({
                date : date
            }), '{"date":"2012-10-09T20:30:40.678Z"}', 'should output ISO8601 on JSON.stringify');
        }
    });

    test('toISOString', function (assert) {
        var date = moment.utc('2012-10-09T20:30:40.678');

        assert.equal(date.toISOString(), '2012-10-09T20:30:40.678Z', 'should output ISO8601 on moment.fn.toISOString');

        // big years
        date = moment.utc('+020123-10-09T20:30:40.678');
        assert.equal(date.toISOString(), '+020123-10-09T20:30:40.678Z', 'ISO8601 format on big positive year');
        // negative years
        date = moment.utc('-000001-10-09T20:30:40.678');
        assert.equal(date.toISOString(), '-000001-10-09T20:30:40.678Z', 'ISO8601 format on negative year');
        // big negative years
        date = moment.utc('-020123-10-09T20:30:40.678');
        assert.equal(date.toISOString(), '-020123-10-09T20:30:40.678Z', 'ISO8601 format on big negative year');
    });

    test('long years', function (assert) {
        assert.equal(moment.utc().year(2).format('YYYYYY'), '+000002', 'small year with YYYYYY');
        assert.equal(moment.utc().year(2012).format('YYYYYY'), '+002012', 'regular year with YYYYYY');
        assert.equal(moment.utc().year(20123).format('YYYYYY'), '+020123', 'big year with YYYYYY');

        assert.equal(moment.utc().year(-1).format('YYYYYY'), '-000001', 'small negative year with YYYYYY');
        assert.equal(moment.utc().year(-2012).format('YYYYYY'), '-002012', 'negative year with YYYYYY');
        assert.equal(moment.utc().year(-20123).format('YYYYYY'), '-020123', 'big negative year with YYYYYY');
    });

    test('iso week formats', function (assert) {
        // http://en.wikipedia.org/wiki/ISO_week_date
        var cases = {
            '2005-01-02': '2004-53',
            '2005-12-31': '2005-52',
            '2007-01-01': '2007-01',
            '2007-12-30': '2007-52',
            '2007-12-31': '2008-01',
            '2008-01-01': '2008-01',
            '2008-12-28': '2008-52',
            '2008-12-29': '2009-01',
            '2008-12-30': '2009-01',
            '2008-12-31': '2009-01',
            '2009-01-01': '2009-01',
            '2009-12-31': '2009-53',
            '2010-01-01': '2009-53',
            '2010-01-02': '2009-53',
            '2010-01-03': '2009-53',
            '404-12-31': '0404-53',
            '405-12-31': '0405-52'
        }, i, isoWeek, formatted2, formatted1;

        for (i in cases) {
            isoWeek = cases[i].split('-').pop();
            formatted2 = moment(i, 'YYYY-MM-DD').format('WW');
            assert.equal(isoWeek, formatted2, i + ': WW should be ' + isoWeek + ', but ' + formatted2);
            isoWeek = isoWeek.replace(/^0+/, '');
            formatted1 = moment(i, 'YYYY-MM-DD').format('W');
            assert.equal(isoWeek, formatted1, i + ': W should be ' + isoWeek + ', but ' + formatted1);
        }
    });

    test('iso week year formats', function (assert) {
        // http://en.wikipedia.org/wiki/ISO_week_date
        var cases = {
            '2005-01-02': '2004-53',
            '2005-12-31': '2005-52',
            '2007-01-01': '2007-01',
            '2007-12-30': '2007-52',
            '2007-12-31': '2008-01',
            '2008-01-01': '2008-01',
            '2008-12-28': '2008-52',
            '2008-12-29': '2009-01',
            '2008-12-30': '2009-01',
            '2008-12-31': '2009-01',
            '2009-01-01': '2009-01',
            '2009-12-31': '2009-53',
            '2010-01-01': '2009-53',
            '2010-01-02': '2009-53',
            '2010-01-03': '2009-53',
            '404-12-31': '0404-53',
            '405-12-31': '0405-52'
        }, i, isoWeekYear, formatted5, formatted4, formatted2;

        for (i in cases) {
            isoWeekYear = cases[i].split('-')[0];
            formatted5 = moment(i, 'YYYY-MM-DD').format('GGGGG');
            assert.equal('0' + isoWeekYear, formatted5, i + ': GGGGG should be ' + isoWeekYear + ', but ' + formatted5);
            formatted4 = moment(i, 'YYYY-MM-DD').format('GGGG');
            assert.equal(isoWeekYear, formatted4, i + ': GGGG should be ' + isoWeekYear + ', but ' + formatted4);
            formatted2 = moment(i, 'YYYY-MM-DD').format('GG');
            assert.equal(isoWeekYear.slice(2, 4), formatted2, i + ': GG should be ' + isoWeekYear + ', but ' + formatted2);
        }
    });

    test('week year formats', function (assert) {
        // http://en.wikipedia.org/wiki/ISO_week_date
        var cases = {
            '2005-01-02': '2004-53',
            '2005-12-31': '2005-52',
            '2007-01-01': '2007-01',
            '2007-12-30': '2007-52',
            '2007-12-31': '2008-01',
            '2008-01-01': '2008-01',
            '2008-12-28': '2008-52',
            '2008-12-29': '2009-01',
            '2008-12-30': '2009-01',
            '2008-12-31': '2009-01',
            '2009-01-01': '2009-01',
            '2009-12-31': '2009-53',
            '2010-01-01': '2009-53',
            '2010-01-02': '2009-53',
            '2010-01-03': '2009-53',
            '404-12-31': '0404-53',
            '405-12-31': '0405-52'
        }, i, isoWeekYear, formatted5, formatted4, formatted2;

        moment.locale('dow:1,doy:4', {week: {dow: 1, doy: 4}});

        for (i in cases) {
            isoWeekYear = cases[i].split('-')[0];
            formatted5 = moment(i, 'YYYY-MM-DD').format('ggggg');
            assert.equal('0' + isoWeekYear, formatted5, i + ': ggggg should be ' + isoWeekYear + ', but ' + formatted5);
            formatted4 = moment(i, 'YYYY-MM-DD').format('gggg');
            assert.equal(isoWeekYear, formatted4, i + ': gggg should be ' + isoWeekYear + ', but ' + formatted4);
            formatted2 = moment(i, 'YYYY-MM-DD').format('gg');
            assert.equal(isoWeekYear.slice(2, 4), formatted2, i + ': gg should be ' + isoWeekYear + ', but ' + formatted2);
        }
    });

    test('iso weekday formats', function (assert) {
        assert.equal(moment([1985, 1,  4]).format('E'), '1', 'Feb  4 1985 is Monday    -- 1st day');
        assert.equal(moment([2029, 8, 18]).format('E'), '2', 'Sep 18 2029 is Tuesday   -- 2nd day');
        assert.equal(moment([2013, 3, 24]).format('E'), '3', 'Apr 24 2013 is Wednesday -- 3rd day');
        assert.equal(moment([2015, 2,  5]).format('E'), '4', 'Mar  5 2015 is Thursday  -- 4th day');
        assert.equal(moment([1970, 0,  2]).format('E'), '5', 'Jan  2 1970 is Friday    -- 5th day');
        assert.equal(moment([2001, 4, 12]).format('E'), '6', 'May 12 2001 is Saturday  -- 6th day');
        assert.equal(moment([2000, 0,  2]).format('E'), '7', 'Jan  2 2000 is Sunday    -- 7th day');
    });

    test('weekday formats', function (assert) {
        moment.locale('dow: 3,doy: 5', {week: {dow: 3, doy: 5}});
        assert.equal(moment([1985, 1,  6]).format('e'), '0', 'Feb  6 1985 is Wednesday -- 0th day');
        assert.equal(moment([2029, 8, 20]).format('e'), '1', 'Sep 20 2029 is Thursday  -- 1st day');
        assert.equal(moment([2013, 3, 26]).format('e'), '2', 'Apr 26 2013 is Friday    -- 2nd day');
        assert.equal(moment([2015, 2,  7]).format('e'), '3', 'Mar  7 2015 is Saturday  -- 3nd day');
        assert.equal(moment([1970, 0,  4]).format('e'), '4', 'Jan  4 1970 is Sunday    -- 4th day');
        assert.equal(moment([2001, 4, 14]).format('e'), '5', 'May 14 2001 is Monday    -- 5th day');
        assert.equal(moment([2000, 0,  4]).format('e'), '6', 'Jan  4 2000 is Tuesday   -- 6th day');
    });

    test('toString is just human readable format', function (assert) {
        var b = moment(new Date(2009, 1, 5, 15, 25, 50, 125));
        assert.equal(b.toString(), b.format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ'));
    });

    test('toJSON skips postformat', function (assert) {
        moment.locale('postformat', {
            postformat: function (s) {
                s.replace(/./g, 'X');
            }
        });
        assert.equal(moment.utc([2000, 0, 1]).toJSON(), '2000-01-01T00:00:00.000Z', 'toJSON doesn\'t postformat');
        moment.locale('postformat', null);
    });

    test('calendar day timezone', function (assert) {
        moment.locale('en');
        var zones = [60, -60, 90, -90, 360, -360, 720, -720],
            b = moment().utc().startOf('day').subtract({m : 1}),
            c = moment().local().startOf('day').subtract({m : 1}),
            d = moment().local().startOf('day').subtract({d : 2}),
            i, z, a;

        for (i = 0; i < zones.length; ++i) {
            z = zones[i];
            a = moment().utcOffset(z).startOf('day').subtract({m: 1});
            assert.equal(moment(a).utcOffset(z).calendar(), 'Yesterday at 11:59 PM',
                         'Yesterday at 11:59 PM, not Today, or the wrong time, tz = ' + z);
        }

        assert.equal(moment(b).utc().calendar(), 'Yesterday at 11:59 PM', 'Yesterday at 11:59 PM, not Today, or the wrong time');
        assert.equal(moment(c).local().calendar(), 'Yesterday at 11:59 PM', 'Yesterday at 11:59 PM, not Today, or the wrong time');
        assert.equal(moment(c).local().calendar(d), 'Tomorrow at 11:59 PM', 'Tomorrow at 11:59 PM, not Yesterday, or the wrong time');
    });

    test('calendar with custom formats', function (assert) {
        assert.equal(moment().calendar(null, {sameDay: '[Today]'}), 'Today', 'Today');
        assert.equal(moment().add(1, 'days').calendar(null, {nextDay: '[Tomorrow]'}), 'Tomorrow', 'Tomorrow');
        assert.equal(moment([1985, 1, 4]).calendar(null, {sameElse: 'YYYY-MM-DD'}), '1985-02-04', 'Else');
    });

    test('invalid', function (assert) {
        assert.equal(moment.invalid().format(), 'Invalid date');
        assert.equal(moment.invalid().format('YYYY-MM-DD'), 'Invalid date');
    });

    test('quarter formats', function (assert) {
        assert.equal(moment([1985, 1,  4]).format('Q'), '1', 'Feb  4 1985 is Q1');
        assert.equal(moment([2029, 8, 18]).format('Q'), '3', 'Sep 18 2029 is Q3');
        assert.equal(moment([2013, 3, 24]).format('Q'), '2', 'Apr 24 2013 is Q2');
        assert.equal(moment([2015, 2,  5]).format('Q'), '1', 'Mar  5 2015 is Q1');
        assert.equal(moment([1970, 0,  2]).format('Q'), '1', 'Jan  2 1970 is Q1');
        assert.equal(moment([2001, 11, 12]).format('Q'), '4', 'Dec 12 2001 is Q4');
        assert.equal(moment([2000, 0,  2]).format('[Q]Q-YYYY'), 'Q1-2000', 'Jan  2 2000 is Q1');
    });

    test('full expanded format is returned from abbreviated formats', function (assert) {
        var locales = '';

        locales += 'af ar-ma ar-sa ar-tn ar az be bg bn bo br bs';
        locales += 'ca cs cv cy da de-at de el en-au en-ca en-gb';
        locales += 'en eo es et eu fa fi fo fr-ca fr fy gl he hi';
        locales += 'hr hu hy-am id is it ja jv ka km ko lb lt lv';
        locales += 'me mk ml mr ms-my my nb ne nl nn pl pt-rb pt';
        locales += 'ro ru si sk sl sq sr-cyrl  sr sv ta th tl-ph';
        locales += 'tr tzm-latn tzm   uk uz vi zh-cn zh-tw';

        locales.split(' ').forEach(function (locale) {
            var data, tokens;
            data = moment().locale(locale).localeData()._longDateFormat;
            tokens = Object.keys(data);
            tokens.forEach(function (token) {
                // Check each format string to make sure it does not contain any
                // tokens that need to be expanded.
                tokens.forEach(function (i) {
                    // strip escaped sequences
                    var format = data[i].replace(/(\[[^\]]*\])/g, '');
                    assert.equal(false, !!~format.indexOf(token), 'locale ' + locale + ' contains ' + token + ' in ' + i);
                });
            });
        });
    });

    test('milliseconds', function (assert) {
        var m = moment('123', 'SSS');

        assert.equal(m.format('S'), '1');
        assert.equal(m.format('SS'), '12');
        assert.equal(m.format('SSS'), '123');
        assert.equal(m.format('SSSS'), '1230');
        assert.equal(m.format('SSSSS'), '12300');
        assert.equal(m.format('SSSSSS'), '123000');
        assert.equal(m.format('SSSSSSS'), '1230000');
        assert.equal(m.format('SSSSSSSS'), '12300000');
        assert.equal(m.format('SSSSSSSSS'), '123000000');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('from_to');

    test('from', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.from(start.clone().add(5, 'seconds')),  'a few seconds ago', '5 seconds = a few seconds ago');
        assert.equal(start.from(start.clone().add(1, 'minute')),  'a minute ago', '1 minute = a minute ago');
        assert.equal(start.from(start.clone().add(5, 'minutes')),  '5 minutes ago', '5 minutes = 5 minutes ago');

        assert.equal(start.from(start.clone().subtract(5, 'seconds')),  'in a few seconds', '5 seconds = in a few seconds');
        assert.equal(start.from(start.clone().subtract(1, 'minute')),  'in a minute', '1 minute = in a minute');
        assert.equal(start.from(start.clone().subtract(5, 'minutes')),  'in 5 minutes', '5 minutes = in 5 minutes');
    });

    test('from with absolute duration', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.from(start.clone().add(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.from(start.clone().add(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.from(start.clone().add(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');

        assert.equal(start.from(start.clone().subtract(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.from(start.clone().subtract(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.from(start.clone().subtract(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');
    });

    test('to', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.to(start.clone().subtract(5, 'seconds')),  'a few seconds ago', '5 seconds = a few seconds ago');
        assert.equal(start.to(start.clone().subtract(1, 'minute')),  'a minute ago', '1 minute = a minute ago');
        assert.equal(start.to(start.clone().subtract(5, 'minutes')),  '5 minutes ago', '5 minutes = 5 minutes ago');

        assert.equal(start.to(start.clone().add(5, 'seconds')),  'in a few seconds', '5 seconds = in a few seconds');
        assert.equal(start.to(start.clone().add(1, 'minute')),  'in a minute', '1 minute = in a minute');
        assert.equal(start.to(start.clone().add(5, 'minutes')),  'in 5 minutes', '5 minutes = in 5 minutes');
    });

    test('to with absolute duration', function (assert) {
        var start = moment();
        moment.locale('en');
        assert.equal(start.to(start.clone().add(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.to(start.clone().add(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.to(start.clone().add(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');

        assert.equal(start.to(start.clone().subtract(5, 'seconds'), true),  'a few seconds', '5 seconds = a few seconds');
        assert.equal(start.to(start.clone().subtract(1, 'minute'), true),  'a minute', '1 minute = a minute');
        assert.equal(start.to(start.clone().subtract(5, 'minutes'), true),  '5 minutes', '5 minutes = 5 minutes');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('getters and setters');

    test('getters', function (assert) {
        var a = moment([2011, 9, 12, 6, 7, 8, 9]);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('getters programmatic', function (assert) {
        var a = moment([2011, 9, 12, 6, 7, 8, 9]);
        assert.equal(a.get('year'), 2011, 'year');
        assert.equal(a.get('month'), 9, 'month');
        assert.equal(a.get('date'), 12, 'date');
        assert.equal(a.get('day'), 3, 'day');
        assert.equal(a.get('hour'), 6, 'hour');
        assert.equal(a.get('minute'), 7, 'minute');
        assert.equal(a.get('second'), 8, 'second');
        assert.equal(a.get('milliseconds'), 9, 'milliseconds');

        //actual getters tested elsewhere
        assert.equal(a.get('weekday'), a.weekday(), 'weekday');
        assert.equal(a.get('isoWeekday'), a.isoWeekday(), 'isoWeekday');
        assert.equal(a.get('week'), a.week(), 'week');
        assert.equal(a.get('isoWeek'), a.isoWeek(), 'isoWeek');
        assert.equal(a.get('dayOfYear'), a.dayOfYear(), 'dayOfYear');
    });

    test('setters plural', function (assert) {
        var a = moment();
        a.years(2011);
        a.months(9);
        a.dates(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(9);
        assert.equal(a.years(), 2011, 'years');
        assert.equal(a.months(), 9, 'months');
        assert.equal(a.dates(), 12, 'dates');
        assert.equal(a.days(), 3, 'days');
        assert.equal(a.hours(), 6, 'hours');
        assert.equal(a.minutes(), 7, 'minutes');
        assert.equal(a.seconds(), 8, 'seconds');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('setters singular', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hour(6);
        a.minute(7);
        a.second(8);
        a.millisecond(9);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hour(), 6, 'hour');
        assert.equal(a.minute(), 7, 'minute');
        assert.equal(a.second(), 8, 'second');
        assert.equal(a.millisecond(), 9, 'milliseconds');
    });

    test('setters', function (assert) {
        var a = moment();
        a.year(2011);
        a.month(9);
        a.date(12);
        a.hours(6);
        a.minutes(7);
        a.seconds(8);
        a.milliseconds(9);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');

        // Test month() behavior. See https://github.com/timrwood/moment/pull/822
        a = moment('20130531', 'YYYYMMDD');
        a.month(3);
        assert.equal(a.month(), 3, 'month edge case');
    });

    test('setter programmatic', function (assert) {
        var a = moment();
        a.set('year', 2011);
        a.set('month', 9);
        a.set('date', 12);
        a.set('hours', 6);
        a.set('minutes', 7);
        a.set('seconds', 8);
        a.set('milliseconds', 9);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');

        // Test month() behavior. See https://github.com/timrwood/moment/pull/822
        a = moment('20130531', 'YYYYMMDD');
        a.month(3);
        assert.equal(a.month(), 3, 'month edge case');
    });

    // Disable this, until we weekYear setter is fixed.
    // https://github.com/moment/moment/issues/1379
    // test('setters programatic with weeks', function (assert) {
    //     var a = moment();
    //     a.set('weekYear', 2001);
    //     a.set('week', 49);
    //     a.set('day', 4);
    //     assert.equals(a.weekYear(), 2001);
    //     assert.equals(a.week(), 49);
    //     assert.equals(a.day(), 4);

    //     a.set('weekday', 1);
    //     assert.equals(a.weekday(), 1);

    //     assert.done();
    //},

    // I think this suffers from the same issue as the non-iso version.
    // test('setters programatic with weeks ISO', function (assert) {
    //     var a = moment();
    //     a.set('isoWeekYear', 2001);
    //     a.set('isoWeek', 49);
    //     a.set('isoWeekday', 4);

    //     assert.equals(a.weekYear(), 2001);
    //     assert.equals(a.week(), 49);
    //     assert.equals(a.day(), 4);

    //     assert.done();
    //},

    test('setters strings', function (assert) {
        var a = moment([2012]).locale('en');
        assert.equal(a.clone().day(0).day('Wednesday').day(), 3, 'day full name');
        assert.equal(a.clone().day(0).day('Wed').day(), 3, 'day short name');
        assert.equal(a.clone().day(0).day('We').day(), 3, 'day minimal name');
        assert.equal(a.clone().day(0).day('invalid').day(), 0, 'invalid day name');
        assert.equal(a.clone().month(0).month('April').month(), 3, 'month full name');
        assert.equal(a.clone().month(0).month('Apr').month(), 3, 'month short name');
        assert.equal(a.clone().month(0).month('invalid').month(), 0, 'invalid month name');
    });

    test('setters - falsey values', function (assert) {
        var a = moment();
        // ensure minutes wasn't coincidentally 0 already
        a.minutes(1);
        a.minutes(0);
        assert.equal(a.minutes(), 0, 'falsey value');
    });

    test('chaining setters', function (assert) {
        var a = moment();
        a.year(2011)
         .month(9)
         .date(12)
         .hours(6)
         .minutes(7)
         .seconds(8);
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
    });

    test('setter with multiple unit values', function (assert) {
        var a = moment();
        a.set({
            year: 2011,
            month: 9,
            date: 12,
            hours: 6,
            minutes: 7,
            seconds: 8,
            milliseconds: 9
        });
        assert.equal(a.year(), 2011, 'year');
        assert.equal(a.month(), 9, 'month');
        assert.equal(a.date(), 12, 'date');
        assert.equal(a.day(), 3, 'day');
        assert.equal(a.hours(), 6, 'hour');
        assert.equal(a.minutes(), 7, 'minute');
        assert.equal(a.seconds(), 8, 'second');
        assert.equal(a.milliseconds(), 9, 'milliseconds');
    });

    test('day setter', function (assert) {
        var a = moment([2011, 0, 15]);
        assert.equal(moment(a).day(0).date(), 9, 'set from saturday to sunday');
        assert.equal(moment(a).day(6).date(), 15, 'set from saturday to saturday');
        assert.equal(moment(a).day(3).date(), 12, 'set from saturday to wednesday');

        a = moment([2011, 0, 9]);
        assert.equal(moment(a).day(0).date(), 9, 'set from sunday to sunday');
        assert.equal(moment(a).day(6).date(), 15, 'set from sunday to saturday');
        assert.equal(moment(a).day(3).date(), 12, 'set from sunday to wednesday');

        a = moment([2011, 0, 12]);
        assert.equal(moment(a).day(0).date(), 9, 'set from wednesday to sunday');
        assert.equal(moment(a).day(6).date(), 15, 'set from wednesday to saturday');
        assert.equal(moment(a).day(3).date(), 12, 'set from wednesday to wednesday');

        assert.equal(moment(a).day(-7).date(), 2, 'set from wednesday to last sunday');
        assert.equal(moment(a).day(-1).date(), 8, 'set from wednesday to last saturday');
        assert.equal(moment(a).day(-4).date(), 5, 'set from wednesday to last wednesday');

        assert.equal(moment(a).day(7).date(), 16, 'set from wednesday to next sunday');
        assert.equal(moment(a).day(13).date(), 22, 'set from wednesday to next saturday');
        assert.equal(moment(a).day(10).date(), 19, 'set from wednesday to next wednesday');

        assert.equal(moment(a).day(14).date(), 23, 'set from wednesday to second next sunday');
        assert.equal(moment(a).day(20).date(), 29, 'set from wednesday to second next saturday');
        assert.equal(moment(a).day(17).date(), 26, 'set from wednesday to second next wednesday');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('invalid');

    test('invalid', function (assert) {
        var m = moment.invalid();
        assert.equal(m.isValid(), false);
        assert.equal(m.parsingFlags().userInvalidated, true);
        assert.ok(isNaN(m.valueOf()));
    });

    test('invalid with existing flag', function (assert) {
        var m = moment.invalid({invalidMonth : 'whatchamacallit'});
        assert.equal(m.isValid(), false);
        assert.equal(m.parsingFlags().userInvalidated, false);
        assert.equal(m.parsingFlags().invalidMonth, 'whatchamacallit');
        assert.ok(isNaN(m.valueOf()));
    });

    test('invalid with custom flag', function (assert) {
        var m = moment.invalid({tooBusyWith : 'reiculating splines'});
        assert.equal(m.isValid(), false);
        assert.equal(m.parsingFlags().userInvalidated, false);
        assert.equal(m.parsingFlags().tooBusyWith, 'reiculating splines');
        assert.ok(isNaN(m.valueOf()));
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is after');

    test('is after without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), true, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), true, 'second is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond match');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), true, 'millisecond is earlier');
        assert.equal(m.isAfter(m), false, 'moments are not after themselves');
        assert.equal(+m, +mCopy, 'isAfter second should not change moment');
    });

    test('is after year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');
        assert.equal(m.isAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), false, 'exact start of year');
        assert.equal(m.isAfter(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), false, 'exact end of year');
        assert.equal(m.isAfter(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');
        assert.equal(m.isAfter(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of previous year');
        assert.equal(m.isAfter(moment(new Date(1980, 11, 31, 23, 59, 59, 999)), 'year'), true, 'end of year far before');
        assert.equal(m.isAfter(m, 'year'), false, 'same moments are not after the same year');
        assert.equal(+m, +mCopy, 'isAfter year should not change moment');
    });

    test('is after month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month match');
        assert.equal(m.isAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), false, 'exact start of month');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), false, 'exact end of month');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');
        assert.equal(m.isAfter(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), true, 'end of previous month');
        assert.equal(m.isAfter(moment(new Date(2010, 12, 31, 23, 59, 59, 999)), 'month'), true, 'later month but earlier year');
        assert.equal(m.isAfter(m, 'month'), false, 'same moments are not after the same month');
        assert.equal(+m, +mCopy, 'isAfter month should not change moment');
    });

    test('is after day', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 7, 8, 9, 10)), 'day'), false, 'day match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'day'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'day'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 7, 8, 9, 10)), 'day'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 7, 8, 9, 10)), 'day'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 7, 8, 9, 10)), 'day'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 0, 0, 0, 0)), 'day'), false, 'exact start of day');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 23, 59, 59, 999)), 'day'), false, 'exact end of day');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 23, 59, 59, 999)), 'day'), true, 'end of previous day');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 10, 0, 0, 0, 0)), 'day'), true, 'later day but earlier year');
        assert.equal(m.isAfter(m, 'day'), false, 'same moments are not after the same day');
        assert.equal(+m, +mCopy, 'isAfter day should not change moment');
    });

    test('is after hour', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hour'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 8, 9, 10)), 'hour'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 8, 9, 10)), 'hour'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 8, 9, 10)), 'hour'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 8, 9, 10)), 'hour'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 0, 0, 0)), 'hour'), false, 'exact start of hour');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 59, 59, 999)), 'hour'), false, 'exact end of hour');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 59, 59, 999)), 'hour'), true, 'end of previous hour');
        assert.equal(m.isAfter(m, 'hour'), false, 'same moments are not after the same hour');
        assert.equal(+m, +mCopy, 'isAfter hour should not change moment');
    });

    test('is after minute', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minute'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 9, 10)), 'minute'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 9, 10)), 'minute'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 3, 4, 9, 10)), 'minute'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 9, 10)), 'minute'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 2, 4, 9, 10)), 'minute'), true, 'hour is earler');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 9, 10)), 'minute'), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 9, 10)), 'minute'), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 0, 0)), 'minute'), false, 'exact start of minute');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 59, 999)), 'minute'), false, 'exact end of minute');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 59, 999)), 'minute'), true, 'end of previous minute');
        assert.equal(m.isAfter(m, 'minute'), false, 'same moments are not after the same minute');
        assert.equal(+m, +mCopy, 'isAfter minute should not change moment');
    });

    test('is after second', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'second'), false, 'second match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'second'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'second'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'second'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'second'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'second'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'second'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'second'), true, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'second'), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'second'), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'second'), false, 'second is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'second'), true, 'second is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 0)), 'second'), false, 'exact start of second');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 999)), 'second'), false, 'exact end of second');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 999)), 'second'), true, 'end of previous second');
        assert.equal(m.isAfter(m, 'second'), false, 'same moments are not after the same second');
        assert.equal(+m, +mCopy, 'isAfter second should not change moment');
    });

    test('is after millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond match');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isAfter(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');
        assert.equal(m.isAfter(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');
        assert.equal(m.isAfter(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), true, 'day is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), true, 'hour is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), true, 'minute is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), true, 'second is earlier');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isAfter(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), true, 'millisecond is earlier');
        assert.equal(m.isAfter(m, 'millisecond'), false, 'same moments are not after the same millisecond');
        assert.equal(+m, +mCopy, 'isAfter millisecond should not change moment');
    });

    test('is after invalid', function (assert) {
        var m = moment(), invalid = moment.invalid();
        assert.equal(m.isAfter(invalid), false, 'valid moment is not after invalid moment');
        assert.equal(invalid.isAfter(m), false, 'invalid moment is not after valid moment');
        assert.equal(m.isAfter(invalid, 'year'), false, 'invalid moment year');
        assert.equal(m.isAfter(invalid, 'month'), false, 'invalid moment month');
        assert.equal(m.isAfter(invalid, 'day'), false, 'invalid moment day');
        assert.equal(m.isAfter(invalid, 'hour'), false, 'invalid moment hour');
        assert.equal(m.isAfter(invalid, 'minute'), false, 'invalid moment minute');
        assert.equal(m.isAfter(invalid, 'second'), false, 'invalid moment second');
        assert.equal(m.isAfter(invalid, 'milliseconds'), false, 'invalid moment milliseconds');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is before');

    test('is after without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), true, 'second is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), false, 'second is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond match');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), true, 'millisecond is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), false, 'millisecond is earlier');
        assert.equal(m.isBefore(m), false, 'moments are not before themselves');
        assert.equal(+m, +mCopy, 'isBefore second should not change moment');
    });

    test('is before year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');
        assert.equal(m.isBefore(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), false, 'exact start of year');
        assert.equal(m.isBefore(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), false, 'exact end of year');
        assert.equal(m.isBefore(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), true, 'start of next year');
        assert.equal(m.isBefore(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of previous year');
        assert.equal(m.isBefore(moment(new Date(1980, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of year far before');
        assert.equal(m.isBefore(m, 'year'), false, 'same moments are not before the same year');
        assert.equal(+m, +mCopy, 'isBefore year should not change moment');
    });

    test('is before month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month match');
        assert.equal(m.isBefore(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), false, 'exact start of month');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), false, 'exact end of month');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), true, 'start of next month');
        assert.equal(m.isBefore(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), false, 'end of previous month');
        assert.equal(m.isBefore(moment(new Date(2010, 12, 31, 23, 59, 59, 999)), 'month'), false, 'later month but earlier year');
        assert.equal(m.isBefore(m, 'month'), false, 'same moments are not before the same month');
        assert.equal(+m, +mCopy, 'isBefore month should not change moment');
    });

    test('is before day', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 7, 8, 9, 10)), 'day'), false, 'day match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 7, 8, 9, 10)), 'day'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 7, 8, 9, 10)), 'day'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 7, 8, 9, 10)), 'day'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 7, 8, 9, 10)), 'day'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 7, 8, 9, 10)), 'day'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 0, 0, 0, 0)), 'day'), false, 'exact start of day');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 23, 59, 59, 999)), 'day'), false, 'exact end of day');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 0, 0, 0, 0)), 'day'), true, 'start of next day');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 23, 59, 59, 999)), 'day'), false, 'end of previous day');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 10, 0, 0, 0, 0)), 'day'), false, 'later day but earlier year');
        assert.equal(m.isBefore(m, 'day'), false, 'same moments are not before the same day');
        assert.equal(+m, +mCopy, 'isBefore day should not change moment');
    });

    test('is before hour', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 8, 9, 10)), 'hour'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 8, 9, 10)), 'hour'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 8, 9, 10)), 'hour'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 8, 9, 10)), 'hour'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 8, 9, 10)), 'hour'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 8, 9, 10)), 'hour'), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 0, 0, 0)), 'hour'), false, 'exact start of hour');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 59, 59, 999)), 'hour'), false, 'exact end of hour');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 0, 0, 0)), 'hour'), true, 'start of next hour');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 59, 59, 999)), 'hour'), false, 'end of previous hour');
        assert.equal(m.isBefore(m, 'hour'), false, 'same moments are not before the same hour');
        assert.equal(+m, +mCopy, 'isBefore hour should not change moment');
    });

    test('is before minute', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 9, 10)), 'minute'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 9, 10)), 'minute'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 9, 10)), 'minute'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 9, 10)), 'minute'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 3, 4, 9, 10)), 'minute'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 9, 10)), 'minute'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 2, 4, 9, 10)), 'minute'), false, 'hour is earler');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 9, 10)), 'minute'), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 9, 10)), 'minute'), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 0, 0)), 'minute'), false, 'exact start of minute');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 59, 999)), 'minute'), false, 'exact end of minute');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 0, 0)), 'minute'), true, 'start of next minute');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 59, 999)), 'minute'), false, 'end of previous minute');
        assert.equal(m.isBefore(m, 'minute'), false, 'same moments are not before the same minute');
        assert.equal(+m, +mCopy, 'isBefore minute should not change moment');
    });

    test('is before second', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'second'), false, 'second match');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'second'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'second'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'second'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'second'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'second'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'second'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'second'), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'second'), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'second'), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'second'), true, 'second is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'second'), false, 'second is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 0)), 'second'), false, 'exact start of second');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 999)), 'second'), false, 'exact end of second');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 0)), 'second'), true, 'start of next second');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 999)), 'second'), false, 'end of previous second');
        assert.equal(m.isBefore(m, 'second'), false, 'same moments are not before the same second');
        assert.equal(+m, +mCopy, 'isBefore second should not change moment');
    });

    test('is before millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond match');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'milliseconds'), false, 'plural should work');
        assert.equal(m.isBefore(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'year is later');
        assert.equal(m.isBefore(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), true, 'month is later');
        assert.equal(m.isBefore(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), true, 'day is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), false, 'day is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), true, 'hour is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), false, 'hour is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), true, 'minute is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), false, 'minute is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), true, 'second is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), false, 'second is earlier');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), true, 'millisecond is later');
        assert.equal(m.isBefore(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), false, 'millisecond is earlier');
        assert.equal(m.isBefore(m, 'millisecond'), false, 'same moments are not before the same millisecond');
        assert.equal(+m, +mCopy, 'isBefore millisecond should not change moment');
    });

    test('is before invalid', function (assert) {
        var m = moment(), invalid = moment.invalid();
        assert.equal(m.isBefore(invalid), false, 'valid moment is not before invalid moment');
        assert.equal(invalid.isBefore(m), false, 'invalid moment is not before valid moment');
        assert.equal(m.isBefore(invalid, 'year'), false, 'invalid moment year');
        assert.equal(m.isBefore(invalid, 'month'), false, 'invalid moment month');
        assert.equal(m.isBefore(invalid, 'day'), false, 'invalid moment day');
        assert.equal(m.isBefore(invalid, 'hour'), false, 'invalid moment hour');
        assert.equal(m.isBefore(invalid, 'minute'), false, 'invalid moment minute');
        assert.equal(m.isBefore(invalid, 'second'), false, 'invalid moment second');
        assert.equal(m.isBefore(invalid, 'milliseconds'), false, 'invalid moment milliseconds');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is between');

    test('is between without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2009, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'year is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2013, 3, 2, 3, 4, 5, 10))), false, 'year is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2012, 3, 2, 3, 4, 5, 10))), true, 'year is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 5, 2, 3, 4, 5, 10))), false, 'month is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 2, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 4, 2, 3, 4, 5, 10))), true, 'month is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 1, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 4, 3, 4, 5, 10))), false, 'day is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 1, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 3, 3, 4, 5, 10))), true, 'day is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 1, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 5, 4, 5, 10))), false, 'hour is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 2, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 4, 4, 5, 10))), true, 'hour is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 6, 5, 10))), false, 'minute is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 2, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'minute is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 3, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 5, 5, 10))), true, 'minute is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 7, 10))), false, 'second is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 3, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'second is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 4, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 6, 10))), true, 'second is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 12))), false, 'millisecond is later');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 8)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 10))), false, 'millisecond is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 3, 2, 3, 4, 5, 9)),
                    moment(new Date(2011, 3, 2, 3, 4, 5, 11))), true, 'millisecond is between');
        assert.equal(m.isBetween(m, m), false, 'moments are not between themselves');
        assert.equal(+m, +mCopy, 'isBetween second should not change moment');
    });

    test('is between year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year match');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2013, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2010, 5, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year is later');
        assert.equal(m.isBetween(m, 'year'), false, 'same moments are not between the same year');
        assert.equal(+m, +mCopy, 'isBetween year should not change moment');
    });

    test('is between month', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 0, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 0, 31, 23, 59, 59, 999)),
                    moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'month is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), false, 'month is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 11, 6, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 6, 7, 8, 9, 10)), 'month'), false, 'month is later');
        assert.equal(m.isBetween(m, 'month'), false, 'same moments are not between the same month');
        assert.equal(+m, +mCopy, 'isBetween month should not change moment');
    });

    test('is between day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), false, 'day match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), true, 'day is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 4, 7, 8, 9, 10)), 'day'), false, 'day is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 1, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), false, 'day is later');
        assert.equal(m.isBetween(m, 'day'), false, 'same moments are not between the same day');
        assert.equal(+m, +mCopy, 'isBetween day should not change moment');
    });

    test('is between hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 5, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 9, 9, 10)), 'hour'), false, 'hour match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 1, 59, 59, 999)),
                    moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hours'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 2, 59, 59, 999)),
                    moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), true, 'hour is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'hour'), false, 'hour is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)),
                    moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'hour'), false, 'hour is later');
        assert.equal(m.isBetween(m, 'hour'), false, 'same moments are not between the same hour');
        assert.equal(+m, +mCopy, 'isBetween hour should not change moment');
    });

    test('is between minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'minute match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 3, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 3, 59, 999)),
                    moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), true, 'minute is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 5, 0, 0)),
                    moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'minute'), false, 'minute is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 2, 9, 10)),
                    moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), false, 'minute is later');
        assert.equal(m.isBetween(m, 'minute'), false, 'same moments are not between the same minute');
        assert.equal(+m, +mCopy, 'isBetween minute should not change moment');
    });

    test('is between second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), false, 'second match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 4, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 4, 999)),
                    moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), true, 'second is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 6, 0)),
                    moment(new Date(2011, 1, 2, 3, 4, 7, 10)), 'second'), false, 'second is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 3, 10)),
                    moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), false, 'second is later');
        assert.equal(m.isBetween(m, 'second'), false, 'same moments are not between the same second');
        assert.equal(+m, +mCopy, 'isBetween second should not change moment');
    });

    test('is between millisecond', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)), 'millisecond'), false, 'millisecond match');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 5)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 5)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)), 'millisecond'), true, 'millisecond is between');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 7)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'millisecond'), false, 'millisecond is earlier');
        assert.equal(m.isBetween(
                    moment(new Date(2011, 1, 2, 3, 4, 5, 4)),
                    moment(new Date(2011, 1, 2, 3, 4, 5, 6)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isBetween(m, 'millisecond'), false, 'same moments are not between the same millisecond');
        assert.equal(+m, +mCopy, 'isBetween millisecond should not change moment');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is date');

    test('isDate recognizes Date objects', function (assert) {
        assert.ok(moment.isDate(new Date()), 'no args (now)');
        assert.ok(moment.isDate(new Date([2014, 2, 15])), 'array args');
        assert.ok(moment.isDate(new Date('2014-03-15')), 'string args');
        assert.ok(moment.isDate(new Date('does NOT look like a date')), 'invalid date');
    });

    test('isDate rejects non-Date objects', function (assert) {
        assert.ok(!moment.isDate(), 'nothing');
        assert.ok(!moment.isDate(undefined), 'undefined');
        assert.ok(!moment.isDate(null), 'string args');
        assert.ok(!moment.isDate(42), 'number');
        assert.ok(!moment.isDate('2014-03-15'), 'string');
        assert.ok(!moment.isDate([2014, 2, 15]), 'array');
        assert.ok(!moment.isDate({year: 2014, month: 2, day: 15}), 'object');
        assert.ok(!moment.isDate({toString: function () {
            return '[object Date]';
        }}), 'lying object');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is moment');

    test('is moment object', function (assert) {
        var MyObj = function () {},
            extend = function (a, b) {
                var i;
                for (i in b) {
                    a[i] = b[i];
                }
                return a;
            };
        MyObj.prototype.toDate = function () {
            return new Date();
        };

        assert.ok(moment.isMoment(moment()), 'simple moment object');
        assert.ok(moment.isMoment(moment(null)), 'invalid moment object');
        assert.ok(moment.isMoment(extend({}, moment())), 'externally cloned moments are moments');
        assert.ok(moment.isMoment(extend({}, moment.utc())), 'externally cloned utc moments are moments');

        assert.ok(!moment.isMoment(new MyObj()), 'myObj is not moment object');
        assert.ok(!moment.isMoment(moment), 'moment function is not moment object');
        assert.ok(!moment.isMoment(new Date()), 'date object is not moment object');
        assert.ok(!moment.isMoment(Object), 'Object is not moment object');
        assert.ok(!moment.isMoment('foo'), 'string is not moment object');
        assert.ok(!moment.isMoment(1), 'number is not moment object');
        assert.ok(!moment.isMoment(NaN), 'NaN is not moment object');
        assert.ok(!moment.isMoment(null), 'null is not moment object');
        assert.ok(!moment.isMoment(undefined), 'undefined is not moment object');
    });

    test('is moment with hacked hasOwnProperty', function (assert) {
        var obj = {};
        // HACK to suppress jshint warning about bad property name
        obj['hasOwnMoney'.replace('Money', 'Property')] = function () {
            return true;
        };

        assert.ok(!moment.isMoment(obj), 'isMoment works even if passed object has a wrong hasOwnProperty implementation (ie8)');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is same');

    test('is same without units', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2012, 3, 2, 3, 5, 5, 10))), false, 'year is later');
        assert.equal(m.isSame(moment(new Date(2010, 3, 2, 3, 3, 5, 10))), false, 'year is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 4, 2, 3, 4, 5, 10))), false, 'month is later');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10))), false, 'month is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 3, 3, 4, 5, 10))), false, 'day is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 3, 4, 5, 10))), false, 'day is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 4, 4, 5, 10))), false, 'hour is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 2, 4, 5, 10))), false, 'hour is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 5, 5, 10))), false, 'minute is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 3, 5, 10))), false, 'minute is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 10))), false, 'second is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 11))), false, 'second is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10))), true, 'millisecond match');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 11))), false, 'millisecond is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 9))), false, 'millisecond is earlier');
        assert.equal(m.isSame(m), true, 'moments are the same as themselves');
        assert.equal(+m, +mCopy, 'isSame second should not change moment');
    });

    test('is same year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'year'), true, 'year match');
        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'years'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 5, 6, 7, 8, 9, 10)), 'year'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 0, 1, 0, 0, 0, 0)), 'year'), true, 'exact start of year');
        assert.equal(m.isSame(moment(new Date(2011, 11, 31, 23, 59, 59, 999)), 'year'), true, 'exact end of year');
        assert.equal(m.isSame(moment(new Date(2012, 0, 1, 0, 0, 0, 0)), 'year'), false, 'start of next year');
        assert.equal(m.isSame(moment(new Date(2010, 11, 31, 23, 59, 59, 999)), 'year'), false, 'end of previous year');
        assert.equal(m.isSame(m, 'year'), true, 'same moments are in the same year');
        assert.equal(+m, +mCopy, 'isSame year should not change moment');
    });

    test('is same month', function (assert) {
        var m = moment(new Date(2011, 2, 3, 4, 5, 6, 7)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'month'), true, 'month match');
        assert.equal(m.isSame(moment(new Date(2011, 2, 6, 7, 8, 9, 10)), 'months'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 2, 6, 7, 8, 9, 10)), 'month'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 5, 6, 7, 8, 9, 10)), 'month'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 1, 0, 0, 0, 0)), 'month'), true, 'exact start of month');
        assert.equal(m.isSame(moment(new Date(2011, 2, 31, 23, 59, 59, 999)), 'month'), true, 'exact end of month');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 0, 0, 0, 0)), 'month'), false, 'start of next month');
        assert.equal(m.isSame(moment(new Date(2011, 1, 27, 23, 59, 59, 999)), 'month'), false, 'end of previous month');
        assert.equal(m.isSame(m, 'month'), true, 'same moments are in the same month');
        assert.equal(+m, +mCopy, 'isSame month should not change moment');
    });

    test('is same day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'day'), true, 'day match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 7, 8, 9, 10)), 'days'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 7, 8, 9, 10)), 'day'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 7, 8, 9, 10)), 'day'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 7, 8, 9, 10)), 'day'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 0, 0, 0, 0)), 'day'), true, 'exact start of day');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 23, 59, 59, 999)), 'day'), true, 'exact end of day');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 0, 0, 0, 0)), 'day'), false, 'start of next day');
        assert.equal(m.isSame(moment(new Date(2011, 1, 1, 23, 59, 59, 999)), 'day'), false, 'end of previous day');
        assert.equal(m.isSame(m, 'day'), true, 'same moments are in the same day');
        assert.equal(+m, +mCopy, 'isSame day should not change moment');
    });

    test('is same hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hour'), true, 'hour match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 8, 9, 10)), 'hours'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 8, 9, 10)), 'hour'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 8, 9, 10)), 'hour'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 8, 9, 10)), 'hour'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 8, 9, 10)), 'hour'), false, 'hour mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 0, 0, 0)), 'hour'), true, 'exact start of hour');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 59, 59, 999)), 'hour'), true, 'exact end of hour');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 0, 0, 0)), 'hour'), false, 'start of next hour');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 2, 59, 59, 999)), 'hour'), false, 'end of previous hour');
        assert.equal(m.isSame(m, 'hour'), true, 'same moments are in the same hour');
        assert.equal(+m, +mCopy, 'isSame hour should not change moment');
    });

    test('is same minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minute'), true, 'minute match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 9, 10)), 'minutes'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 4, 9, 10)), 'minute'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 9, 10)), 'minute'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 4, 9, 10)), 'minute'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 4, 9, 10)), 'minute'), false, 'hour mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 9, 10)), 'minute'), false, 'minute mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 0, 0)), 'minute'), true, 'exact start of minute');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 59, 999)), 'minute'), true, 'exact end of minute');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 0, 0)), 'minute'), false, 'start of next minute');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 3, 59, 999)), 'minute'), false, 'end of previous minute');
        assert.equal(m.isSame(m, 'minute'), true, 'same moments are in the same minute');
        assert.equal(+m, +mCopy, 'isSame minute should not change moment');
    });

    test('is same second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'second'), true, 'second match');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 10)), 'seconds'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 1, 2, 3, 4, 5, 10)), 'second'), false, 'year mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'second'), false, 'month mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 3, 3, 4, 5, 10)), 'second'), false, 'day mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 4, 4, 5, 10)), 'second'), false, 'hour mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 5, 5, 10)), 'second'), false, 'minute mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 6, 10)), 'second'), false, 'second mismatch');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 0)), 'second'), true, 'exact start of second');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 5, 999)), 'second'), true, 'exact end of second');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 6, 0)), 'second'), false, 'start of next second');
        assert.equal(m.isSame(moment(new Date(2011, 1, 2, 3, 4, 4, 999)), 'second'), false, 'end of previous second');
        assert.equal(m.isSame(m, 'second'), true, 'same moments are in the same second');
        assert.equal(+m, +mCopy, 'isSame second should not change moment');
    });

    test('is same millisecond', function (assert) {
        var m = moment(new Date(2011, 3, 2, 3, 4, 5, 10)), mCopy = moment(m);
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'millisecond'), true, 'millisecond match');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 5, 10)), 'milliseconds'), true, 'plural should work');
        assert.equal(m.isSame(moment(new Date(2012, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is later');
        assert.equal(m.isSame(moment(new Date(2010, 3, 2, 3, 4, 5, 10)), 'millisecond'), false, 'year is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 4, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is later');
        assert.equal(m.isSame(moment(new Date(2011, 2, 2, 3, 4, 5, 10)), 'millisecond'), false, 'month is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 3, 3, 4, 5, 10)), 'millisecond'), false, 'day is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 1, 4, 5, 10)), 'millisecond'), false, 'day is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 4, 4, 5, 10)), 'millisecond'), false, 'hour is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 1, 4, 1, 5, 10)), 'millisecond'), false, 'hour is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 5, 5, 10)), 'millisecond'), false, 'minute is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 3, 5, 10)), 'millisecond'), false, 'minute is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 10)), 'millisecond'), false, 'second is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 5)), 'millisecond'), false, 'second is earlier');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 6, 11)), 'millisecond'), false, 'millisecond is later');
        assert.equal(m.isSame(moment(new Date(2011, 3, 2, 3, 4, 4, 9)), 'millisecond'), false, 'millisecond is earlier');
        assert.equal(m.isSame(m, 'millisecond'), true, 'same moments are in the same millisecond');
        assert.equal(+m, +mCopy, 'isSame millisecond should not change moment');
    });

    test('is same with utc offset moments', function (assert) {
        assert.ok(moment.parseZone('2013-02-01T-05:00').isSame(moment('2013-02-01'), 'year'), 'zoned vs local moment');
        assert.ok(moment('2013-02-01').isSame(moment('2013-02-01').utcOffset('-05:00'), 'year'), 'local vs zoned moment');
        assert.ok(moment.parseZone('2013-02-01T-05:00').isSame(moment.parseZone('2013-02-01T-06:30'), 'year'),
                'zoned vs (differently) zoned moment');
    });

    test('is same with invalid moments', function (assert) {
        assert.equal(moment.invalid().isSame(moment.invalid()), false, 'invalid moments are not considered equal');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('is valid');

    test('array bad month', function (assert) {
        assert.equal(moment([2010, -1]).isValid(), false, 'month -1 invalid');
        assert.equal(moment([2100, 12]).isValid(), false, 'month 12 invalid');
    });

    test('array good month', function (assert) {
        for (var i = 0; i < 12; i++) {
            assert.equal(moment([2010, i]).isValid(), true, 'month ' + i);
            assert.equal(moment.utc([2010, i]).isValid(), true, 'month ' + i);
        }
    });

    test('array bad date', function (assert) {
        var tests = [
            moment([2010, 0, 0]),
            moment([2100, 0, 32]),
            moment.utc([2010, 0, 0]),
            moment.utc([2100, 0, 32])
        ],
        i, m;

        for (i in tests) {
            m = tests[i];
            assert.equal(m.isValid(), false);
        }
    });

    test('h/hh with hour > 12', function (assert) {
        assert.ok(moment('06/20/2014 11:51 PM', 'MM/DD/YYYY hh:mm A', true).isValid(), '11 for hh');
        assert.ok(moment('06/20/2014 11:51 AM', 'MM/DD/YYYY hh:mm A', true).isValid(), '11 for hh');
        assert.ok(moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A').isValid(), 'non-strict validity 23 for hh');
        assert.ok(moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A').parsingFlags().bigHour, 'non-strict bigHour 23 for hh');
        assert.ok(!moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A', true).isValid(), 'validity 23 for hh');
        assert.ok(moment('06/20/2014 23:51 PM', 'MM/DD/YYYY hh:mm A', true).parsingFlags().bigHour, 'bigHour 23 for hh');
    });

    test('array bad date leap year', function (assert) {
        assert.equal(moment([2010, 1, 29]).isValid(), false, '2010 feb 29');
        assert.equal(moment([2100, 1, 29]).isValid(), false, '2100 feb 29');
        assert.equal(moment([2008, 1, 30]).isValid(), false, '2008 feb 30');
        assert.equal(moment([2000, 1, 30]).isValid(), false, '2000 feb 30');

        assert.equal(moment.utc([2010, 1, 29]).isValid(), false, 'utc 2010 feb 29');
        assert.equal(moment.utc([2100, 1, 29]).isValid(), false, 'utc 2100 feb 29');
        assert.equal(moment.utc([2008, 1, 30]).isValid(), false, 'utc 2008 feb 30');
        assert.equal(moment.utc([2000, 1, 30]).isValid(), false, 'utc 2000 feb 30');
    });

    test('string + formats bad date', function (assert) {
        assert.equal(moment('2020-00-00', []).isValid(), false, 'invalid on empty array');
        assert.equal(moment('2020-00-00', ['YYYY-MM-DD', 'DD-MM-YYYY']).isValid(), false, 'invalid on all in array');
        assert.equal(moment('2020-00-00', ['DD-MM-YYYY', 'YYYY-MM-DD']).isValid(), false, 'invalid on all in array');
        assert.equal(moment('2020-01-01', ['YYYY-MM-DD', 'DD-MM-YYYY']).isValid(), true, 'valid on first');
        assert.equal(moment('2020-01-01', ['DD-MM-YYYY', 'YYYY-MM-DD']).isValid(), true, 'valid on last');
        assert.equal(moment('2020-01-01', ['YYYY-MM-DD', 'YYYY-DD-MM']).isValid(), true, 'valid on both');
        assert.equal(moment('2020-13-01', ['YYYY-MM-DD', 'YYYY-DD-MM']).isValid(), true, 'valid on last');

        assert.equal(moment('12-13-2012', ['DD-MM-YYYY', 'YYYY-MM-DD']).isValid(), false, 'month rollover');
        assert.equal(moment('12-13-2012', ['DD-MM-YYYY', 'DD-MM-YYYY']).isValid(), false, 'month rollover');
        assert.equal(moment('38-12-2012', ['DD-MM-YYYY']).isValid(), false, 'day rollover');
    });

    test('string nonsensical with format', function (assert) {
        assert.equal(moment('fail', 'MM-DD-YYYY').isValid(), false, 'string \'fail\' with format \'MM-DD-YYYY\'');
        assert.equal(moment('xx-xx-2001', 'DD-MM-YYY').isValid(), true, 'string \'xx-xx-2001\' with format \'MM-DD-YYYY\'');
    });

    test('string with bad month name', function (assert) {
        assert.equal(moment('01-Nam-2012', 'DD-MMM-YYYY').isValid(), false, '\'Nam\' is an invalid month');
        assert.equal(moment('01-Aug-2012', 'DD-MMM-YYYY').isValid(), true, '\'Aug\' is a valid month');
    });

    test('string with spaceless format', function (assert) {
        assert.equal(moment('10Sep2001', 'DDMMMYYYY').isValid(), true, 'Parsing 10Sep2001 should result in a valid date');
    });

    test('invalid string iso 8601', function (assert) {
        var tests = [
            '2010-00-00',
            '2010-01-00',
            '2010-01-40',
            '2010-01-01T24:01',  // 24:00:00 is actually valid
            '2010-01-01T23:60',
            '2010-01-01T23:59:60'
        ], i;

        for (i = 0; i < tests.length; i++) {
            assert.equal(moment(tests[i]).isValid(), false, tests[i] + ' should be invalid');
            assert.equal(moment.utc(tests[i]).isValid(), false, tests[i] + ' should be invalid');
        }
    });

    test('invalid string iso 8601 + timezone', function (assert) {
        var tests = [
            '2010-00-00T+00:00',
            '2010-01-00T+00:00',
            '2010-01-40T+00:00',
            '2010-01-40T24:01+00:00',
            '2010-01-40T23:60+00:00',
            '2010-01-40T23:59:60+00:00',
            '2010-01-40T23:59:59.9999+00:00'
        ], i;

        for (i = 0; i < tests.length; i++) {
            assert.equal(moment(tests[i]).isValid(), false, tests[i] + ' should be invalid');
            assert.equal(moment.utc(tests[i]).isValid(), false, tests[i] + ' should be invalid');
        }
    });

    test('valid string iso 8601 + timezone', function (assert) {
        var tests = [
            '2010-01-01',
            '2010-01-30',
            '2010-01-30T23+00:00',
            '2010-01-30T23:59+00:00',
            '2010-01-30T23:59:59+00:00',
            '2010-01-30T23:59:59.999+00:00',
            '2010-01-30T23:59:59.999-07:00',
            '2010-01-30T00:00:00.000+07:00',
            '2010-01-30 00:00:00.000Z'
        ], i;

        for (i = 0; i < tests.length; i++) {
            assert.equal(moment(tests[i]).isValid(), true, tests[i] + ' should be valid in normal');
            assert.equal(moment.utc(tests[i]).isValid(), true, tests[i] + ' should be valid in normal');
            assert.equal(moment(tests[i], moment.ISO_8601, true).isValid(), true, tests[i] + ' should be valid in strict');
            assert.equal(moment.utc(tests[i], moment.ISO_8601, true).isValid(), true, tests[i] + ' should be valid in strict');
        }
    });

    test('invalidAt', function (assert) {
        assert.equal(moment([2000, 12]).invalidAt(), 1, 'month 12 is invalid: 0-11');
        assert.equal(moment([2000, 1, 30]).invalidAt(), 2, '30 is not a valid february day');
        assert.equal(moment([2000, 1, 29, 25]).invalidAt(), 3, '25 is invalid hour');
        assert.equal(moment([2000, 1, 29, 24,  1]).invalidAt(), 3, '24:01 is invalid hour');
        assert.equal(moment([2000, 1, 29, 23, 60]).invalidAt(), 4, '60 is invalid minute');
        assert.equal(moment([2000, 1, 29, 23, 59, 60]).invalidAt(), 5, '60 is invalid second');
        assert.equal(moment([2000, 1, 29, 23, 59, 59, 1000]).invalidAt(), 6, '1000 is invalid millisecond');
        assert.equal(moment([2000, 1, 29, 23, 59, 59, 999]).invalidAt(), -1, '-1 if everything is fine');
    });

    test('valid Unix timestamp', function (assert) {
        assert.equal(moment(1371065286, 'X').isValid(), true, 'number integer');
        assert.equal(moment(1379066897.0, 'X').isValid(), true, 'number whole 1dp');
        assert.equal(moment(1379066897.7, 'X').isValid(), true, 'number 1dp');
        assert.equal(moment(1379066897.00, 'X').isValid(), true, 'number whole 2dp');
        assert.equal(moment(1379066897.07, 'X').isValid(), true, 'number 2dp');
        assert.equal(moment(1379066897.17, 'X').isValid(), true, 'number 2dp');
        assert.equal(moment(1379066897.000, 'X').isValid(), true, 'number whole 3dp');
        assert.equal(moment(1379066897.007, 'X').isValid(), true, 'number 3dp');
        assert.equal(moment(1379066897.017, 'X').isValid(), true, 'number 3dp');
        assert.equal(moment(1379066897.157, 'X').isValid(), true, 'number 3dp');
        assert.equal(moment('1371065286', 'X').isValid(), true, 'string integer');
        assert.equal(moment('1379066897.', 'X').isValid(), true, 'string trailing .');
        assert.equal(moment('1379066897.0', 'X').isValid(), true, 'string whole 1dp');
        assert.equal(moment('1379066897.7', 'X').isValid(), true, 'string 1dp');
        assert.equal(moment('1379066897.00', 'X').isValid(), true, 'string whole 2dp');
        assert.equal(moment('1379066897.07', 'X').isValid(), true, 'string 2dp');
        assert.equal(moment('1379066897.17', 'X').isValid(), true, 'string 2dp');
        assert.equal(moment('1379066897.000', 'X').isValid(), true, 'string whole 3dp');
        assert.equal(moment('1379066897.007', 'X').isValid(), true, 'string 3dp');
        assert.equal(moment('1379066897.017', 'X').isValid(), true, 'string 3dp');
        assert.equal(moment('1379066897.157', 'X').isValid(), true, 'string 3dp');
    });

    test('invalid Unix timestamp', function (assert) {
        assert.equal(moment(undefined, 'X').isValid(), false, 'undefined');
        assert.equal(moment('undefined', 'X').isValid(), false, 'string undefined');
        try {
            assert.equal(moment(null, 'X').isValid(), false, 'null');
        } catch (e) {
            assert.ok(true, 'null');
        }

        assert.equal(moment('null', 'X').isValid(), false, 'string null');
        assert.equal(moment([], 'X').isValid(), false, 'array');
        assert.equal(moment('{}', 'X').isValid(), false, 'object');
        try {
            assert.equal(moment('', 'X').isValid(), false, 'string empty');
        } catch (e) {
            assert.ok(true, 'string empty');
        }

        assert.equal(moment(' ', 'X').isValid(), false, 'string space');
    });

    test('valid Unix offset milliseconds', function (assert) {
        assert.equal(moment(1234567890123, 'x').isValid(), true, 'number integer');
        assert.equal(moment('1234567890123', 'x').isValid(), true, 'string integer');
    });

    test('invalid Unix offset milliseconds', function (assert) {
        assert.equal(moment(undefined, 'x').isValid(), false, 'undefined');
        assert.equal(moment('undefined', 'x').isValid(), false, 'string undefined');
        try {
            assert.equal(moment(null, 'x').isValid(), false, 'null');
        } catch (e) {
            assert.ok(true, 'null');
        }

        assert.equal(moment('null', 'x').isValid(), false, 'string null');
        assert.equal(moment([], 'x').isValid(), false, 'array');
        assert.equal(moment('{}', 'x').isValid(), false, 'object');
        try {
            assert.equal(moment('', 'x').isValid(), false, 'string empty');
        } catch (e) {
            assert.ok(true, 'string empty');
        }

        assert.equal(moment(' ', 'x').isValid(), false, 'string space');
    });

    test('empty', function (assert) {
        assert.equal(moment(null).isValid(), false, 'null');
        assert.equal(moment('').isValid(), false, 'empty string');
        assert.equal(moment(null, 'YYYY').isValid(), false, 'format + null');
        assert.equal(moment('', 'YYYY').isValid(), false, 'format + empty string');
        assert.equal(moment(' ', 'YYYY').isValid(), false, 'format + empty when trimmed');
    });

    test('days of the year', function (assert) {
        assert.equal(moment('2010 300', 'YYYY DDDD').isValid(), true, 'day 300 of year valid');
        assert.equal(moment('2010 365', 'YYYY DDDD').isValid(), true, 'day 365 of year valid');
        assert.equal(moment('2010 366', 'YYYY DDDD').isValid(), false, 'day 366 of year invalid');
        assert.equal(moment('2012 365', 'YYYY DDDD').isValid(), true, 'day 365 of leap year valid');
        assert.equal(moment('2012 366', 'YYYY DDDD').isValid(), true, 'day 366 of leap year valid');
        assert.equal(moment('2012 367', 'YYYY DDDD').isValid(), false, 'day 367 of leap year invalid');
    });

    test('24:00:00.000 is valid', function (assert) {
        assert.equal(moment('2014-01-01 24', 'YYYY-MM-DD HH').isValid(), true, '24 is valid');
        assert.equal(moment('2014-01-01 24:00', 'YYYY-MM-DD HH:mm').isValid(), true, '24:00 is valid');
        assert.equal(moment('2014-01-01 24:01', 'YYYY-MM-DD HH:mm').isValid(), false, '24:01 is not valid');
    });

    test('oddball permissiveness', function (assert) {
        //https://github.com/moment/moment/issues/1128
        assert.ok(moment('2010-10-3199', ['MM/DD/YYYY', 'MM-DD-YYYY', 'YYYY-MM-DD']).isValid());

        //https://github.com/moment/moment/issues/1122
        assert.ok(moment('3:25', ['h:mma', 'hh:mma', 'H:mm', 'HH:mm']).isValid());
    });

    test('0 hour is invalid in strict', function (assert) {
        assert.equal(moment('00:01', 'hh:mm', true).isValid(), false, '00 hour is invalid in strict');
        assert.equal(moment('00:01', 'hh:mm').isValid(), true, '00 hour is valid in normal');
        assert.equal(moment('0:01', 'h:mm', true).isValid(), false, '0 hour is invalid in strict');
        assert.equal(moment('0:01', 'h:mm').isValid(), true, '0 hour is valid in normal');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('leap year');

    test('leap year', function (assert) {
        assert.equal(moment([2010, 0, 1]).isLeapYear(), false, '2010');
        assert.equal(moment([2100, 0, 1]).isLeapYear(), false, '2100');
        assert.equal(moment([2008, 0, 1]).isLeapYear(), true, '2008');
        assert.equal(moment([2000, 0, 1]).isLeapYear(), true, '2000');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('listers');

    test('default', function (assert) {
        assert.deepEqual(moment.months(), ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']);
        assert.deepEqual(moment.monthsShort(), ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']);
        assert.deepEqual(moment.weekdays(), ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']);
        assert.deepEqual(moment.weekdaysShort(), ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']);
        assert.deepEqual(moment.weekdaysMin(), ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']);
    });

    test('index', function (assert) {
        assert.equal(moment.months(0), 'January');
        assert.equal(moment.months(2), 'March');
        assert.equal(moment.monthsShort(0), 'Jan');
        assert.equal(moment.monthsShort(2), 'Mar');
        assert.equal(moment.weekdays(0), 'Sunday');
        assert.equal(moment.weekdays(2), 'Tuesday');
        assert.equal(moment.weekdaysShort(0), 'Sun');
        assert.equal(moment.weekdaysShort(2), 'Tue');
        assert.equal(moment.weekdaysMin(0), 'Su');
        assert.equal(moment.weekdaysMin(2), 'Tu');
    });

    test('localized', function (assert) {
        var months = 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),
            monthsShort = 'on_tw_th_fo_fi_si_se_ei_ni_te_el_tw'.split('_'),
            weekdays = 'one_two_three_four_five_six_seven'.split('_'),
            weekdaysShort = 'on_tw_th_fo_fi_si_se'.split('_'),
            weekdaysMin = '1_2_3_4_5_6_7'.split('_');

        moment.locale('numerologists', {
            months : months,
            monthsShort : monthsShort,
            weekdays : weekdays,
            weekdaysShort: weekdaysShort,
            weekdaysMin: weekdaysMin
        });

        assert.deepEqual(moment.months(), months);
        assert.deepEqual(moment.monthsShort(), monthsShort);
        assert.deepEqual(moment.weekdays(), weekdays);
        assert.deepEqual(moment.weekdaysShort(), weekdaysShort);
        assert.deepEqual(moment.weekdaysMin(), weekdaysMin);

        assert.equal(moment.months(0), 'one');
        assert.equal(moment.monthsShort(0), 'on');
        assert.equal(moment.weekdays(0), 'one');
        assert.equal(moment.weekdaysShort(0), 'on');
        assert.equal(moment.weekdaysMin(0), '1');

        assert.equal(moment.months(2), 'three');
        assert.equal(moment.monthsShort(2), 'th');
        assert.equal(moment.weekdays(2), 'three');
        assert.equal(moment.weekdaysShort(2), 'th');
        assert.equal(moment.weekdaysMin(2), '3');
    });

    test('with functions', function (assert) {
        var monthsShort = 'one_two_three_four_five_six_seven_eight_nine_ten_eleven_twelve'.split('_'),
            monthsShortWeird = 'onesy_twosy_threesy_foursy_fivesy_sixsy_sevensy_eightsy_ninesy_tensy_elevensy_twelvesy'.split('_');

        moment.locale('difficult', {

            monthsShort: function (m, format) {
                var arr = format.match(/-MMM-/) ? monthsShortWeird : monthsShort;
                return arr[m.month()];
            }
        });

        assert.deepEqual(moment.monthsShort(), monthsShort);
        assert.deepEqual(moment.monthsShort('MMM'), monthsShort);
        assert.deepEqual(moment.monthsShort('-MMM-'), monthsShortWeird);

        assert.deepEqual(moment.monthsShort('MMM', 2), 'three');
        assert.deepEqual(moment.monthsShort('-MMM-', 2), 'threesy');
        assert.deepEqual(moment.monthsShort(2), 'three');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function each(array, callback) {
        var i;
        for (i = 0; i < array.length; i++) {
            callback(array[i], i, array);
        }
    }

    module('locale', {
        setup : function () {
            // TODO: Remove once locales are switched to ES6
            each([{
                name: 'en-gb',
                data: {}
            }, {
                name: 'en-ca',
                data: {}
            }, {
                name: 'es',
                data: {
                    relativeTime: {past: 'hace %s', s: 'unos segundos', d: 'un da'},
                    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_')
                }
            }, {
                name: 'fr',
                data: {}
            }, {
                name: 'fr-ca',
                data: {}
            }, {
                name: 'it',
                data: {}
            }, {
                name: 'zh-cn',
                data: {
                    months: '___________'.split('_')
                }
            }], function (locale) {
                if (moment.locale(locale.name) !== locale.name) {
                    moment.defineLocale(locale.name, locale.data);
                }
            });
            moment.locale('en');
        }
    });

    test('library getters and setters', function (assert) {
        var r = moment.locale('en');

        assert.equal(r, 'en', 'locale should return en by default');
        assert.equal(moment.locale(), 'en', 'locale should return en by default');

        moment.locale('fr');
        assert.equal(moment.locale(), 'fr', 'locale should return the changed locale');

        moment.locale('en-gb');
        assert.equal(moment.locale(), 'en-gb', 'locale should return the changed locale');

        moment.locale('en');
        assert.equal(moment.locale(), 'en', 'locale should reset');

        moment.locale('does-not-exist');
        assert.equal(moment.locale(), 'en', 'locale should reset');

        moment.locale('EN');
        assert.equal(moment.locale(), 'en', 'Normalize locale key case');

        moment.locale('EN_gb');
        assert.equal(moment.locale(), 'en-gb', 'Normalize locale key underscore');
    });

    test('library setter array of locales', function (assert) {
        assert.equal(moment.locale(['non-existent', 'fr', 'also-non-existent']), 'fr', 'passing an array uses the first valid locale');
        assert.equal(moment.locale(['es', 'fr', 'also-non-existent']), 'es', 'passing an array uses the first valid locale');
    });

    test('library setter locale substrings', function (assert) {
        assert.equal(moment.locale('fr-crap'), 'fr', 'use substrings');
        assert.equal(moment.locale('fr-does-not-exist'), 'fr', 'uses deep substrings');
        assert.equal(moment.locale('fr-CA-does-not-exist'), 'fr-ca', 'uses deepest substring');
    });

    test('library getter locale array and substrings', function (assert) {
        assert.equal(moment.locale(['en-CH', 'fr']), 'en', 'prefer root locale to shallower ones');
        assert.equal(moment.locale(['en-gb-leeds', 'en-CA']), 'en-gb', 'prefer root locale to shallower ones');
        assert.equal(moment.locale(['en-fake', 'en-CA']), 'en-ca', 'prefer alternatives with shared roots');
        assert.equal(moment.locale(['en-fake', 'en-fake2', 'en-ca']), 'en-ca', 'prefer alternatives with shared roots');
        assert.equal(moment.locale(['fake-CA', 'fake-MX', 'fr']), 'fr', 'always find something if possible');
        assert.equal(moment.locale(['fake-CA', 'fake-MX', 'fr']), 'fr', 'always find something if possible');
        assert.equal(moment.locale(['fake-CA', 'fake-MX', 'fr-fake-fake-fake']), 'fr', 'always find something if possible');
        assert.equal(moment.locale(['en', 'en-CA']), 'en', 'prefer earlier if it works');
    });

    test('library ensure inheritance', function (assert) {
        moment.locale('made-up', {
            // I put them out of order
            months : 'February_March_April_May_June_July_August_September_October_November_December_January'.split('_')
            // the rest of the properties should be inherited.
        });

        assert.equal(moment([2012, 5, 6]).format('MMMM'), 'July', 'Override some of the configs');
        assert.equal(moment([2012, 5, 6]).format('MMM'), 'Jun', 'But not all of them');
    });

    test('library ensure inheritance LT L LL LLL LLLL', function (assert) {
        var locale = 'test-inherit-lt';

        moment.defineLocale(locale, {
            longDateFormat : {
                LT : '-[LT]-',
                L : '-[L]-',
                LL : '-[LL]-',
                LLL : '-[LLL]-',
                LLLL : '-[LLLL]-'
            },
            calendar : {
                sameDay : '[sameDay] LT',
                nextDay : '[nextDay] L',
                nextWeek : '[nextWeek] LL',
                lastDay : '[lastDay] LLL',
                lastWeek : '[lastWeek] LLLL',
                sameElse : 'L'
            }
        });

        moment.locale('es');

        assert.equal(moment().locale(locale).calendar(), 'sameDay -LT-', 'Should use instance locale in LT formatting');
        assert.equal(moment().add(1, 'days').locale(locale).calendar(), 'nextDay -L-', 'Should use instance locale in L formatting');
        assert.equal(moment().add(-1, 'days').locale(locale).calendar(), 'lastDay -LLL-', 'Should use instance locale in LL formatting');
        assert.equal(moment().add(4, 'days').locale(locale).calendar(), 'nextWeek -LL-', 'Should use instance locale in LLL formatting');
        assert.equal(moment().add(-4, 'days').locale(locale).calendar(), 'lastWeek -LLLL-', 'Should use instance locale in LLLL formatting');
    });

    test('library localeData', function (assert) {
        moment.locale('en');

        var jan = moment([2000, 0]);

        assert.equal(moment.localeData().months(jan), 'January', 'no arguments returns global');
        assert.equal(moment.localeData('zh-cn').months(jan), '', 'a string returns the locale based on key');
        assert.equal(moment.localeData(moment().locale('es')).months(jan), 'Enero', 'if you pass in a moment it uses the moment\'s locale');
    });

    test('library deprecations', function (assert) {
        moment.lang('dude', {months: ['Movember']});
        assert.equal(moment.locale(), 'dude', 'setting the lang sets the locale');
        assert.equal(moment.lang(), moment.locale());
        assert.equal(moment.langData(), moment.localeData(), 'langData is localeData');
    });

    test('defineLocale', function (assert) {
        moment.locale('en');
        moment.defineLocale('dude', {months: ['Movember']});
        assert.equal(moment().locale(), 'dude', 'defineLocale also sets it');
        assert.equal(moment().locale('dude').locale(), 'dude', 'defineLocale defines a locale');
    });

    test('library convenience', function (assert) {
        moment.locale('something', {week: {dow: 3}});
        moment.locale('something');
        assert.equal(moment.locale(), 'something', 'locale can be used to create the locale too');
    });

    test('firstDayOfWeek firstDayOfYear locale getters', function (assert) {
        moment.locale('something', {week: {dow: 3, doy: 4}});
        moment.locale('something');
        assert.equal(moment.localeData().firstDayOfWeek(), 3, 'firstDayOfWeek');
        assert.equal(moment.localeData().firstDayOfYear(), 4, 'firstDayOfYear');
    });

    test('instance locale method', function (assert) {
        moment.locale('en');

        assert.equal(moment([2012, 5, 6]).format('MMMM'), 'June', 'Normally default to global');
        assert.equal(moment([2012, 5, 6]).locale('es').format('MMMM'), 'Junio', 'Use the instance specific locale');
        assert.equal(moment([2012, 5, 6]).format('MMMM'), 'June', 'Using an instance specific locale does not affect other moments');
    });

    test('instance locale method with array', function (assert) {
        var m = moment().locale(['non-existent', 'fr', 'also-non-existent']);
        assert.equal(m.locale(), 'fr', 'passing an array uses the first valid locale');
        m = moment().locale(['es', 'fr', 'also-non-existent']);
        assert.equal(m.locale(), 'es', 'passing an array uses the first valid locale');
    });

    test('instance getter locale substrings', function (assert) {
        var m = moment();

        m.locale('fr-crap');
        assert.equal(m.locale(), 'fr', 'use substrings');

        m.locale('fr-does-not-exist');
        assert.equal(m.locale(), 'fr', 'uses deep substrings');
    });

    test('instance locale persists with manipulation', function (assert) {
        moment.locale('en');

        assert.equal(moment([2012, 5, 6]).locale('es').add({days: 1}).format('MMMM'), 'Junio', 'With addition');
        assert.equal(moment([2012, 5, 6]).locale('es').day(0).format('MMMM'), 'Junio', 'With day getter');
        assert.equal(moment([2012, 5, 6]).locale('es').endOf('day').format('MMMM'), 'Junio', 'With endOf');
    });

    test('instance locale persists with cloning', function (assert) {
        moment.locale('en');

        var a = moment([2012, 5, 6]).locale('es'),
            b = a.clone(),
            c = moment(a);

        assert.equal(b.format('MMMM'), 'Junio', 'using moment.fn.clone()');
        assert.equal(b.format('MMMM'), 'Junio', 'using moment()');
    });

    test('duration locale method', function (assert) {
        moment.locale('en');

        assert.equal(moment.duration({seconds:  44}).humanize(), 'a few seconds', 'Normally default to global');
        assert.equal(moment.duration({seconds:  44}).locale('es').humanize(), 'unos segundos', 'Use the instance specific locale');
        assert.equal(moment.duration({seconds:  44}).humanize(), 'a few seconds', 'Using an instance specific locale does not affect other durations');
    });

    test('duration locale persists with cloning', function (assert) {
        moment.locale('en');

        var a = moment.duration({seconds:  44}).locale('es'),
            b = moment.duration(a);

        assert.equal(b.humanize(), 'unos segundos', 'using moment.duration()');
    });

    test('changing the global locale doesn\'t affect existing duration instances', function (assert) {
        var mom = moment.duration();
        moment.locale('fr');
        assert.equal('en', mom.locale());
    });

    test('duration deprecations', function (assert) {
        assert.equal(moment.duration().lang(), moment.duration().localeData(), 'duration.lang is the same as duration.localeData');
    });

    test('from and fromNow with invalid date', function (assert) {
        assert.equal(moment(NaN).from(), 'Invalid date', 'moment.from with invalid moment');
        assert.equal(moment(NaN).fromNow(), 'Invalid date', 'moment.fromNow with invalid moment');
    });

    test('from relative time future', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 44})),  'in a few seconds', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 45})),  'in a minute',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 89})),  'in a minute',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({s: 90})),  'in 2 minutes',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 44})),  'in 44 minutes',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 45})),  'in an hour',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 89})),  'in an hour',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({m: 90})),  'in 2 hours',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 5})),   'in 5 hours',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 21})),  'in 21 hours',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 22})),  'in a day',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 35})),  'in a day',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({h: 36})),  'in 2 days',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 1})),   'in a day',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 5})),   'in 5 days',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 25})),  'in 25 days',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 26})),  'in a month',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 30})),  'in a month',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 45})),  'in a month',       '45 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 47})),  'in 2 months',      '47 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 74})),  'in 2 months',      '74 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 78})),  'in 3 months',      '78 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({M: 1})),   'in a month',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({M: 5})),   'in 5 months',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 315})), 'in 10 months',     '315 days = 10 months');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 344})), 'in a year',        '344 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 345})), 'in a year',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({d: 548})), 'in 2 years',       '548 days = in 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({y: 1})),   'in a year',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).subtract({y: 5})),   'in 5 years',       '5 years = 5 years');
    });

    test('from relative time past', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 44})),  'a few seconds ago', '44 seconds = a few seconds');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 45})),  'a minute ago',      '45 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 89})),  'a minute ago',      '89 seconds = a minute');
        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90})),  '2 minutes ago',     '90 seconds = 2 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 44})),  '44 minutes ago',    '44 minutes = 44 minutes');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 45})),  'an hour ago',       '45 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 89})),  'an hour ago',       '89 minutes = an hour');
        assert.equal(start.from(moment([2007, 1, 28]).add({m: 90})),  '2 hours ago',       '90 minutes = 2 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 5})),   '5 hours ago',       '5 hours = 5 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 21})),  '21 hours ago',      '21 hours = 21 hours');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 22})),  'a day ago',         '22 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 35})),  'a day ago',         '35 hours = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({h: 36})),  '2 days ago',        '36 hours = 2 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 1})),   'a day ago',         '1 day = a day');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 5})),   '5 days ago',        '5 days = 5 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 25})),  '25 days ago',       '25 days = 25 days');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 26})),  'a month ago',       '26 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 30})),  'a month ago',       '30 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 43})),  'a month ago',       '43 days = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 46})),  '2 months ago',      '46 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 74})),  '2 months ago',      '75 days = 2 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 76})),  '3 months ago',      '76 days = 3 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 1})),   'a month ago',       '1 month = a month');
        assert.equal(start.from(moment([2007, 1, 28]).add({M: 5})),   '5 months ago',      '5 months = 5 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 315})), '10 months ago',     '315 days = 10 months');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 344})), 'a year ago',        '344 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 345})), 'a year ago',        '345 days = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({d: 548})), '2 years ago',       '548 days = 2 years');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 1})),   'a year ago',        '1 year = a year');
        assert.equal(start.from(moment([2007, 1, 28]).add({y: 5})),   '5 years ago',       '5 years = 5 years');
    });

    test('instance locale used with from', function (assert) {
        moment.locale('en');

        var a = moment([2012, 5, 6]).locale('es'),
            b = moment([2012, 5, 7]);

        assert.equal(a.from(b), 'hace un da', 'preserve locale of first moment');
        assert.equal(b.from(a), 'in a day', 'do not preserve locale of second moment');
    });

    test('instance localeData', function (assert) {
        moment.defineLocale('dude', {week: {dow: 3}});
        assert.equal(moment().locale('dude').localeData()._week.dow, 3);
    });

    test('month name callback function', function (assert) {
        function fakeReplace(m, format) {
            if (/test/.test(format)) {
                return 'test';
            }
            if (m.date() === 1) {
                return 'date';
            }
            return 'default';
        }

        moment.locale('made-up-2', {
            months : fakeReplace,
            monthsShort : fakeReplace,
            weekdays : fakeReplace,
            weekdaysShort : fakeReplace,
            weekdaysMin : fakeReplace
        });

        assert.equal(moment().format('[test] dd ddd dddd MMM MMMM'), 'test test test test test test', 'format month name function should be able to access the format string');
        assert.equal(moment([2011, 0, 1]).format('dd ddd dddd MMM MMMM'), 'date date date date date', 'format month name function should be able to access the moment object');
        assert.equal(moment([2011, 0, 2]).format('dd ddd dddd MMM MMMM'), 'default default default default default', 'format month name function should be able to access the moment object');
    });

    test('changing parts of a locale config', function (assert) {
        moment.locale('partial-lang', {
            months : 'a b c d e f g h i j k l'.split(' ')
        });

        assert.equal(moment([2011, 0, 1]).format('MMMM'), 'a', 'should be able to set locale values when creating the localeuage');

        moment.locale('partial-lang', {
            monthsShort : 'A B C D E F G H I J K L'.split(' ')
        });

        assert.equal(moment([2011, 0, 1]).format('MMMM MMM'), 'a A', 'should be able to set locale values after creating the localeuage');
    });

    test('start/endOf week feature for first-day-is-monday locales', function (assert) {
        moment.locale('monday-lang', {
            week : {
                dow : 1 // Monday is the first day of the week
            }
        });

        moment.locale('monday-lang');
        assert.equal(moment([2013, 0, 1]).startOf('week').day(), 1, 'for locale monday-lang first day of the week should be monday');
        assert.equal(moment([2013, 0, 1]).endOf('week').day(), 0, 'for locale monday-lang last day of the week should be sunday');
    });

    test('meridiem parsing', function (assert) {
        moment.locale('meridiem-parsing', {
            meridiemParse : /[bd]/i,
            isPM : function (input) {
                return input === 'b';
            }
        });

        moment.locale('meridiem-parsing');
        assert.equal(moment('2012-01-01 3b', 'YYYY-MM-DD ha').hour(), 15, 'Custom parsing of meridiem should work');
        assert.equal(moment('2012-01-01 3d', 'YYYY-MM-DD ha').hour(), 3, 'Custom parsing of meridiem should work');
    });

    test('invalid date formatting', function (assert) {
        moment.locale('has-invalid', {
            invalidDate: 'KHAAAAAAAAAAAN!'
        });

        assert.equal(moment.invalid().format(), 'KHAAAAAAAAAAAN!');
        assert.equal(moment.invalid().format('YYYY-MM-DD'), 'KHAAAAAAAAAAAN!');
    });

    test('return locale name', function (assert) {
        var registered = moment.locale('return-this', {});

        assert.equal(registered, 'return-this', 'returns the locale configured');
    });

    test('changing the global locale doesn\'t affect existing instances', function (assert) {
        var mom = moment();
        moment.locale('fr');
        assert.equal('en', mom.locale());
    });

    test('setting a language on instance returns the original moment for chaining', function (assert) {
        var mom = moment();

        assert.equal(mom.lang('fr'), mom, 'setting the language (lang) returns the original moment for chaining');
        assert.equal(mom.locale('it'), mom, 'setting the language (locale) returns the original moment for chaining');
    });

    test('lang(key) changes the language of the instance', function (assert) {
        var m = moment().month(0);
        m.lang('fr');
        assert.equal(m.locale(), 'fr', 'm.lang(key) changes instance locale');
    });

    test('moment#locale(false) resets to global locale', function (assert) {
        var m = moment();

        moment.locale('fr');
        m.locale('it');

        assert.equal(moment.locale(), 'fr', 'global locale is it');
        assert.equal(m.locale(), 'it', 'instance locale is it');
        m.locale(false);
        assert.equal(m.locale(), 'fr', 'instance locale reset to global locale');
    });

    test('moment().locale with missing key doesn\'t change locale', function (assert) {
        assert.equal(moment().locale('boo').localeData(), moment.localeData(),
                'preserve global locale in case of bad locale id');
    });

    test('moment().lang with missing key doesn\'t change locale', function (assert) {
        assert.equal(moment().lang('boo').localeData(), moment.localeData(),
                'preserve global locale in case of bad locale id');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('min max');

    test('min', function (assert) {
        var now = moment(),
            future = now.clone().add(1, 'month'),
            past = now.clone().subtract(1, 'month'),
            invalid = moment.invalid();

        assert.equal(moment.min(now, future, past), past, 'min(now, future, past)');
        assert.equal(moment.min(future, now, past), past, 'min(future, now, past)');
        assert.equal(moment.min(future, past, now), past, 'min(future, past, now)');
        assert.equal(moment.min(past, future, now), past, 'min(past, future, now)');
        assert.equal(moment.min(now, past), past, 'min(now, past)');
        assert.equal(moment.min(past, now), past, 'min(past, now)');
        assert.equal(moment.min(now), now, 'min(now, past)');

        assert.equal(moment.min([now, future, past]), past, 'min([now, future, past])');
        assert.equal(moment.min([now, past]), past, 'min(now, past)');
        assert.equal(moment.min([now]), now, 'min(now)');

        assert.equal(moment.min([now, invalid]), invalid, 'min(now, invalid)');
        assert.equal(moment.min([invalid, now]), invalid, 'min(invalid, now)');
    });

    test('max', function (assert) {
        var now = moment(),
            future = now.clone().add(1, 'month'),
            past = now.clone().subtract(1, 'month'),
            invalid = moment.invalid();

        assert.equal(moment.max(now, future, past), future, 'max(now, future, past)');
        assert.equal(moment.max(future, now, past), future, 'max(future, now, past)');
        assert.equal(moment.max(future, past, now), future, 'max(future, past, now)');
        assert.equal(moment.max(past, future, now), future, 'max(past, future, now)');
        assert.equal(moment.max(now, past), now, 'max(now, past)');
        assert.equal(moment.max(past, now), now, 'max(past, now)');
        assert.equal(moment.max(now), now, 'max(now, past)');

        assert.equal(moment.max([now, future, past]), future, 'max([now, future, past])');
        assert.equal(moment.max([now, past]), now, 'max(now, past)');
        assert.equal(moment.max([now]), now, 'max(now)');

        assert.equal(moment.max([now, invalid]), invalid, 'max(now, invalid)');
        assert.equal(moment.max([invalid, now]), invalid, 'max(invalid, now)');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('mutable');

    test('manipulation methods', function (assert) {
        var m = moment();

        assert.equal(m, m.year(2011), 'year() should be mutable');
        assert.equal(m, m.month(1), 'month() should be mutable');
        assert.equal(m, m.hours(7), 'hours() should be mutable');
        assert.equal(m, m.minutes(33), 'minutes() should be mutable');
        assert.equal(m, m.seconds(44), 'seconds() should be mutable');
        assert.equal(m, m.milliseconds(55), 'milliseconds() should be mutable');
        assert.equal(m, m.day(2), 'day() should be mutable');
        assert.equal(m, m.startOf('week'), 'startOf() should be mutable');
        assert.equal(m, m.add(1, 'days'), 'add() should be mutable');
        assert.equal(m, m.subtract(2, 'years'), 'subtract() should be mutable');
        assert.equal(m, m.local(), 'local() should be mutable');
        assert.equal(m, m.utc(), 'utc() should be mutable');
    });

    test('non mutable methods', function (assert) {
        var m = moment();
        assert.notEqual(m, m.clone(), 'clone() should not be mutable');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('normalize units');

    test('normalize units', function (assert) {
        var fullKeys = ['year', 'quarter', 'month', 'isoWeek', 'week', 'day', 'hour', 'minute', 'second', 'millisecond', 'date', 'dayOfYear', 'weekday', 'isoWeekday', 'weekYear', 'isoWeekYear'],
            aliases = ['y', 'Q', 'M', 'W', 'w', 'd', 'h', 'm', 's', 'ms', 'D', 'DDD', 'e', 'E', 'gg', 'GG'],
            length = fullKeys.length,
            fullKey,
            fullKeyCaps,
            fullKeyPlural,
            fullKeyCapsPlural,
            fullKeyLower,
            alias,
            index;

        for (index = 0; index < length; index += 1) {
            fullKey = fullKeys[index];
            fullKeyCaps = fullKey.toUpperCase();
            fullKeyLower = fullKey.toLowerCase();
            fullKeyPlural = fullKey + 's';
            fullKeyCapsPlural = fullKeyCaps + 's';
            alias = aliases[index];
            assert.equal(moment.normalizeUnits(fullKey), fullKey, 'Testing full key ' + fullKey);
            assert.equal(moment.normalizeUnits(fullKeyCaps), fullKey, 'Testing full key capitalised ' + fullKey);
            assert.equal(moment.normalizeUnits(fullKeyPlural), fullKey, 'Testing full key plural ' + fullKey);
            assert.equal(moment.normalizeUnits(fullKeyCapsPlural), fullKey, 'Testing full key capitalised and plural ' + fullKey);
            assert.equal(moment.normalizeUnits(alias), fullKey, 'Testing alias ' + fullKey);
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('parsing flags');

    function flags () {
        return moment.apply(null, arguments).parsingFlags();
    }

    test('overflow with array', function (assert) {
        //months
        assert.equal(flags([2010, 0]).overflow, -1, 'month 0 valid');
        assert.equal(flags([2010, 1]).overflow, -1, 'month 1 valid');
        assert.equal(flags([2010, -1]).overflow, 1, 'month -1 invalid');
        assert.equal(flags([2100, 12]).overflow, 1, 'month 12 invalid');

        //days
        assert.equal(flags([2010, 1, 16]).overflow, -1, 'date valid');
        assert.equal(flags([2010, 1, -1]).overflow, 2, 'date -1 invalid');
        assert.equal(flags([2010, 1, 0]).overflow, 2, 'date 0 invalid');
        assert.equal(flags([2010, 1, 32]).overflow, 2, 'date 32 invalid');
        assert.equal(flags([2012, 1, 29]).overflow, -1, 'date leap year valid');
        assert.equal(flags([2010, 1, 29]).overflow, 2, 'date leap year invalid');

        //hours
        assert.equal(flags([2010, 1, 1, 8]).overflow, -1, 'hour valid');
        assert.equal(flags([2010, 1, 1, 0]).overflow, -1, 'hour 0 valid');
        assert.equal(flags([2010, 1, 1, -1]).overflow, 3, 'hour -1 invalid');
        assert.equal(flags([2010, 1, 1, 25]).overflow, 3, 'hour 25 invalid');
        assert.equal(flags([2010, 1, 1, 24, 1]).overflow, 3, 'hour 24:01 invalid');

        //minutes
        assert.equal(flags([2010, 1, 1, 8, 15]).overflow, -1, 'minute valid');
        assert.equal(flags([2010, 1, 1, 8, 0]).overflow, -1, 'minute 0 valid');
        assert.equal(flags([2010, 1, 1, 8, -1]).overflow, 4, 'minute -1 invalid');
        assert.equal(flags([2010, 1, 1, 8, 60]).overflow, 4, 'minute 60 invalid');

        //seconds
        assert.equal(flags([2010, 1, 1, 8, 15, 12]).overflow, -1, 'second valid');
        assert.equal(flags([2010, 1, 1, 8, 15, 0]).overflow, -1, 'second 0 valid');
        assert.equal(flags([2010, 1, 1, 8, 15, -1]).overflow, 5, 'second -1 invalid');
        assert.equal(flags([2010, 1, 1, 8, 15, 60]).overflow, 5, 'second 60 invalid');

        //milliseconds
        assert.equal(flags([2010, 1, 1, 8, 15, 12, 345]).overflow, -1, 'millisecond valid');
        assert.equal(flags([2010, 1, 1, 8, 15, 12, 0]).overflow, -1, 'millisecond 0 valid');
        assert.equal(flags([2010, 1, 1, 8, 15, 12, -1]).overflow, 6, 'millisecond -1 invalid');
        assert.equal(flags([2010, 1, 1, 8, 15, 12, 1000]).overflow, 6, 'millisecond 1000 invalid');

        // 24 hrs
        assert.equal(flags([2010, 1, 1, 24, 0, 0, 0]).overflow, -1, '24:00:00.000 is fine');
        assert.equal(flags([2010, 1, 1, 24, 1, 0, 0]).overflow, 3, '24:01:00.000 is wrong hour');
        assert.equal(flags([2010, 1, 1, 24, 0, 1, 0]).overflow, 3, '24:00:01.000 is wrong hour');
        assert.equal(flags([2010, 1, 1, 24, 0, 0, 1]).overflow, 3, '24:00:00.001 is wrong hour');
    });

    test('overflow without format', function (assert) {
        //months
        assert.equal(flags('2001-01', 'YYYY-MM').overflow, -1, 'month 1 valid');
        assert.equal(flags('2001-12', 'YYYY-MM').overflow, -1, 'month 12 valid');
        assert.equal(flags('2001-13', 'YYYY-MM').overflow, 1, 'month 13 invalid');

        //days
        assert.equal(flags('2010-01-16', 'YYYY-MM-DD').overflow, -1, 'date 16 valid');
        assert.equal(flags('2010-01-0',  'YYYY-MM-DD').overflow, 2, 'date 0 invalid');
        assert.equal(flags('2010-01-32', 'YYYY-MM-DD').overflow, 2, 'date 32 invalid');
        assert.equal(flags('2012-02-29', 'YYYY-MM-DD').overflow, -1, 'date leap year valid');
        assert.equal(flags('2010-02-29', 'YYYY-MM-DD').overflow, 2, 'date leap year invalid');

        //days of the year
        assert.equal(flags('2010 300', 'YYYY DDDD').overflow, -1, 'day 300 of year valid');
        assert.equal(flags('2010 365', 'YYYY DDDD').overflow, -1, 'day 365 of year valid');
        assert.equal(flags('2010 366', 'YYYY DDDD').overflow, 2, 'day 366 of year invalid');
        assert.equal(flags('2012 366', 'YYYY DDDD').overflow, -1, 'day 366 of leap year valid');
        assert.equal(flags('2012 367', 'YYYY DDDD').overflow, 2, 'day 367 of leap year invalid');

        //hours
        assert.equal(flags('08', 'HH').overflow, -1, 'hour valid');
        assert.equal(flags('00', 'HH').overflow, -1, 'hour 0 valid');
        assert.equal(flags('25', 'HH').overflow, 3, 'hour 25 invalid');
        assert.equal(flags('24:01', 'HH:mm').overflow, 3, 'hour 24:01 invalid');

        //minutes
        assert.equal(flags('08:15', 'HH:mm').overflow, -1, 'minute valid');
        assert.equal(flags('08:00', 'HH:mm').overflow, -1, 'minute 0 valid');
        assert.equal(flags('08:60', 'HH:mm').overflow, 4, 'minute 60 invalid');

        //seconds
        assert.equal(flags('08:15:12', 'HH:mm:ss').overflow, -1, 'second valid');
        assert.equal(flags('08:15:00', 'HH:mm:ss').overflow, -1, 'second 0 valid');
        assert.equal(flags('08:15:60', 'HH:mm:ss').overflow, 5, 'second 60 invalid');

        //milliseconds
        assert.equal(flags('08:15:12:345', 'HH:mm:ss:SSSS').overflow, -1, 'millisecond valid');
        assert.equal(flags('08:15:12:000', 'HH:mm:ss:SSSS').overflow, -1, 'millisecond 0 valid');

        //this is OK because we don't match the last digit, so it's 100 ms
        assert.equal(flags('08:15:12:1000', 'HH:mm:ss:SSSS').overflow, -1, 'millisecond 1000 actually valid');
    });

    test('extra tokens', function (assert) {
        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD').unusedTokens, [], 'nothing extra');
        assert.deepEqual(flags('1982-05', 'YYYY-MM-DD').unusedTokens, ['DD'], 'extra formatting token');
        assert.deepEqual(flags('1982', 'YYYY-MM-DD').unusedTokens, ['MM', 'DD'], 'multiple extra formatting tokens');
        assert.deepEqual(flags('1982-05', 'YYYY-MM-').unusedTokens, [], 'extra non-formatting token');
        assert.deepEqual(flags('1982-05-', 'YYYY-MM-DD').unusedTokens, ['DD'], 'non-extra non-formatting token');
        assert.deepEqual(flags('1982 05 1982', 'YYYY-MM-DD').unusedTokens, [], 'different non-formatting token');
    });

    test('extra tokens strict', function (assert) {
        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD', true).unusedTokens, [], 'nothing extra');
        assert.deepEqual(flags('1982-05', 'YYYY-MM-DD', true).unusedTokens, ['-', 'DD'], 'extra formatting token');
        assert.deepEqual(flags('1982', 'YYYY-MM-DD', true).unusedTokens, ['-', 'MM', '-', 'DD'], 'multiple extra formatting tokens');
        assert.deepEqual(flags('1982-05', 'YYYY-MM-', true).unusedTokens, ['-'], 'extra non-formatting token');
        assert.deepEqual(flags('1982-05-', 'YYYY-MM-DD', true).unusedTokens, ['DD'], 'non-extra non-formatting token');
        assert.deepEqual(flags('1982 05 1982', 'YYYY-MM-DD', true).unusedTokens, ['-', '-'], 'different non-formatting token');
    });

    test('unused input', function (assert) {
        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD').unusedInput, [], 'normal input');
        assert.deepEqual(flags('1982-05-25 this is more stuff', 'YYYY-MM-DD').unusedInput, [' this is more stuff'], 'trailing nonsense');
        assert.deepEqual(flags('1982-05-25 09:30', 'YYYY-MM-DD').unusedInput, [' 09:30'], ['trailing legit-looking input']);
        assert.deepEqual(flags('1982-05-25 some junk', 'YYYY-MM-DD [some junk]').unusedInput, [], 'junk that actually gets matched');
        assert.deepEqual(flags('stuff at beginning 1982-05-25', 'YYYY-MM-DD').unusedInput, ['stuff at beginning '], 'leading junk');
        assert.deepEqual(flags('junk 1982 more junk 05 yet more junk25', 'YYYY-MM-DD').unusedInput, ['junk ', ' more junk ', ' yet more junk'], 'interstitial junk');
    });

    test('unused input strict', function (assert) {
        assert.deepEqual(flags('1982-05-25', 'YYYY-MM-DD', true).unusedInput, [], 'normal input');
        assert.deepEqual(flags('1982-05-25 this is more stuff', 'YYYY-MM-DD', true).unusedInput, [' this is more stuff'], 'trailing nonsense');
        assert.deepEqual(flags('1982-05-25 09:30', 'YYYY-MM-DD', true).unusedInput, [' 09:30'], ['trailing legit-looking input']);
        assert.deepEqual(flags('1982-05-25 some junk', 'YYYY-MM-DD [some junk]', true).unusedInput, [], 'junk that actually gets matched');
        assert.deepEqual(flags('stuff at beginning 1982-05-25', 'YYYY-MM-DD', true).unusedInput, ['stuff at beginning '], 'leading junk');
        assert.deepEqual(flags('junk 1982 more junk 05 yet more junk25', 'YYYY-MM-DD', true).unusedInput, ['junk ', ' more junk ', ' yet more junk'], 'interstitial junk');
    });

    test('chars left over', function (assert) {
        assert.equal(flags('1982-05-25', 'YYYY-MM-DD').charsLeftOver, 0, 'normal input');
        assert.equal(flags('1982-05-25 this is more stuff', 'YYYY-MM-DD').charsLeftOver, ' this is more stuff'.length, 'trailing nonsense');
        assert.equal(flags('1982-05-25 09:30', 'YYYY-MM-DD').charsLeftOver, ' 09:30'.length, 'trailing legit-looking input');
        assert.equal(flags('stuff at beginning 1982-05-25', 'YYYY-MM-DD').charsLeftOver, 'stuff at beginning '.length, 'leading junk');
        assert.equal(flags('1982 junk 05 more junk25', 'YYYY-MM-DD').charsLeftOver, [' junk ', ' more junk'].join('').length, 'interstitial junk');
        assert.equal(flags('stuff at beginning 1982 junk 05 more junk25', 'YYYY-MM-DD').charsLeftOver, ['stuff at beginning ', ' junk ', ' more junk'].join('').length, 'leading and interstitial junk');
    });

    test('empty', function (assert) {
        assert.equal(flags('1982-05-25', 'YYYY-MM-DD').empty, false, 'normal input');
        assert.equal(flags('nothing here', 'YYYY-MM-DD').empty, true, 'pure garbage');
        assert.equal(flags('junk but has the number 2000 in it', 'YYYY-MM-DD').empty, false, 'only mostly garbage');
        assert.equal(flags('', 'YYYY-MM-DD').empty, true, 'empty string');
        assert.equal(flags('', 'YYYY-MM-DD').empty, true, 'blank string');
    });

    test('null', function (assert) {
        assert.equal(flags('1982-05-25', 'YYYY-MM-DD').nullInput, false, 'normal input');
        assert.equal(flags(null).nullInput, true, 'just null');
        assert.equal(flags(null, 'YYYY-MM-DD').nullInput, true, 'null with format');
    });

    test('invalid month', function (assert) {
        assert.equal(flags('1982 May', 'YYYY MMMM').invalidMonth, null, 'normal input');
        assert.equal(flags('1982 Laser', 'YYYY MMMM').invalidMonth, 'Laser', 'bad month name');
    });

    test('empty format array', function (assert) {
        assert.equal(flags('1982 May', ['YYYY MMM']).invalidFormat, false, 'empty format array');
        assert.equal(flags('1982 May', []).invalidFormat, true, 'empty format array');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    var symbolMap = {
            '1': '!',
            '2': '@',
            '3': '#',
            '4': '$',
            '5': '%',
            '6': '^',
            '7': '&',
            '8': '*',
            '9': '(',
            '0': ')'
        },
        numberMap = {
            '!': '1',
            '@': '2',
            '#': '3',
            '$': '4',
            '%': '5',
            '^': '6',
            '&': '7',
            '*': '8',
            '(': '9',
            ')': '0'
        };

    module('preparse and postformat', {
        setup: function () {
            moment.locale('symbol', {
                preparse: function (string) {
                    return string.replace(/[!@#$%\^&*()]/g, function (match) {
                        return numberMap[match];
                    });
                },

                postformat: function (string) {
                    return string.replace(/\d/g, function (match) {
                        return symbolMap[match];
                    });
                }
            });
        }
    });

    test('transform', function (assert) {
        assert.equal(moment.utc('@)!@-)*-@&', 'YYYY-MM-DD').unix(), 1346025600, 'preparse string + format');
        assert.equal(moment.utc('@)!@-)*-@&').unix(), 1346025600, 'preparse ISO8601 string');
        assert.equal(moment.unix(1346025600).utc().format('YYYY-MM-DD'), '@)!@-)*-@&', 'postformat');
    });

    test('transform from', function (assert) {
        var start = moment([2007, 1, 28]);

        assert.equal(start.from(moment([2007, 1, 28]).add({s: 90}), true), '@ minutes', 'postformat should work on moment.fn.from');
        assert.equal(moment().add(6, 'd').fromNow(true), '^ days', 'postformat should work on moment.fn.fromNow');
        assert.equal(moment.duration(10, 'h').humanize(), '!) hours', 'postformat should work on moment.duration.fn.humanize');
    });

    test('calendar day', function (assert) {
        var a = moment().hours(2).minutes(0).seconds(0);

        assert.equal(moment(a).calendar(),                   'Today at @:)) AM',     'today at the same time');
        assert.equal(moment(a).add({m: 25}).calendar(),      'Today at @:@% AM',     'Now plus 25 min');
        assert.equal(moment(a).add({h: 1}).calendar(),       'Today at #:)) AM',     'Now plus 1 hour');
        assert.equal(moment(a).add({d: 1}).calendar(),       'Tomorrow at @:)) AM',  'tomorrow at the same time');
        assert.equal(moment(a).subtract({h: 1}).calendar(),  'Today at !:)) AM',     'Now minus 1 hour');
        assert.equal(moment(a).subtract({d: 1}).calendar(),  'Yesterday at @:)) AM', 'yesterday at the same time');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('quarter');

    test('library quarter getter', function (assert) {
        assert.equal(moment([1985,  1,  4]).quarter(), 1, 'Feb  4 1985 is Q1');
        assert.equal(moment([2029,  8, 18]).quarter(), 3, 'Sep 18 2029 is Q3');
        assert.equal(moment([2013,  3, 24]).quarter(), 2, 'Apr 24 2013 is Q2');
        assert.equal(moment([2015,  2,  5]).quarter(), 1, 'Mar  5 2015 is Q1');
        assert.equal(moment([1970,  0,  2]).quarter(), 1, 'Jan  2 1970 is Q1');
        assert.equal(moment([2001, 11, 12]).quarter(), 4, 'Dec 12 2001 is Q4');
        assert.equal(moment([2000,  0,  2]).quarter(), 1, 'Jan  2 2000 is Q1');
    });

    test('quarter setter singular', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.quarter(2).month(), 4, 'set same quarter');
        assert.equal(m.quarter(3).month(), 7, 'set 3rd quarter');
        assert.equal(m.quarter(1).month(), 1, 'set 1st quarter');
        assert.equal(m.quarter(4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter plural', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.quarters(2).month(), 4, 'set same quarter');
        assert.equal(m.quarters(3).month(), 7, 'set 3rd quarter');
        assert.equal(m.quarters(1).month(), 1, 'set 1st quarter');
        assert.equal(m.quarters(4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter programmatic', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.set('quarter', 2).month(), 4, 'set same quarter');
        assert.equal(m.set('quarter', 3).month(), 7, 'set 3rd quarter');
        assert.equal(m.set('quarter', 1).month(), 1, 'set 1st quarter');
        assert.equal(m.set('quarter', 4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter programmatic plural', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.set('quarters', 2).month(), 4, 'set same quarter');
        assert.equal(m.set('quarters', 3).month(), 7, 'set 3rd quarter');
        assert.equal(m.set('quarters', 1).month(), 1, 'set 1st quarter');
        assert.equal(m.set('quarters', 4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter programmatic abbr', function (assert) {
        var m = moment([2014, 4, 11]);
        assert.equal(m.set('Q', 2).month(), 4, 'set same quarter');
        assert.equal(m.set('Q', 3).month(), 7, 'set 3rd quarter');
        assert.equal(m.set('Q', 1).month(), 1, 'set 1st quarter');
        assert.equal(m.set('Q', 4).month(), 10, 'set 4th quarter');
    });

    test('quarter setter only month changes', function (assert) {
        var m = moment([2014, 4, 11, 1, 2, 3, 4]).quarter(4);
        assert.equal(m.year(), 2014, 'keep year');
        assert.equal(m.month(), 10, 'set month');
        assert.equal(m.date(), 11, 'keep date');
        assert.equal(m.hour(), 1, 'keep hour');
        assert.equal(m.minute(), 2, 'keep minutes');
        assert.equal(m.second(), 3, 'keep seconds');
        assert.equal(m.millisecond(), 4, 'keep milliseconds');
    });

    test('quarter setter bubble to next year', function (assert) {
        var m = moment([2014, 4, 11, 1, 2, 3, 4]).quarter(7);
        assert.equal(m.year(), 2015, 'year bubbled');
        assert.equal(m.month(), 7, 'set month');
        assert.equal(m.date(), 11, 'keep date');
        assert.equal(m.hour(), 1, 'keep hour');
        assert.equal(m.minute(), 2, 'keep minutes');
        assert.equal(m.second(), 3, 'keep seconds');
        assert.equal(m.millisecond(), 4, 'keep milliseconds');
    });

    test('quarter diff', function (assert) {
        assert.equal(moment('2014-01-01').diff(moment('2014-04-01'), 'quarter'),
                -1, 'diff -1 quarter');
        assert.equal(moment('2014-04-01').diff(moment('2014-01-01'), 'quarter'),
                1, 'diff 1 quarter');
        assert.equal(moment('2014-05-01').diff(moment('2014-01-01'), 'quarter'),
                1, 'diff 1 quarter');
        assert.ok(Math.abs((4 / 3) - moment('2014-05-01').diff(
                        moment('2014-01-01'), 'quarter', true)) < 0.00001,
                'diff 1 1/3 quarter');
        assert.equal(moment('2015-01-01').diff(moment('2014-01-01'), 'quarter'),
                4, 'diff 4 quarters');
    });

    test('quarter setter bubble to previous year', function (assert) {
        var m = moment([2014, 4, 11, 1, 2, 3, 4]).quarter(-3);
        assert.equal(m.year(), 2013, 'year bubbled');
        assert.equal(m.month(), 1, 'set month');
        assert.equal(m.date(), 11, 'keep date');
        assert.equal(m.hour(), 1, 'keep hour');
        assert.equal(m.minute(), 2, 'keep minutes');
        assert.equal(m.second(), 3, 'keep seconds');
        assert.equal(m.millisecond(), 4, 'keep milliseconds');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('relative time');

    test('default thresholds fromNow', function (assert) {
        var a = moment();

        // Seconds to minutes threshold
        a.subtract(44, 'seconds');
        assert.equal(a.fromNow(), 'a few seconds ago', 'Below default seconds to minutes threshold');
        a.subtract(1, 'seconds');
        assert.equal(a.fromNow(), 'a minute ago', 'Above default seconds to minutes threshold');

        // Minutes to hours threshold
        a = moment();
        a.subtract(44, 'minutes');
        assert.equal(a.fromNow(), '44 minutes ago', 'Below default minute to hour threshold');
        a.subtract(1, 'minutes');
        assert.equal(a.fromNow(), 'an hour ago', 'Above default minute to hour threshold');

        // Hours to days threshold
        a = moment();
        a.subtract(21, 'hours');
        assert.equal(a.fromNow(), '21 hours ago', 'Below default hours to day threshold');
        a.subtract(1, 'hours');
        assert.equal(a.fromNow(), 'a day ago', 'Above default hours to day threshold');

        // Days to month threshold
        a = moment();
        a.subtract(25, 'days');
        assert.equal(a.fromNow(), '25 days ago', 'Below default days to month (singular) threshold');
        a.subtract(1, 'days');
        assert.equal(a.fromNow(), 'a month ago', 'Above default days to month (singular) threshold');

        // months to year threshold
        a = moment();
        a.subtract(10, 'months');
        assert.equal(a.fromNow(), '10 months ago', 'Below default days to years threshold');
        a.subtract(1, 'month');
        assert.equal(a.fromNow(), 'a year ago', 'Above default days to years threshold');
    });

    test('default thresholds toNow', function (assert) {
        var a = moment();

        // Seconds to minutes threshold
        a.subtract(44, 'seconds');
        assert.equal(a.toNow(), 'in a few seconds', 'Below default seconds to minutes threshold');
        a.subtract(1, 'seconds');
        assert.equal(a.toNow(), 'in a minute', 'Above default seconds to minutes threshold');

        // Minutes to hours threshold
        a = moment();
        a.subtract(44, 'minutes');
        assert.equal(a.toNow(), 'in 44 minutes', 'Below default minute to hour threshold');
        a.subtract(1, 'minutes');
        assert.equal(a.toNow(), 'in an hour', 'Above default minute to hour threshold');

        // Hours to days threshold
        a = moment();
        a.subtract(21, 'hours');
        assert.equal(a.toNow(), 'in 21 hours', 'Below default hours to day threshold');
        a.subtract(1, 'hours');
        assert.equal(a.toNow(), 'in a day', 'Above default hours to day threshold');

        // Days to month threshold
        a = moment();
        a.subtract(25, 'days');
        assert.equal(a.toNow(), 'in 25 days', 'Below default days to month (singular) threshold');
        a.subtract(1, 'days');
        assert.equal(a.toNow(), 'in a month', 'Above default days to month (singular) threshold');

        // months to year threshold
        a = moment();
        a.subtract(10, 'months');
        assert.equal(a.toNow(), 'in 10 months', 'Below default days to years threshold');
        a.subtract(1, 'month');
        assert.equal(a.toNow(), 'in a year', 'Above default days to years threshold');
    });

    test('custom thresholds', function (assert) {
        // Seconds to minutes threshold
        moment.relativeTimeThreshold('s', 55);

        var a = moment();
        a.subtract(54, 'seconds');
        assert.equal(a.fromNow(), 'a few seconds ago', 'Below custom seconds to minutes threshold');
        a.subtract(1, 'seconds');
        assert.equal(a.fromNow(), 'a minute ago', 'Above custom seconds to minutes threshold');

        moment.relativeTimeThreshold('s', 45);

        // Minutes to hours threshold
        moment.relativeTimeThreshold('m', 55);
        a = moment();
        a.subtract(54, 'minutes');
        assert.equal(a.fromNow(), '54 minutes ago', 'Below custom minutes to hours threshold');
        a.subtract(1, 'minutes');
        assert.equal(a.fromNow(), 'an hour ago', 'Above custom minutes to hours threshold');
        moment.relativeTimeThreshold('m', 45);

        // Hours to days threshold
        moment.relativeTimeThreshold('h', 24);
        a = moment();
        a.subtract(23, 'hours');
        assert.equal(a.fromNow(), '23 hours ago', 'Below custom hours to days threshold');
        a.subtract(1, 'hours');
        assert.equal(a.fromNow(), 'a day ago', 'Above custom hours to days threshold');
        moment.relativeTimeThreshold('h', 22);

        // Days to month threshold
        moment.relativeTimeThreshold('d', 28);
        a = moment();
        a.subtract(27, 'days');
        assert.equal(a.fromNow(), '27 days ago', 'Below custom days to month (singular) threshold');
        a.subtract(1, 'days');
        assert.equal(a.fromNow(), 'a month ago', 'Above custom days to month (singular) threshold');
        moment.relativeTimeThreshold('d', 26);

        // months to years threshold
        moment.relativeTimeThreshold('M', 9);
        a = moment();
        a.subtract(8, 'months');
        assert.equal(a.fromNow(), '8 months ago', 'Below custom days to years threshold');
        a.subtract(1, 'months');
        assert.equal(a.fromNow(), 'a year ago', 'Above custom days to years threshold');
        moment.relativeTimeThreshold('M', 11);
    });

    test('retrive threshold settings', function (assert) {
        moment.relativeTimeThreshold('m', 45);
        var minuteThreshold = moment.relativeTimeThreshold('m');

        assert.equal(minuteThreshold, 45, 'Can retrieve minute setting');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('start and end of units');

    test('start of year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('year'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('years'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('y');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 0, 'strip out the month');
        assert.equal(m.date(), 1, 'strip out the day');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of year', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('year'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('years'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('y');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 11, 'set the month');
        assert.equal(m.date(), 31, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of quarter', function (assert) {
        var m = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).startOf('quarter'),
            ms = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).startOf('quarters'),
            ma = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).startOf('Q');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.quarter(), 2, 'keep the quarter');
        assert.equal(m.month(), 3, 'strip out the month');
        assert.equal(m.date(), 1, 'strip out the day');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of quarter', function (assert) {
        var m = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).endOf('quarter'),
            ms = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).endOf('quarters'),
            ma = moment(new Date(2011, 4, 2, 3, 4, 5, 6)).endOf('Q');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.quarter(), 2, 'keep the quarter');
        assert.equal(m.month(), 5, 'set the month');
        assert.equal(m.date(), 30, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of month', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('month'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('months'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('M');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 1, 'strip out the day');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of month', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('month'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('months'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('M');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 28, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of week', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('week'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('weeks'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('w');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 0, 'rolls back to January');
        assert.equal(m.day(), 0, 'set day of week');
        assert.equal(m.date(), 30, 'set correct date');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of week', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('week'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('weeks'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('weeks');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.day(), 6, 'set the day of the week');
        assert.equal(m.date(), 5, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of iso-week', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('isoWeek'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('isoWeeks'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('W');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 0, 'rollback to January');
        assert.equal(m.isoWeekday(), 1, 'set day of iso-week');
        assert.equal(m.date(), 31, 'set correct date');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of iso-week', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('isoWeek'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('isoWeeks'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('W');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.isoWeekday(), 7, 'set the day of the week');
        assert.equal(m.date(), 6, 'set the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('day'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('days'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('d');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 0, 'strip out the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of day', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('day'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('days'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('d');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 23, 'set the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('hour'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('hours'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('h');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 0, 'strip out the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of hour', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('hour'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('hours'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('h');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 59, 'set the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('minute'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('minutes'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('m');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 4, 'keep the minutes');
        assert.equal(m.seconds(), 0, 'strip out the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of minute', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('minute'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('minutes'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('m');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 4, 'keep the minutes');
        assert.equal(m.seconds(), 59, 'set the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('start of second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('second'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('seconds'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).startOf('s');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 4, 'keep the minutes');
        assert.equal(m.seconds(), 5, 'keep the the seconds');
        assert.equal(m.milliseconds(), 0, 'strip out the milliseconds');
    });

    test('end of second', function (assert) {
        var m = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('second'),
            ms = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('seconds'),
            ma = moment(new Date(2011, 1, 2, 3, 4, 5, 6)).endOf('s');
        assert.equal(+m, +ms, 'Plural or singular should work');
        assert.equal(+m, +ma, 'Full or abbreviated should work');
        assert.equal(m.year(), 2011, 'keep the year');
        assert.equal(m.month(), 1, 'keep the month');
        assert.equal(m.date(), 2, 'keep the day');
        assert.equal(m.hours(), 3, 'keep the hours');
        assert.equal(m.minutes(), 4, 'keep the minutes');
        assert.equal(m.seconds(), 5, 'keep the seconds');
        assert.equal(m.milliseconds(), 999, 'set the seconds');
    });

    test('startOf across DST +1', function (assert) {
        var oldUpdateOffset = moment.updateOffset,
            // Based on a real story somewhere in America/Los_Angeles
            dstAt = moment('2014-03-09T02:00:00-08:00').parseZone(),
            m;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.isBefore(dstAt)) {
                mom.utcOffset(-8, keepTime);
            } else {
                mom.utcOffset(-7, keepTime);
            }
        };

        m = moment('2014-03-15T00:00:00-07:00').parseZone();
        m.startOf('M');
        assert.equal(m.format(), '2014-03-01T00:00:00-08:00', 'startOf(\'month\') across +1');

        m = moment('2014-03-09T09:00:00-07:00').parseZone();
        m.startOf('d');
        assert.equal(m.format(), '2014-03-09T00:00:00-08:00', 'startOf(\'day\') across +1');

        m = moment('2014-03-09T03:05:00-07:00').parseZone();
        m.startOf('h');
        assert.equal(m.format(), '2014-03-09T03:00:00-07:00', 'startOf(\'hour\') after +1');

        m = moment('2014-03-09T01:35:00-08:00').parseZone();
        m.startOf('h');
        assert.equal(m.format(), '2014-03-09T01:00:00-08:00', 'startOf(\'hour\') before +1');

        // There is no such time as 2:30-7 to try startOf('hour') across that

        moment.updateOffset = oldUpdateOffset;
    });

    test('startOf across DST -1', function (assert) {
        var oldUpdateOffset = moment.updateOffset,
            // Based on a real story somewhere in America/Los_Angeles
            dstAt = moment('2014-11-02T02:00:00-07:00').parseZone(),
            m;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.isBefore(dstAt)) {
                mom.utcOffset(-7, keepTime);
            } else {
                mom.utcOffset(-8, keepTime);
            }
        };

        m = moment('2014-11-15T00:00:00-08:00').parseZone();
        m.startOf('M');
        assert.equal(m.format(), '2014-11-01T00:00:00-07:00', 'startOf(\'month\') across -1');

        m = moment('2014-11-02T09:00:00-08:00').parseZone();
        m.startOf('d');
        assert.equal(m.format(), '2014-11-02T00:00:00-07:00', 'startOf(\'day\') across -1');

        // note that utc offset is -8
        m = moment('2014-11-02T01:30:00-08:00').parseZone();
        m.startOf('h');
        assert.equal(m.format(), '2014-11-02T01:00:00-08:00', 'startOf(\'hour\') after +1');

        // note that utc offset is -7
        m = moment('2014-11-02T01:30:00-07:00').parseZone();
        m.startOf('h');
        assert.equal(m.format(), '2014-11-02T01:00:00-07:00', 'startOf(\'hour\') before +1');

        moment.updateOffset = oldUpdateOffset;
    });

    test('endOf millisecond and no-arg', function (assert) {
        var m = moment();
        assert.equal(+m, +m.clone().endOf(), 'endOf without argument should change time');
        assert.equal(+m, +m.clone().endOf('ms'), 'endOf with ms argument should change time');
        assert.equal(+m, +m.clone().endOf('millisecond'), 'endOf with millisecond argument should change time');
        assert.equal(+m, +m.clone().endOf('milliseconds'), 'endOf with milliseconds argument should change time');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('string prototype');

    test('string prototype overrides call', function (assert) {
        var prior = String.prototype.call, b;
        String.prototype.call = function () {
            return null;
        };

        b = moment(new Date(2011, 7, 28, 15, 25, 50, 125));
        assert.equal(b.format('MMMM Do YYYY, h:mm a'), 'August 28th 2011, 3:25 pm');

        String.prototype.call = prior;
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('to type');

    test('toObject', function (assert) {
        var expected = {
            years:2010,
            months:3,
            date:5,
            hours:15,
            minutes:10,
            seconds:3,
            milliseconds:123
        };
        assert.deepEqual(moment(expected).toObject(), expected, 'toObject invalid');
    });

    test('toArray', function (assert) {
        var expected = [2014, 11, 26, 11, 46, 58, 17];
        assert.deepEqual(moment(expected).toArray(), expected, 'toArray invalid');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('utc');

    test('utc and local', function (assert) {
        var m = moment(Date.UTC(2011, 1, 2, 3, 4, 5, 6)), offset, expected;
        m.utc();
        // utc
        assert.equal(m.date(), 2, 'the day should be correct for utc');
        assert.equal(m.day(), 3, 'the date should be correct for utc');
        assert.equal(m.hours(), 3, 'the hours should be correct for utc');

        // local
        m.local();
        if (m.zone() > 180) {
            assert.equal(m.date(), 1, 'the date should be correct for local');
            assert.equal(m.day(), 2, 'the day should be correct for local');
        } else {
            assert.equal(m.date(), 2, 'the date should be correct for local');
            assert.equal(m.day(), 3, 'the day should be correct for local');
        }
        offset = Math.floor(m.utcOffset() / 60);
        expected = (24 + 3 + offset) % 24;
        assert.equal(m.hours(), expected, 'the hours (' + m.hours() + ') should be correct for local');
        assert.equal(moment().utc().utcOffset(), 0, 'timezone in utc should always be zero');
    });

    test('creating with utc and no arguments', function (assert) {
        var startOfTest = new Date().valueOf(),
            momentDefaultUtcTime = moment.utc().valueOf(),
            afterMomentCreationTime = new Date().valueOf();

        assert.ok(startOfTest <= momentDefaultUtcTime, 'moment UTC default time should be now, not in the past');
        assert.ok(momentDefaultUtcTime <= afterMomentCreationTime, 'moment UTC default time should be now, not in the future');
    });

    test('creating with utc and a date parameter array', function (assert) {
        var m = moment.utc([2011, 1, 2, 3, 4, 5, 6]);
        assert.equal(m.date(), 2, 'the day should be correct for utc array');
        assert.equal(m.hours(), 3, 'the hours should be correct for utc array');

        m = moment.utc('2011-02-02 3:04:05', 'YYYY-MM-DD HH:mm:ss');
        assert.equal(m.date(), 2, 'the day should be correct for utc parsing format');
        assert.equal(m.hours(), 3, 'the hours should be correct for utc parsing format');

        m = moment.utc('2011-02-02T03:04:05+00:00');
        assert.equal(m.date(), 2, 'the day should be correct for utc parsing iso');
        assert.equal(m.hours(), 3, 'the hours should be correct for utc parsing iso');
    });

    test('creating with utc without timezone', function (assert) {
        var m = moment.utc('2012-01-02T08:20:00');
        assert.equal(m.date(), 2, 'the day should be correct for utc parse without timezone');
        assert.equal(m.hours(), 8, 'the hours should be correct for utc parse without timezone');

        m = moment.utc('2012-01-02T08:20:00+09:00');
        assert.equal(m.date(), 1, 'the day should be correct for utc parse with timezone');
        assert.equal(m.hours(), 23, 'the hours should be correct for utc parse with timezone');
    });

    test('cloning with utc offset', function (assert) {
        var m = moment.utc('2012-01-02T08:20:00');
        assert.equal(moment.utc(m)._isUTC, true, 'the local offset should be converted to UTC');
        assert.equal(moment.utc(m.clone().utc())._isUTC, true, 'the local offset should stay in UTC');

        m.utcOffset(120);
        assert.equal(moment.utc(m)._isUTC, true, 'the explicit utc offset should stay in UTC');
        assert.equal(moment.utc(m).utcOffset(), 0, 'the explicit utc offset should have an offset of 0');
    });

    test('weekday with utc', function (assert) {
        assert.equal(
            moment('2013-09-15T00:00:00Z').utc().weekday(), // first minute of the day
            moment('2013-09-15T23:59:00Z').utc().weekday(), // last minute of the day
            'a UTC-moment\'s .weekday() should not be affected by the local timezone'
        );
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('utc offset');

    test('setter / getter blackbox', function (assert) {
        var m = moment([2010]);

        assert.equal(m.clone().utcOffset(0).utcOffset(), 0, 'utcOffset 0');

        assert.equal(m.clone().utcOffset(1).utcOffset(), 60, 'utcOffset 1 is 60');
        assert.equal(m.clone().utcOffset(60).utcOffset(), 60, 'utcOffset 60');
        assert.equal(m.clone().utcOffset('+01:00').utcOffset(), 60, 'utcOffset +01:00 is 60');
        assert.equal(m.clone().utcOffset('+0100').utcOffset(), 60, 'utcOffset +0100 is 60');

        assert.equal(m.clone().utcOffset(-1).utcOffset(), -60, 'utcOffset -1 is -60');
        assert.equal(m.clone().utcOffset(-60).utcOffset(), -60, 'utcOffset -60');
        assert.equal(m.clone().utcOffset('-01:00').utcOffset(), -60, 'utcOffset -01:00 is -60');
        assert.equal(m.clone().utcOffset('-0100').utcOffset(), -60, 'utcOffset -0100 is -60');

        assert.equal(m.clone().utcOffset(1.5).utcOffset(), 90, 'utcOffset 1.5 is 90');
        assert.equal(m.clone().utcOffset(90).utcOffset(), 90, 'utcOffset 1.5 is 90');
        assert.equal(m.clone().utcOffset('+01:30').utcOffset(), 90, 'utcOffset +01:30 is 90');
        assert.equal(m.clone().utcOffset('+0130').utcOffset(), 90, 'utcOffset +0130 is 90');

        assert.equal(m.clone().utcOffset(-1.5).utcOffset(), -90, 'utcOffset -1.5');
        assert.equal(m.clone().utcOffset(-90).utcOffset(), -90, 'utcOffset -90');
        assert.equal(m.clone().utcOffset('-01:30').utcOffset(), -90, 'utcOffset +01:30 is 90');
        assert.equal(m.clone().utcOffset('-0130').utcOffset(), -90, 'utcOffset +0130 is 90');
    });

    test('utcOffset shorthand hours -> minutes', function (assert) {
        var i;
        for (i = -15; i <= 15; ++i) {
            assert.equal(moment().utcOffset(i).utcOffset(), i * 60,
                    '' + i + ' -> ' + i * 60);
        }
        assert.equal(moment().utcOffset(-16).utcOffset(), -16, '-16 -> -16');
        assert.equal(moment().utcOffset(16).utcOffset(), 16, '16 -> 16');
    });

    test('isLocal, isUtc, isUtcOffset', function (assert) {
        assert.ok(moment().isLocal(), 'moment() creates objects in local time');
        assert.ok(!moment.utc().isLocal(), 'moment.utc creates objects NOT in local time');
        assert.ok(moment.utc().local().isLocal(), 'moment.fn.local() converts to local time');
        assert.ok(!moment().utcOffset(5).isLocal(), 'moment.fn.utcOffset(N) puts objects NOT in local time');
        assert.ok(moment().utcOffset(5).local().isLocal(), 'moment.fn.local() converts to local time');

        assert.ok(moment.utc().isUtc(), 'moment.utc() creates objects in utc time');
        assert.ok(moment().utcOffset(0).isUtc(), 'utcOffset(0) is equivalent to utc mode');
        assert.ok(!moment().utcOffset(1).isUtc(), 'utcOffset(1) is NOT equivalent to utc mode');

        assert.ok(!moment().isUtcOffset(), 'moment() creates objects NOT in utc-offset mode');
        assert.ok(moment.utc().isUtcOffset(), 'moment.utc() creates objects in utc-offset mode');
        assert.ok(moment().utcOffset(3).isUtcOffset(), 'utcOffset(N != 0) creates objects in utc-offset mode');
        assert.ok(moment().utcOffset(0).isUtcOffset(), 'utcOffset(0) creates objects in utc-offset mode');
    });

    test('isUTC', function (assert) {
        assert.ok(moment.utc().isUTC(), 'moment.utc() creates objects in utc time');
        assert.ok(moment().utcOffset(0).isUTC(), 'utcOffset(0) is equivalent to utc mode');
        assert.ok(!moment().utcOffset(1).isUTC(), 'utcOffset(1) is NOT equivalent to utc mode');
    });

    test('change hours when changing the utc offset', function (assert) {
        var m = moment.utc([2000, 0, 1, 6]);
        assert.equal(m.hour(), 6, 'UTC 6AM should be 6AM at +0000');

        // sanity check
        m.utcOffset(0);
        assert.equal(m.hour(), 6, 'UTC 6AM should be 6AM at +0000');

        m.utcOffset(-60);
        assert.equal(m.hour(), 5, 'UTC 6AM should be 5AM at -0100');

        m.utcOffset(60);
        assert.equal(m.hour(), 7, 'UTC 6AM should be 7AM at +0100');
    });

    test('change minutes when changing the utc offset', function (assert) {
        var m = moment.utc([2000, 0, 1, 6, 31]);

        m.utcOffset(0);
        assert.equal(m.format('HH:mm'), '06:31', 'UTC 6:31AM should be 6:31AM at +0000');

        m.utcOffset(-30);
        assert.equal(m.format('HH:mm'), '06:01', 'UTC 6:31AM should be 6:01AM at -0030');

        m.utcOffset(30);
        assert.equal(m.format('HH:mm'), '07:01', 'UTC 6:31AM should be 7:01AM at +0030');

        m.utcOffset(-1380);
        assert.equal(m.format('HH:mm'), '07:31', 'UTC 6:31AM should be 7:31AM at +1380');
    });

    test('distance from the unix epoch', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA),
            zoneC = moment(zoneA),
            zoneD = moment(zoneA),
            zoneE = moment(zoneA);

        zoneB.utc();
        assert.equal(+zoneA, +zoneB, 'moment should equal moment.utc');

        zoneC.utcOffset(60);
        assert.equal(+zoneA, +zoneC, 'moment should equal moment.utcOffset(60)');

        zoneD.utcOffset(-480);
        assert.equal(+zoneA, +zoneD,
                'moment should equal moment.utcOffset(-480)');

        zoneE.utcOffset(-1000);
        assert.equal(+zoneA, +zoneE,
                'moment should equal moment.utcOffset(-1000)');
    });

    test('update offset after changing any values', function (assert) {
        var oldOffset = moment.updateOffset,
            m = moment.utc([2000, 6, 1]);

        moment.updateOffset = function (mom, keepTime) {
            if (mom.__doChange) {
                if (+mom > 962409600000) {
                    mom.utcOffset(-120, keepTime);
                } else {
                    mom.utcOffset(-60, keepTime);
                }
            }
        };

        assert.equal(m.format('ZZ'), '+0000', 'should be at +0000');
        assert.equal(m.format('HH:mm'), '00:00', 'should start 12AM at +0000 timezone');

        m.__doChange = true;
        m.add(1, 'h');

        assert.equal(m.format('ZZ'), '-0200', 'should be at -0200');
        assert.equal(m.format('HH:mm'), '23:00', '1AM at +0000 should be 11PM at -0200 timezone');

        m.subtract(1, 'h');

        assert.equal(m.format('ZZ'), '-0100', 'should be at -0100');
        assert.equal(m.format('HH:mm'), '23:00', '12AM at +0000 should be 11PM at -0100 timezone');

        moment.updateOffset = oldOffset;
    });

    //////////////////
    test('getters and setters', function (assert) {
        var a = moment([2011, 5, 20]);

        assert.equal(a.clone().utcOffset(-120).year(2012).year(), 2012, 'should get and set year correctly');
        assert.equal(a.clone().utcOffset(-120).month(1).month(), 1, 'should get and set month correctly');
        assert.equal(a.clone().utcOffset(-120).date(2).date(), 2, 'should get and set date correctly');
        assert.equal(a.clone().utcOffset(-120).day(1).day(), 1, 'should get and set day correctly');
        assert.equal(a.clone().utcOffset(-120).hour(1).hour(), 1, 'should get and set hour correctly');
        assert.equal(a.clone().utcOffset(-120).minute(1).minute(), 1, 'should get and set minute correctly');
    });

    test('getters', function (assert) {
        var a = moment.utc([2012, 0, 1, 0, 0, 0]);

        assert.equal(a.clone().utcOffset(-120).year(),  2011, 'should get year correctly');
        assert.equal(a.clone().utcOffset(-120).month(),   11, 'should get month correctly');
        assert.equal(a.clone().utcOffset(-120).date(),    31, 'should get date correctly');
        assert.equal(a.clone().utcOffset(-120).hour(),    22, 'should get hour correctly');
        assert.equal(a.clone().utcOffset(-120).minute(),   0, 'should get minute correctly');

        assert.equal(a.clone().utcOffset(120).year(),  2012, 'should get year correctly');
        assert.equal(a.clone().utcOffset(120).month(),    0, 'should get month correctly');
        assert.equal(a.clone().utcOffset(120).date(),     1, 'should get date correctly');
        assert.equal(a.clone().utcOffset(120).hour(),     2, 'should get hour correctly');
        assert.equal(a.clone().utcOffset(120).minute(),   0, 'should get minute correctly');

        assert.equal(a.clone().utcOffset(90).year(),  2012, 'should get year correctly');
        assert.equal(a.clone().utcOffset(90).month(),    0, 'should get month correctly');
        assert.equal(a.clone().utcOffset(90).date(),     1, 'should get date correctly');
        assert.equal(a.clone().utcOffset(90).hour(),     1, 'should get hour correctly');
        assert.equal(a.clone().utcOffset(90).minute(),  30, 'should get minute correctly');
    });

    test('from', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).utcOffset(-720),
            zoneC = moment(zoneA).utcOffset(-360),
            zoneD = moment(zoneA).utcOffset(690),
            other = moment(zoneA).add(35, 'm');

        assert.equal(zoneA.from(other), zoneB.from(other), 'moment#from should be the same in all zones');
        assert.equal(zoneA.from(other), zoneC.from(other), 'moment#from should be the same in all zones');
        assert.equal(zoneA.from(other), zoneD.from(other), 'moment#from should be the same in all zones');
    });

    test('diff', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).utcOffset(-720),
            zoneC = moment(zoneA).utcOffset(-360),
            zoneD = moment(zoneA).utcOffset(690),
            other = moment(zoneA).add(35, 'm');

        assert.equal(zoneA.diff(other), zoneB.diff(other), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other), zoneC.diff(other), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other), zoneD.diff(other), 'moment#diff should be the same in all zones');

        assert.equal(zoneA.diff(other, 'minute', true), zoneB.diff(other, 'minute', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'minute', true), zoneC.diff(other, 'minute', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'minute', true), zoneD.diff(other, 'minute', true), 'moment#diff should be the same in all zones');

        assert.equal(zoneA.diff(other, 'hour', true), zoneB.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'hour', true), zoneC.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'hour', true), zoneD.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
    });

    test('unix offset and timestamp', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).utcOffset(-720),
            zoneC = moment(zoneA).utcOffset(-360),
            zoneD = moment(zoneA).utcOffset(690);

        assert.equal(zoneA.unix(), zoneB.unix(), 'moment#unix should be the same in all zones');
        assert.equal(zoneA.unix(), zoneC.unix(), 'moment#unix should be the same in all zones');
        assert.equal(zoneA.unix(), zoneD.unix(), 'moment#unix should be the same in all zones');

        assert.equal(+zoneA, +zoneB, 'moment#valueOf should be the same in all zones');
        assert.equal(+zoneA, +zoneC, 'moment#valueOf should be the same in all zones');
        assert.equal(+zoneA, +zoneD, 'moment#valueOf should be the same in all zones');
    });

    test('cloning', function (assert) {
        assert.equal(moment().utcOffset(-120).clone().utcOffset(), -120,
                'explicit cloning should retain the offset');
        assert.equal(moment().utcOffset(120).clone().utcOffset(), 120,
                'explicit cloning should retain the offset');
        assert.equal(moment(moment().utcOffset(-120)).utcOffset(), -120,
                'implicit cloning should retain the offset');
        assert.equal(moment(moment().utcOffset(120)).utcOffset(), 120,
                'implicit cloning should retain the offset');
    });

    test('start of / end of', function (assert) {
        var a = moment.utc([2010, 1, 2, 0, 0, 0]).utcOffset(-450);

        assert.equal(a.clone().startOf('day').hour(), 0,
                'start of day should work on moments with utc offset');
        assert.equal(a.clone().startOf('day').minute(), 0,
                'start of day should work on moments with utc offset');
        assert.equal(a.clone().startOf('hour').minute(), 0,
                'start of hour should work on moments with utc offset');

        assert.equal(a.clone().endOf('day').hour(), 23,
                'end of day should work on moments with utc offset');
        assert.equal(a.clone().endOf('day').minute(), 59,
                'end of day should work on moments with utc offset');
        assert.equal(a.clone().endOf('hour').minute(), 59,
                'end of hour should work on moments with utc offset');
    });

    test('reset offset with moment#utc', function (assert) {
        var a = moment.utc([2012]).utcOffset(-480);

        assert.equal(a.clone().hour(),      16, 'different utc offset should have different hour');
        assert.equal(a.clone().utc().hour(), 0, 'calling moment#utc should reset the offset');
    });

    test('reset offset with moment#local', function (assert) {
        var a = moment([2012]).utcOffset(-480);

        assert.equal(a.clone().local().hour(), 0, 'calling moment#local should reset the offset');
    });

    test('toDate', function (assert) {
        var zoneA = new Date(),
            zoneB = moment(zoneA).utcOffset(-720).toDate(),
            zoneC = moment(zoneA).utcOffset(-360).toDate(),
            zoneD = moment(zoneA).utcOffset(690).toDate();

        assert.equal(+zoneA, +zoneB, 'moment#toDate should output a date with the right unix timestamp');
        assert.equal(+zoneA, +zoneC, 'moment#toDate should output a date with the right unix timestamp');
        assert.equal(+zoneA, +zoneD, 'moment#toDate should output a date with the right unix timestamp');
    });

    test('same / before / after', function (assert) {
        var zoneA = moment().utc(),
            zoneB = moment(zoneA).utcOffset(-120),
            zoneC = moment(zoneA).utcOffset(120);

        assert.ok(zoneA.isSame(zoneB), 'two moments with different offsets should be the same');
        assert.ok(zoneA.isSame(zoneC), 'two moments with different offsets should be the same');

        assert.ok(zoneA.isSame(zoneB, 'hour'), 'two moments with different offsets should be the same hour');
        assert.ok(zoneA.isSame(zoneC, 'hour'), 'two moments with different offsets should be the same hour');

        zoneA.add(1, 'hour');

        assert.ok(zoneA.isAfter(zoneB), 'isAfter should work with two moments with different offsets');
        assert.ok(zoneA.isAfter(zoneC), 'isAfter should work with two moments with different offsets');

        assert.ok(zoneA.isAfter(zoneB, 'hour'), 'isAfter:hour should work with two moments with different offsets');
        assert.ok(zoneA.isAfter(zoneC, 'hour'), 'isAfter:hour should work with two moments with different offsets');

        zoneA.subtract(2, 'hour');

        assert.ok(zoneA.isBefore(zoneB), 'isBefore should work with two moments with different offsets');
        assert.ok(zoneA.isBefore(zoneC), 'isBefore should work with two moments with different offsets');

        assert.ok(zoneA.isBefore(zoneB, 'hour'), 'isBefore:hour should work with two moments with different offsets');
        assert.ok(zoneA.isBefore(zoneC, 'hour'), 'isBefore:hour should work with two moments with different offsets');
    });

    test('add / subtract over dst', function (assert) {
        var oldOffset = moment.updateOffset,
            m = moment.utc([2000, 2, 31, 3]);

        moment.updateOffset = function (mom, keepTime) {
            if (mom.clone().utc().month() > 2) {
                mom.utcOffset(60, keepTime);
            } else {
                mom.utcOffset(0, keepTime);
            }
        };

        assert.equal(m.hour(), 3, 'should start at 00:00');

        m.add(24, 'hour');

        assert.equal(m.hour(), 4, 'adding 24 hours should disregard dst');

        m.subtract(24, 'hour');

        assert.equal(m.hour(), 3, 'subtracting 24 hours should disregard dst');

        m.add(1, 'day');

        assert.equal(m.hour(), 3, 'adding 1 day should have the same hour');

        m.subtract(1, 'day');

        assert.equal(m.hour(), 3, 'subtracting 1 day should have the same hour');

        m.add(1, 'month');

        assert.equal(m.hour(), 3, 'adding 1 month should have the same hour');

        m.subtract(1, 'month');

        assert.equal(m.hour(), 3, 'subtracting 1 month should have the same hour');

        moment.updateOffset = oldOffset;
    });

    test('isDST', function (assert) {
        var oldOffset = moment.updateOffset;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.month() > 2 && mom.month() < 9) {
                mom.utcOffset(60, keepTime);
            } else {
                mom.utcOffset(0, keepTime);
            }
        };

        assert.ok(!moment().month(0).isDST(),  'Jan should not be summer dst');
        assert.ok(moment().month(6).isDST(),   'Jul should be summer dst');
        assert.ok(!moment().month(11).isDST(), 'Dec should not be summer dst');

        moment.updateOffset = function (mom) {
            if (mom.month() > 2 && mom.month() < 9) {
                mom.utcOffset(0);
            } else {
                mom.utcOffset(60);
            }
        };

        assert.ok(moment().month(0).isDST(),  'Jan should be winter dst');
        assert.ok(!moment().month(6).isDST(), 'Jul should not be winter dst');
        assert.ok(moment().month(11).isDST(), 'Dec should be winter dst');

        moment.updateOffset = oldOffset;
    });

    test('zone names', function (assert) {
        assert.equal(moment().zoneAbbr(),   '', 'Local zone abbr should be empty');
        assert.equal(moment().format('z'),  '', 'Local zone formatted abbr should be empty');
        assert.equal(moment().zoneName(),   '', 'Local zone name should be empty');
        assert.equal(moment().format('zz'), '', 'Local zone formatted name should be empty');

        assert.equal(moment.utc().zoneAbbr(),   'UTC', 'UTC zone abbr should be UTC');
        assert.equal(moment.utc().format('z'),  'UTC', 'UTC zone formatted abbr should be UTC');
        assert.equal(moment.utc().zoneName(),   'Coordinated Universal Time', 'UTC zone abbr should be Coordinated Universal Time');
        assert.equal(moment.utc().format('zz'), 'Coordinated Universal Time', 'UTC zone formatted abbr should be Coordinated Universal Time');
    });

    test('hours alignment with UTC', function (assert) {
        assert.equal(moment().utcOffset(-120).hasAlignedHourOffset(), true);
        assert.equal(moment().utcOffset(180).hasAlignedHourOffset(), true);
        assert.equal(moment().utcOffset(-90).hasAlignedHourOffset(), false);
        assert.equal(moment().utcOffset(90).hasAlignedHourOffset(), false);
    });

    test('hours alignment with other zone', function (assert) {
        var m = moment().utcOffset(-120);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-90)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(90)), false);

        m = moment().utcOffset(-90);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-180)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(180)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-30)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(30)), true);

        m = moment().utcOffset(60);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-90)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(90)), false);

        m = moment().utcOffset(-25);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(35)), true);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-85)), true);

        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(-35)), false);
        assert.equal(m.hasAlignedHourOffset(moment().utcOffset(85)), false);
    });

    test('parse zone', function (assert) {
        var m = moment('2013-01-01T00:00:00-13:00').parseZone();
        assert.equal(m.utcOffset(), -13 * 60);
        assert.equal(m.hours(), 0);
    });

    test('parse zone static', function (assert) {
        var m = moment.parseZone('2013-01-01T00:00:00-13:00');
        assert.equal(m.utcOffset(), -13 * 60);
        assert.equal(m.hours(), 0);
    });

    test('parse zone with more arguments', function (assert) {
        var m;
        m = moment.parseZone('2013 01 01 05 -13:00', 'YYYY MM DD HH ZZ');
        assert.equal(m.format(), '2013-01-01T05:00:00-13:00', 'accept input and format');
        m = moment.parseZone('2013-01-01-13:00', 'YYYY MM DD ZZ', true);
        assert.equal(m.isValid(), false, 'accept input, format and strict flag');
        m = moment.parseZone('2013-01-01-13:00', ['DD MM YYYY ZZ', 'YYYY MM DD ZZ']);
        assert.equal(m.format(), '2013-01-01T00:00:00-13:00', 'accept input and array of formats');
    });

    test('parse zone with a timezone from the format string', function (assert) {
        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY ZZ #####').parseZone();

        assert.equal(m.utcOffset(), -4 * 60);
    });

    test('parse zone without a timezone included in the format string', function (assert) {
        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY').parseZone();

        assert.equal(m.utcOffset(), 11 * 60);
    });

    test('timezone format', function (assert) {
        assert.equal(moment().utcOffset(60).format('ZZ'), '+0100', '-60 -> +0100');
        assert.equal(moment().utcOffset(90).format('ZZ'), '+0130', '-90 -> +0130');
        assert.equal(moment().utcOffset(120).format('ZZ'), '+0200', '-120 -> +0200');

        assert.equal(moment().utcOffset(-60).format('ZZ'), '-0100', '+60 -> -0100');
        assert.equal(moment().utcOffset(-90).format('ZZ'), '-0130', '+90 -> -0130');
        assert.equal(moment().utcOffset(-120).format('ZZ'), '-0200', '+120 -> -0200');
    });

    test('local to utc, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss';
        assert.equal(m.clone().utc(true).format(fmt), m.format(fmt), 'local to utc failed to keep local time');
    });

    test('local to utc, keepLocalTime = false', function (assert) {
        var m = moment();
        assert.equal(m.clone().utc().valueOf(), m.valueOf(), 'local to utc failed to keep utc time (implicit)');
        assert.equal(m.clone().utc(false).valueOf(), m.valueOf(), 'local to utc failed to keep utc time (explicit)');
    });

    test('local to zone, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss',
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            assert.equal(m.clone().utcOffset(z * 60, true).format(fmt),
                    m.format(fmt),
                    'local to utcOffset(' + z + ':00) failed to keep local time');
        }
    });

    test('local to zone, keepLocalTime = false', function (assert) {
        var m = moment(),
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            assert.equal(m.clone().utcOffset(z * 60).valueOf(),
                    m.valueOf(),
                    'local to utcOffset(' + z + ':00) failed to keep utc time (implicit)');
            assert.equal(m.clone().utcOffset(z * 60, false).valueOf(),
                    m.valueOf(),
                    'local to utcOffset(' + z + ':00) failed to keep utc time (explicit)');
        }
    });

    test('utc to local, keepLocalTime = true', function (assert) {
        var um = moment.utc(),
            fmt = 'YYYY-DD-MM HH:mm:ss';

        assert.equal(um.clone().local(true).format(fmt), um.format(fmt), 'utc to local failed to keep local time');
    });

    test('utc to local, keepLocalTime = false', function (assert) {
        var um = moment.utc();
        assert.equal(um.clone().local().valueOf(), um.valueOf(), 'utc to local failed to keep utc time (implicit)');
        assert.equal(um.clone().local(false).valueOf(), um.valueOf(), 'utc to local failed to keep utc time (explicit)');
    });

    test('zone to local, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss',
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            m.utcOffset(z * 60);

            assert.equal(m.clone().local(true).format(fmt),
                    m.format(fmt),
                    'utcOffset(' + z + ':00) to local failed to keep local time');
        }
    });

    test('zone to local, keepLocalTime = false', function (assert) {
        var m = moment(),
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            m.utcOffset(z * 60);

            assert.equal(m.clone().local(false).valueOf(), m.valueOf(),
                    'utcOffset(' + z + ':00) to local failed to keep utc time (explicit)');
            assert.equal(m.clone().local().valueOf(), m.valueOf(),
                    'utcOffset(' + z + ':00) to local failed to keep utc time (implicit)');
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('week year');

    test('iso week year', function (assert) {
        // Some examples taken from http://en.wikipedia.org/wiki/ISO_week
        assert.equal(moment([2005, 0, 1]).isoWeekYear(), 2004);
        assert.equal(moment([2005, 0, 2]).isoWeekYear(), 2004);
        assert.equal(moment([2005, 0, 3]).isoWeekYear(), 2005);
        assert.equal(moment([2005, 11, 31]).isoWeekYear(), 2005);
        assert.equal(moment([2006, 0, 1]).isoWeekYear(), 2005);
        assert.equal(moment([2006, 0, 2]).isoWeekYear(), 2006);
        assert.equal(moment([2007, 0, 1]).isoWeekYear(), 2007);
        assert.equal(moment([2007, 11, 30]).isoWeekYear(), 2007);
        assert.equal(moment([2007, 11, 31]).isoWeekYear(), 2008);
        assert.equal(moment([2008, 0, 1]).isoWeekYear(), 2008);
        assert.equal(moment([2008, 11, 28]).isoWeekYear(), 2008);
        assert.equal(moment([2008, 11, 29]).isoWeekYear(), 2009);
        assert.equal(moment([2008, 11, 30]).isoWeekYear(), 2009);
        assert.equal(moment([2008, 11, 31]).isoWeekYear(), 2009);
        assert.equal(moment([2009, 0, 1]).isoWeekYear(), 2009);
        assert.equal(moment([2010, 0, 1]).isoWeekYear(), 2009);
        assert.equal(moment([2010, 0, 2]).isoWeekYear(), 2009);
        assert.equal(moment([2010, 0, 3]).isoWeekYear(), 2009);
        assert.equal(moment([2010, 0, 4]).isoWeekYear(), 2010);
    });

    test('week year', function (assert) {
        // Some examples taken from http://en.wikipedia.org/wiki/ISO_week
        moment.locale('dow: 1,doy: 4', {week: {dow: 1, doy: 4}}); // like iso
        assert.equal(moment([2005, 0, 1]).weekYear(), 2004);
        assert.equal(moment([2005, 0, 2]).weekYear(), 2004);
        assert.equal(moment([2005, 0, 3]).weekYear(), 2005);
        assert.equal(moment([2005, 11, 31]).weekYear(), 2005);
        assert.equal(moment([2006, 0, 1]).weekYear(), 2005);
        assert.equal(moment([2006, 0, 2]).weekYear(), 2006);
        assert.equal(moment([2007, 0, 1]).weekYear(), 2007);
        assert.equal(moment([2007, 11, 30]).weekYear(), 2007);
        assert.equal(moment([2007, 11, 31]).weekYear(), 2008);
        assert.equal(moment([2008, 0, 1]).weekYear(), 2008);
        assert.equal(moment([2008, 11, 28]).weekYear(), 2008);
        assert.equal(moment([2008, 11, 29]).weekYear(), 2009);
        assert.equal(moment([2008, 11, 30]).weekYear(), 2009);
        assert.equal(moment([2008, 11, 31]).weekYear(), 2009);
        assert.equal(moment([2009, 0, 1]).weekYear(), 2009);
        assert.equal(moment([2010, 0, 1]).weekYear(), 2009);
        assert.equal(moment([2010, 0, 2]).weekYear(), 2009);
        assert.equal(moment([2010, 0, 3]).weekYear(), 2009);
        assert.equal(moment([2010, 0, 4]).weekYear(), 2010);

        moment.locale('dow: 1,doy: 7', {week: {dow: 1, doy: 7}});
        assert.equal(moment([2004, 11, 26]).weekYear(), 2004);
        assert.equal(moment([2004, 11, 27]).weekYear(), 2005);
        assert.equal(moment([2005, 11, 25]).weekYear(), 2005);
        assert.equal(moment([2005, 11, 26]).weekYear(), 2006);
        assert.equal(moment([2006, 11, 31]).weekYear(), 2006);
        assert.equal(moment([2007,  0,  1]).weekYear(), 2007);
        assert.equal(moment([2007, 11, 30]).weekYear(), 2007);
        assert.equal(moment([2007, 11, 31]).weekYear(), 2008);
        assert.equal(moment([2008, 11, 28]).weekYear(), 2008);
        assert.equal(moment([2008, 11, 29]).weekYear(), 2009);
        assert.equal(moment([2009, 11, 27]).weekYear(), 2009);
        assert.equal(moment([2009, 11, 28]).weekYear(), 2010);
    });

    // Verifies that the week number, week day computation is correct for all dow, doy combinations
    test('week year roundtrip', function (assert) {
        var dow, doy, wd, m;
        for (dow = 0; dow < 7; ++dow) {
            for (doy = dow; doy < dow + 7; ++doy) {
                for (wd = 0; wd < 7; ++wd) {
                    moment.locale('dow: ' + dow + ', doy: ' + doy, {week: {dow: dow, doy: doy}});
                    // We use the 10th week as the 1st one can spill to the previous year
                    m = moment('2015 10 ' + wd, 'gggg w d', true);
                    assert.equal(m.format('gggg w d'), '2015 10 ' + wd, 'dow: ' + dow + ' doy: ' + doy + ' wd: ' + wd);
                    m = moment('2015 10 ' + wd, 'gggg w e', true);
                    assert.equal(m.format('gggg w e'), '2015 10 ' + wd, 'dow: ' + dow + ' doy: ' + doy + ' wd: ' + wd);
                }
            }
        }
    });

    test('week numbers 2012/2013', function (assert) {
        moment.locale('dow: 6, doy: 12', {week: {dow: 6, doy: 12}});
        assert.equal(52, moment('2012-12-28', 'YYYY-MM-DD').week()); // 51 -- should be 52?
        assert.equal(1, moment('2012-12-29', 'YYYY-MM-DD').week()); // 52 -- should be 1
        assert.equal(1, moment('2013-01-01', 'YYYY-MM-DD').week()); // 52 -- should be 1
        assert.equal(2, moment('2013-01-08', 'YYYY-MM-DD').week()); // 53 -- should be 2
        assert.equal(2, moment('2013-01-11', 'YYYY-MM-DD').week()); // 53 -- should be 2
        assert.equal(3, moment('2013-01-12', 'YYYY-MM-DD').week()); // 1 -- should be 3
        assert.equal(52, moment().weeksInYear(2012)); // 52
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('week day');

    test('iso weekday', function (assert) {
        var i;

        for (i = 0; i < 7; ++i) {
            moment.locale('dow:' + i + ',doy: 6', {week: {dow: i, doy: 6}});
            assert.equal(moment([1985, 1,  4]).isoWeekday(), 1, 'Feb  4 1985 is Monday    -- 1st day');
            assert.equal(moment([2029, 8, 18]).isoWeekday(), 2, 'Sep 18 2029 is Tuesday   -- 2nd day');
            assert.equal(moment([2013, 3, 24]).isoWeekday(), 3, 'Apr 24 2013 is Wednesday -- 3rd day');
            assert.equal(moment([2015, 2,  5]).isoWeekday(), 4, 'Mar  5 2015 is Thursday  -- 4th day');
            assert.equal(moment([1970, 0,  2]).isoWeekday(), 5, 'Jan  2 1970 is Friday    -- 5th day');
            assert.equal(moment([2001, 4, 12]).isoWeekday(), 6, 'May 12 2001 is Saturday  -- 6th day');
            assert.equal(moment([2000, 0,  2]).isoWeekday(), 7, 'Jan  2 2000 is Sunday    -- 7th day');
        }
    });

    test('iso weekday setter', function (assert) {
        var a = moment([2011, 0, 10]);
        assert.equal(moment(a).isoWeekday(1).date(),  10, 'set from mon to mon');
        assert.equal(moment(a).isoWeekday(4).date(),  13, 'set from mon to thu');
        assert.equal(moment(a).isoWeekday(7).date(),  16, 'set from mon to sun');
        assert.equal(moment(a).isoWeekday(-6).date(),  3, 'set from mon to last mon');
        assert.equal(moment(a).isoWeekday(-3).date(),  6, 'set from mon to last thu');
        assert.equal(moment(a).isoWeekday(0).date(),   9, 'set from mon to last sun');
        assert.equal(moment(a).isoWeekday(8).date(),  17, 'set from mon to next mon');
        assert.equal(moment(a).isoWeekday(11).date(), 20, 'set from mon to next thu');
        assert.equal(moment(a).isoWeekday(14).date(), 23, 'set from mon to next sun');

        a = moment([2011, 0, 13]);
        assert.equal(moment(a).isoWeekday(1).date(), 10, 'set from thu to mon');
        assert.equal(moment(a).isoWeekday(4).date(), 13, 'set from thu to thu');
        assert.equal(moment(a).isoWeekday(7).date(), 16, 'set from thu to sun');
        assert.equal(moment(a).isoWeekday(-6).date(),  3, 'set from thu to last mon');
        assert.equal(moment(a).isoWeekday(-3).date(),  6, 'set from thu to last thu');
        assert.equal(moment(a).isoWeekday(0).date(),   9, 'set from thu to last sun');
        assert.equal(moment(a).isoWeekday(8).date(),  17, 'set from thu to next mon');
        assert.equal(moment(a).isoWeekday(11).date(), 20, 'set from thu to next thu');
        assert.equal(moment(a).isoWeekday(14).date(), 23, 'set from thu to next sun');

        a = moment([2011, 0, 16]);
        assert.equal(moment(a).isoWeekday(1).date(), 10, 'set from sun to mon');
        assert.equal(moment(a).isoWeekday(4).date(), 13, 'set from sun to thu');
        assert.equal(moment(a).isoWeekday(7).date(), 16, 'set from sun to sun');
        assert.equal(moment(a).isoWeekday(-6).date(),  3, 'set from sun to last mon');
        assert.equal(moment(a).isoWeekday(-3).date(),  6, 'set from sun to last thu');
        assert.equal(moment(a).isoWeekday(0).date(),   9, 'set from sun to last sun');
        assert.equal(moment(a).isoWeekday(8).date(),  17, 'set from sun to next mon');
        assert.equal(moment(a).isoWeekday(11).date(), 20, 'set from sun to next thu');
        assert.equal(moment(a).isoWeekday(14).date(), 23, 'set from sun to next sun');
    });

    test('weekday first day of week Sunday (dow 0)', function (assert) {
        moment.locale('dow: 0,doy: 6', {week: {dow: 0, doy: 6}});
        assert.equal(moment([1985, 1,  3]).weekday(), 0, 'Feb  3 1985 is Sunday    -- 0th day');
        assert.equal(moment([2029, 8, 17]).weekday(), 1, 'Sep 17 2029 is Monday    -- 1st day');
        assert.equal(moment([2013, 3, 23]).weekday(), 2, 'Apr 23 2013 is Tuesday   -- 2nd day');
        assert.equal(moment([2015, 2,  4]).weekday(), 3, 'Mar  4 2015 is Wednesday -- 3nd day');
        assert.equal(moment([1970, 0,  1]).weekday(), 4, 'Jan  1 1970 is Thursday  -- 4th day');
        assert.equal(moment([2001, 4, 11]).weekday(), 5, 'May 11 2001 is Friday    -- 5th day');
        assert.equal(moment([2000, 0,  1]).weekday(), 6, 'Jan  1 2000 is Saturday  -- 6th day');
    });

    test('weekday first day of week Monday (dow 1)', function (assert) {
        moment.locale('dow: 1,doy: 6', {week: {dow: 1, doy: 6}});
        assert.equal(moment([1985, 1,  4]).weekday(), 0, 'Feb  4 1985 is Monday    -- 0th day');
        assert.equal(moment([2029, 8, 18]).weekday(), 1, 'Sep 18 2029 is Tuesday   -- 1st day');
        assert.equal(moment([2013, 3, 24]).weekday(), 2, 'Apr 24 2013 is Wednesday -- 2nd day');
        assert.equal(moment([2015, 2,  5]).weekday(), 3, 'Mar  5 2015 is Thursday  -- 3nd day');
        assert.equal(moment([1970, 0,  2]).weekday(), 4, 'Jan  2 1970 is Friday    -- 4th day');
        assert.equal(moment([2001, 4, 12]).weekday(), 5, 'May 12 2001 is Saturday  -- 5th day');
        assert.equal(moment([2000, 0,  2]).weekday(), 6, 'Jan  2 2000 is Sunday    -- 6th day');
    });

    test('weekday first day of week Tuesday (dow 2)', function (assert) {
        moment.locale('dow: 2,doy: 6', {week: {dow: 2, doy: 6}});
        assert.equal(moment([1985, 1,  5]).weekday(), 0, 'Feb  5 1985 is Tuesday   -- 0th day');
        assert.equal(moment([2029, 8, 19]).weekday(), 1, 'Sep 19 2029 is Wednesday -- 1st day');
        assert.equal(moment([2013, 3, 25]).weekday(), 2, 'Apr 25 2013 is Thursday  -- 2nd day');
        assert.equal(moment([2015, 2,  6]).weekday(), 3, 'Mar  6 2015 is Friday    -- 3nd day');
        assert.equal(moment([1970, 0,  3]).weekday(), 4, 'Jan  3 1970 is Staturday -- 4th day');
        assert.equal(moment([2001, 4, 13]).weekday(), 5, 'May 13 2001 is Sunday    -- 5th day');
        assert.equal(moment([2000, 0,  3]).weekday(), 6, 'Jan  3 2000 is Monday    -- 6th day');
    });

    test('weekday first day of week Wednesday (dow 3)', function (assert) {
        moment.locale('dow: 3,doy: 6', {week: {dow: 3, doy: 6}});
        assert.equal(moment([1985, 1,  6]).weekday(), 0, 'Feb  6 1985 is Wednesday -- 0th day');
        assert.equal(moment([2029, 8, 20]).weekday(), 1, 'Sep 20 2029 is Thursday  -- 1st day');
        assert.equal(moment([2013, 3, 26]).weekday(), 2, 'Apr 26 2013 is Friday    -- 2nd day');
        assert.equal(moment([2015, 2,  7]).weekday(), 3, 'Mar  7 2015 is Saturday  -- 3nd day');
        assert.equal(moment([1970, 0,  4]).weekday(), 4, 'Jan  4 1970 is Sunday    -- 4th day');
        assert.equal(moment([2001, 4, 14]).weekday(), 5, 'May 14 2001 is Monday    -- 5th day');
        assert.equal(moment([2000, 0,  4]).weekday(), 6, 'Jan  4 2000 is Tuesday   -- 6th day');
        moment.locale('dow:3,doy:6', null);
    });

    test('weekday first day of week Thursday (dow 4)', function (assert) {
        moment.locale('dow: 4,doy: 6', {week: {dow: 4, doy: 6}});
        assert.equal(moment([1985, 1,  7]).weekday(), 0, 'Feb  7 1985 is Thursday  -- 0th day');
        assert.equal(moment([2029, 8, 21]).weekday(), 1, 'Sep 21 2029 is Friday    -- 1st day');
        assert.equal(moment([2013, 3, 27]).weekday(), 2, 'Apr 27 2013 is Saturday  -- 2nd day');
        assert.equal(moment([2015, 2,  8]).weekday(), 3, 'Mar  8 2015 is Sunday    -- 3nd day');
        assert.equal(moment([1970, 0,  5]).weekday(), 4, 'Jan  5 1970 is Monday    -- 4th day');
        assert.equal(moment([2001, 4, 15]).weekday(), 5, 'May 15 2001 is Tuesday   -- 5th day');
        assert.equal(moment([2000, 0,  5]).weekday(), 6, 'Jan  5 2000 is Wednesday -- 6th day');
    });

    test('weekday first day of week Friday (dow 5)', function (assert) {
        moment.locale('dow: 5,doy: 6', {week: {dow: 5, doy: 6}});
        assert.equal(moment([1985, 1,  8]).weekday(), 0, 'Feb  8 1985 is Friday    -- 0th day');
        assert.equal(moment([2029, 8, 22]).weekday(), 1, 'Sep 22 2029 is Staturday -- 1st day');
        assert.equal(moment([2013, 3, 28]).weekday(), 2, 'Apr 28 2013 is Sunday    -- 2nd day');
        assert.equal(moment([2015, 2,  9]).weekday(), 3, 'Mar  9 2015 is Monday    -- 3nd day');
        assert.equal(moment([1970, 0,  6]).weekday(), 4, 'Jan  6 1970 is Tuesday   -- 4th day');
        assert.equal(moment([2001, 4, 16]).weekday(), 5, 'May 16 2001 is Wednesday -- 5th day');
        assert.equal(moment([2000, 0,  6]).weekday(), 6, 'Jan  6 2000 is Thursday  -- 6th day');
    });

    test('weekday first day of week Saturday (dow 6)', function (assert) {
        moment.locale('dow: 6,doy: 6', {week: {dow: 6, doy: 6}});
        assert.equal(moment([1985, 1,  9]).weekday(), 0, 'Feb  9 1985 is Staturday -- 0th day');
        assert.equal(moment([2029, 8, 23]).weekday(), 1, 'Sep 23 2029 is Sunday    -- 1st day');
        assert.equal(moment([2013, 3, 29]).weekday(), 2, 'Apr 29 2013 is Monday    -- 2nd day');
        assert.equal(moment([2015, 2, 10]).weekday(), 3, 'Mar 10 2015 is Tuesday   -- 3nd day');
        assert.equal(moment([1970, 0,  7]).weekday(), 4, 'Jan  7 1970 is Wednesday -- 4th day');
        assert.equal(moment([2001, 4, 17]).weekday(), 5, 'May 17 2001 is Thursday  -- 5th day');
        assert.equal(moment([2000, 0,  7]).weekday(), 6, 'Jan  7 2000 is Friday    -- 6th day');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('weeks');

    test('day of year', function (assert) {
        assert.equal(moment([2000,  0,  1]).dayOfYear(),   1, 'Jan  1 2000 should be day 1 of the year');
        assert.equal(moment([2000,  1, 28]).dayOfYear(),  59, 'Feb 28 2000 should be day 59 of the year');
        assert.equal(moment([2000,  1, 29]).dayOfYear(),  60, 'Feb 28 2000 should be day 60 of the year');
        assert.equal(moment([2000, 11, 31]).dayOfYear(), 366, 'Dec 31 2000 should be day 366 of the year');
        assert.equal(moment([2001,  0,  1]).dayOfYear(),   1, 'Jan  1 2001 should be day 1 of the year');
        assert.equal(moment([2001,  1, 28]).dayOfYear(),  59, 'Feb 28 2001 should be day 59 of the year');
        assert.equal(moment([2001,  2,  1]).dayOfYear(),  60, 'Mar  1 2001 should be day 60 of the year');
        assert.equal(moment([2001, 11, 31]).dayOfYear(), 365, 'Dec 31 2001 should be day 365 of the year');
    });

    test('day of year setters', function (assert) {
        assert.equal(moment([2000,  0,  1]).dayOfYear(200).dayOfYear(), 200, 'Setting Jan  1 2000 day of the year to 200 should work');
        assert.equal(moment([2000,  1, 28]).dayOfYear(200).dayOfYear(), 200, 'Setting Feb 28 2000 day of the year to 200 should work');
        assert.equal(moment([2000,  1, 29]).dayOfYear(200).dayOfYear(), 200, 'Setting Feb 28 2000 day of the year to 200 should work');
        assert.equal(moment([2000, 11, 31]).dayOfYear(200).dayOfYear(), 200, 'Setting Dec 31 2000 day of the year to 200 should work');
        assert.equal(moment().dayOfYear(1).dayOfYear(),   1, 'Setting day of the year to 1 should work');
        assert.equal(moment().dayOfYear(59).dayOfYear(),  59, 'Setting day of the year to 59 should work');
        assert.equal(moment().dayOfYear(60).dayOfYear(),  60, 'Setting day of the year to 60 should work');
        assert.equal(moment().dayOfYear(365).dayOfYear(), 365, 'Setting day of the year to 365 should work');
    });

    test('iso weeks year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).isoWeek(), 52, 'Jan  1 2012 should be iso week 52');
        assert.equal(moment([2012, 0, 2]).isoWeek(),  1, 'Jan  2 2012 should be iso week 1');
        assert.equal(moment([2012, 0, 8]).isoWeek(),  1, 'Jan  8 2012 should be iso week 1');
        assert.equal(moment([2012, 0, 9]).isoWeek(),  2, 'Jan  9 2012 should be iso week 2');
        assert.equal(moment([2012, 0, 15]).isoWeek(), 2, 'Jan 15 2012 should be iso week 2');
    });

    test('iso weeks year starting monday', function (assert) {
        assert.equal(moment([2007, 0, 1]).isoWeek(),  1, 'Jan  1 2007 should be iso week 1');
        assert.equal(moment([2007, 0, 7]).isoWeek(),  1, 'Jan  7 2007 should be iso week 1');
        assert.equal(moment([2007, 0, 8]).isoWeek(),  2, 'Jan  8 2007 should be iso week 2');
        assert.equal(moment([2007, 0, 14]).isoWeek(), 2, 'Jan 14 2007 should be iso week 2');
        assert.equal(moment([2007, 0, 15]).isoWeek(), 3, 'Jan 15 2007 should be iso week 3');
    });

    test('iso weeks year starting tuesday', function (assert) {
        assert.equal(moment([2007, 11, 31]).isoWeek(), 1, 'Dec 31 2007 should be iso week 1');
        assert.equal(moment([2008,  0,  1]).isoWeek(), 1, 'Jan  1 2008 should be iso week 1');
        assert.equal(moment([2008,  0,  6]).isoWeek(), 1, 'Jan  6 2008 should be iso week 1');
        assert.equal(moment([2008,  0,  7]).isoWeek(), 2, 'Jan  7 2008 should be iso week 2');
        assert.equal(moment([2008,  0, 13]).isoWeek(), 2, 'Jan 13 2008 should be iso week 2');
        assert.equal(moment([2008,  0, 14]).isoWeek(), 3, 'Jan 14 2008 should be iso week 3');
    });

    test('iso weeks year starting wednesday', function (assert) {
        assert.equal(moment([2002, 11, 30]).isoWeek(), 1, 'Dec 30 2002 should be iso week 1');
        assert.equal(moment([2003,  0,  1]).isoWeek(), 1, 'Jan  1 2003 should be iso week 1');
        assert.equal(moment([2003,  0,  5]).isoWeek(), 1, 'Jan  5 2003 should be iso week 1');
        assert.equal(moment([2003,  0,  6]).isoWeek(), 2, 'Jan  6 2003 should be iso week 2');
        assert.equal(moment([2003,  0, 12]).isoWeek(), 2, 'Jan 12 2003 should be iso week 2');
        assert.equal(moment([2003,  0, 13]).isoWeek(), 3, 'Jan 13 2003 should be iso week 3');
    });

    test('iso weeks year starting thursday', function (assert) {
        assert.equal(moment([2008, 11, 29]).isoWeek(), 1, 'Dec 29 2008 should be iso week 1');
        assert.equal(moment([2009,  0,  1]).isoWeek(), 1, 'Jan  1 2009 should be iso week 1');
        assert.equal(moment([2009,  0,  4]).isoWeek(), 1, 'Jan  4 2009 should be iso week 1');
        assert.equal(moment([2009,  0,  5]).isoWeek(), 2, 'Jan  5 2009 should be iso week 2');
        assert.equal(moment([2009,  0, 11]).isoWeek(), 2, 'Jan 11 2009 should be iso week 2');
        assert.equal(moment([2009,  0, 13]).isoWeek(), 3, 'Jan 12 2009 should be iso week 3');
    });

    test('iso weeks year starting friday', function (assert) {
        assert.equal(moment([2009, 11, 28]).isoWeek(), 53, 'Dec 28 2009 should be iso week 53');
        assert.equal(moment([2010,  0,  1]).isoWeek(), 53, 'Jan  1 2010 should be iso week 53');
        assert.equal(moment([2010,  0,  3]).isoWeek(), 53, 'Jan  3 2010 should be iso week 53');
        assert.equal(moment([2010,  0,  4]).isoWeek(),  1, 'Jan  4 2010 should be iso week 1');
        assert.equal(moment([2010,  0, 10]).isoWeek(),  1, 'Jan 10 2010 should be iso week 1');
        assert.equal(moment([2010,  0, 11]).isoWeek(),  2, 'Jan 11 2010 should be iso week 2');
    });

    test('iso weeks year starting saturday', function (assert) {
        assert.equal(moment([2010, 11, 27]).isoWeek(), 52, 'Dec 27 2010 should be iso week 52');
        assert.equal(moment([2011,  0,  1]).isoWeek(), 52, 'Jan  1 2011 should be iso week 52');
        assert.equal(moment([2011,  0,  2]).isoWeek(), 52, 'Jan  2 2011 should be iso week 52');
        assert.equal(moment([2011,  0,  3]).isoWeek(),  1, 'Jan  3 2011 should be iso week 1');
        assert.equal(moment([2011,  0,  9]).isoWeek(),  1, 'Jan  9 2011 should be iso week 1');
        assert.equal(moment([2011,  0, 10]).isoWeek(),  2, 'Jan 10 2011 should be iso week 2');
    });

    test('iso weeks year starting sunday formatted', function (assert) {
        assert.equal(moment([2012, 0,  1]).format('W WW Wo'), '52 52 52nd', 'Jan  1 2012 should be iso week 52');
        assert.equal(moment([2012, 0,  2]).format('W WW Wo'),   '1 01 1st', 'Jan  2 2012 should be iso week 1');
        assert.equal(moment([2012, 0,  8]).format('W WW Wo'),   '1 01 1st', 'Jan  8 2012 should be iso week 1');
        assert.equal(moment([2012, 0,  9]).format('W WW Wo'),   '2 02 2nd', 'Jan  9 2012 should be iso week 2');
        assert.equal(moment([2012, 0, 15]).format('W WW Wo'),   '2 02 2nd', 'Jan 15 2012 should be iso week 2');
    });

    test('weeks plural year starting sunday', function (assert) {
        assert.equal(moment([2012, 0,  1]).weeks(), 1, 'Jan  1 2012 should be week 1');
        assert.equal(moment([2012, 0,  7]).weeks(), 1, 'Jan  7 2012 should be week 1');
        assert.equal(moment([2012, 0,  8]).weeks(), 2, 'Jan  8 2012 should be week 2');
        assert.equal(moment([2012, 0, 14]).weeks(), 2, 'Jan 14 2012 should be week 2');
        assert.equal(moment([2012, 0, 15]).weeks(), 3, 'Jan 15 2012 should be week 3');
    });

    test('iso weeks plural year starting sunday', function (assert) {
        assert.equal(moment([2012, 0, 1]).isoWeeks(), 52, 'Jan  1 2012 should be iso week 52');
        assert.equal(moment([2012, 0, 2]).isoWeeks(),  1, 'Jan  2 2012 should be iso week 1');
        assert.equal(moment([2012, 0, 8]).isoWeeks(),  1, 'Jan  8 2012 should be iso week 1');
        assert.equal(moment([2012, 0, 9]).isoWeeks(),  2, 'Jan  9 2012 should be iso week 2');
        assert.equal(moment([2012, 0, 15]).isoWeeks(), 2, 'Jan 15 2012 should be iso week 2');
    });

    test('weeks setter', function (assert) {
        assert.equal(moment([2012, 0,  1]).week(30).week(), 30, 'Setting Jan 1 2012 to week 30 should work');
        assert.equal(moment([2012, 0,  7]).week(30).week(), 30, 'Setting Jan 7 2012 to week 30 should work');
        assert.equal(moment([2012, 0,  8]).week(30).week(), 30, 'Setting Jan 8 2012 to week 30 should work');
        assert.equal(moment([2012, 0, 14]).week(30).week(), 30, 'Setting Jan 14 2012 to week 30 should work');
        assert.equal(moment([2012, 0, 15]).week(30).week(), 30, 'Setting Jan 15 2012 to week 30 should work');
    });

    test('iso weeks setter', function (assert) {
        assert.equal(moment([2012, 0,  1]).isoWeeks(25).isoWeeks(), 25, 'Setting Jan  1 2012 to week 25 should work');
        assert.equal(moment([2012, 0,  2]).isoWeeks(24).isoWeeks(), 24, 'Setting Jan  2 2012 to week 24 should work');
        assert.equal(moment([2012, 0,  8]).isoWeeks(23).isoWeeks(), 23, 'Setting Jan  8 2012 to week 23 should work');
        assert.equal(moment([2012, 0,  9]).isoWeeks(22).isoWeeks(), 22, 'Setting Jan  9 2012 to week 22 should work');
        assert.equal(moment([2012, 0, 15]).isoWeeks(21).isoWeeks(), 21, 'Setting Jan 15 2012 to week 21 should work');
    });

    test('iso weeks setter day of year', function (assert) {
        assert.equal(moment([2012, 0,  1]).isoWeek(1).dayOfYear(), 9, 'Setting Jan  1 2012 to week 1 should be day of year 8');
        assert.equal(moment([2012, 0,  1]).isoWeek(1).year(),   2011, 'Setting Jan  1 2012 to week 1 should be year 2011');
        assert.equal(moment([2012, 0,  2]).isoWeek(1).dayOfYear(), 2, 'Setting Jan  2 2012 to week 1 should be day of year 2');
        assert.equal(moment([2012, 0,  8]).isoWeek(1).dayOfYear(), 8, 'Setting Jan  8 2012 to week 1 should be day of year 8');
        assert.equal(moment([2012, 0,  9]).isoWeek(1).dayOfYear(), 2, 'Setting Jan  9 2012 to week 1 should be day of year 2');
        assert.equal(moment([2012, 0, 15]).isoWeek(1).dayOfYear(), 8, 'Setting Jan 15 2012 to week 1 should be day of year 8');
    });

    test('years with iso week 53', function (assert) {
        // Based on a table taken from http://en.wikipedia.org/wiki/ISO_week_date
        // (as downloaded on 2014-01-06) listing the 71 years in a 400-year cycle
        // that have 53 weeks; in this case reflecting the 2000 based cycle
        assert.equal(moment([2004, 11, 31]).isoWeek(), 53, 'Dec 31 2004 should be iso week 53');
        assert.equal(moment([2009, 11, 31]).isoWeek(), 53, 'Dec 31 2009 should be iso week 53');
        assert.equal(moment([2015, 11, 31]).isoWeek(), 53, 'Dec 31 2015 should be iso week 53');
        assert.equal(moment([2020, 11, 31]).isoWeek(), 53, 'Dec 31 2020 should be iso week 53');
        assert.equal(moment([2026, 11, 31]).isoWeek(), 53, 'Dec 31 2026 should be iso week 53');
        assert.equal(moment([2032, 11, 31]).isoWeek(), 53, 'Dec 31 2032 should be iso week 53');
        assert.equal(moment([2037, 11, 31]).isoWeek(), 53, 'Dec 31 2037 should be iso week 53');
        assert.equal(moment([2043, 11, 31]).isoWeek(), 53, 'Dec 31 2043 should be iso week 53');
        assert.equal(moment([2048, 11, 31]).isoWeek(), 53, 'Dec 31 2048 should be iso week 53');
        assert.equal(moment([2054, 11, 31]).isoWeek(), 53, 'Dec 31 2054 should be iso week 53');
        assert.equal(moment([2060, 11, 31]).isoWeek(), 53, 'Dec 31 2060 should be iso week 53');
        assert.equal(moment([2065, 11, 31]).isoWeek(), 53, 'Dec 31 2065 should be iso week 53');
        assert.equal(moment([2071, 11, 31]).isoWeek(), 53, 'Dec 31 2071 should be iso week 53');
        assert.equal(moment([2076, 11, 31]).isoWeek(), 53, 'Dec 31 2076 should be iso week 53');
        assert.equal(moment([2082, 11, 31]).isoWeek(), 53, 'Dec 31 2082 should be iso week 53');
        assert.equal(moment([2088, 11, 31]).isoWeek(), 53, 'Dec 31 2088 should be iso week 53');
        assert.equal(moment([2093, 11, 31]).isoWeek(), 53, 'Dec 31 2093 should be iso week 53');
        assert.equal(moment([2099, 11, 31]).isoWeek(), 53, 'Dec 31 2099 should be iso week 53');
        assert.equal(moment([2105, 11, 31]).isoWeek(), 53, 'Dec 31 2105 should be iso week 53');
        assert.equal(moment([2111, 11, 31]).isoWeek(), 53, 'Dec 31 2111 should be iso week 53');
        assert.equal(moment([2116, 11, 31]).isoWeek(), 53, 'Dec 31 2116 should be iso week 53');
        assert.equal(moment([2122, 11, 31]).isoWeek(), 53, 'Dec 31 2122 should be iso week 53');
        assert.equal(moment([2128, 11, 31]).isoWeek(), 53, 'Dec 31 2128 should be iso week 53');
        assert.equal(moment([2133, 11, 31]).isoWeek(), 53, 'Dec 31 2133 should be iso week 53');
        assert.equal(moment([2139, 11, 31]).isoWeek(), 53, 'Dec 31 2139 should be iso week 53');
        assert.equal(moment([2144, 11, 31]).isoWeek(), 53, 'Dec 31 2144 should be iso week 53');
        assert.equal(moment([2150, 11, 31]).isoWeek(), 53, 'Dec 31 2150 should be iso week 53');
        assert.equal(moment([2156, 11, 31]).isoWeek(), 53, 'Dec 31 2156 should be iso week 53');
        assert.equal(moment([2161, 11, 31]).isoWeek(), 53, 'Dec 31 2161 should be iso week 53');
        assert.equal(moment([2167, 11, 31]).isoWeek(), 53, 'Dec 31 2167 should be iso week 53');
        assert.equal(moment([2172, 11, 31]).isoWeek(), 53, 'Dec 31 2172 should be iso week 53');
        assert.equal(moment([2178, 11, 31]).isoWeek(), 53, 'Dec 31 2178 should be iso week 53');
        assert.equal(moment([2184, 11, 31]).isoWeek(), 53, 'Dec 31 2184 should be iso week 53');
        assert.equal(moment([2189, 11, 31]).isoWeek(), 53, 'Dec 31 2189 should be iso week 53');
        assert.equal(moment([2195, 11, 31]).isoWeek(), 53, 'Dec 31 2195 should be iso week 53');
        assert.equal(moment([2201, 11, 31]).isoWeek(), 53, 'Dec 31 2201 should be iso week 53');
        assert.equal(moment([2207, 11, 31]).isoWeek(), 53, 'Dec 31 2207 should be iso week 53');
        assert.equal(moment([2212, 11, 31]).isoWeek(), 53, 'Dec 31 2212 should be iso week 53');
        assert.equal(moment([2218, 11, 31]).isoWeek(), 53, 'Dec 31 2218 should be iso week 53');
        assert.equal(moment([2224, 11, 31]).isoWeek(), 53, 'Dec 31 2224 should be iso week 53');
        assert.equal(moment([2229, 11, 31]).isoWeek(), 53, 'Dec 31 2229 should be iso week 53');
        assert.equal(moment([2235, 11, 31]).isoWeek(), 53, 'Dec 31 2235 should be iso week 53');
        assert.equal(moment([2240, 11, 31]).isoWeek(), 53, 'Dec 31 2240 should be iso week 53');
        assert.equal(moment([2246, 11, 31]).isoWeek(), 53, 'Dec 31 2246 should be iso week 53');
        assert.equal(moment([2252, 11, 31]).isoWeek(), 53, 'Dec 31 2252 should be iso week 53');
        assert.equal(moment([2257, 11, 31]).isoWeek(), 53, 'Dec 31 2257 should be iso week 53');
        assert.equal(moment([2263, 11, 31]).isoWeek(), 53, 'Dec 31 2263 should be iso week 53');
        assert.equal(moment([2268, 11, 31]).isoWeek(), 53, 'Dec 31 2268 should be iso week 53');
        assert.equal(moment([2274, 11, 31]).isoWeek(), 53, 'Dec 31 2274 should be iso week 53');
        assert.equal(moment([2280, 11, 31]).isoWeek(), 53, 'Dec 31 2280 should be iso week 53');
        assert.equal(moment([2285, 11, 31]).isoWeek(), 53, 'Dec 31 2285 should be iso week 53');
        assert.equal(moment([2291, 11, 31]).isoWeek(), 53, 'Dec 31 2291 should be iso week 53');
        assert.equal(moment([2296, 11, 31]).isoWeek(), 53, 'Dec 31 2296 should be iso week 53');
        assert.equal(moment([2303, 11, 31]).isoWeek(), 53, 'Dec 31 2303 should be iso week 53');
        assert.equal(moment([2308, 11, 31]).isoWeek(), 53, 'Dec 31 2308 should be iso week 53');
        assert.equal(moment([2314, 11, 31]).isoWeek(), 53, 'Dec 31 2314 should be iso week 53');
        assert.equal(moment([2320, 11, 31]).isoWeek(), 53, 'Dec 31 2320 should be iso week 53');
        assert.equal(moment([2325, 11, 31]).isoWeek(), 53, 'Dec 31 2325 should be iso week 53');
        assert.equal(moment([2331, 11, 31]).isoWeek(), 53, 'Dec 31 2331 should be iso week 53');
        assert.equal(moment([2336, 11, 31]).isoWeek(), 53, 'Dec 31 2336 should be iso week 53');
        assert.equal(moment([2342, 11, 31]).isoWeek(), 53, 'Dec 31 2342 should be iso week 53');
        assert.equal(moment([2348, 11, 31]).isoWeek(), 53, 'Dec 31 2348 should be iso week 53');
        assert.equal(moment([2353, 11, 31]).isoWeek(), 53, 'Dec 31 2353 should be iso week 53');
        assert.equal(moment([2359, 11, 31]).isoWeek(), 53, 'Dec 31 2359 should be iso week 53');
        assert.equal(moment([2364, 11, 31]).isoWeek(), 53, 'Dec 31 2364 should be iso week 53');
        assert.equal(moment([2370, 11, 31]).isoWeek(), 53, 'Dec 31 2370 should be iso week 53');
        assert.equal(moment([2376, 11, 31]).isoWeek(), 53, 'Dec 31 2376 should be iso week 53');
        assert.equal(moment([2381, 11, 31]).isoWeek(), 53, 'Dec 31 2381 should be iso week 53');
        assert.equal(moment([2387, 11, 31]).isoWeek(), 53, 'Dec 31 2387 should be iso week 53');
        assert.equal(moment([2392, 11, 31]).isoWeek(), 53, 'Dec 31 2392 should be iso week 53');
        assert.equal(moment([2398, 11, 31]).isoWeek(), 53, 'Dec 31 2398 should be iso week 53');
    });

    test('count years with iso week 53', function (assert) {
        // Based on http://en.wikipedia.org/wiki/ISO_week_date (as seen on 2014-01-06)
        // stating that there are 71 years in a 400-year cycle that have 53 weeks;
        // in this case reflecting the 2000 based cycle
        var count = 0, i;
        for (i = 0; i < 400; i++) {
            count += (moment([2000 + i, 11, 31]).isoWeek() === 53) ? 1 : 0;
        }
        assert.equal(count, 71, 'Should have 71 years in 400-year cycle with iso week 53');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('weeks in year');

    test('isoWeeksInYear', function (assert) {
        assert.equal(moment([2004]).isoWeeksInYear(), 53, '2004 has 53 iso weeks');
        assert.equal(moment([2005]).isoWeeksInYear(), 52, '2005 has 53 iso weeks');
        assert.equal(moment([2006]).isoWeeksInYear(), 52, '2006 has 53 iso weeks');
        assert.equal(moment([2007]).isoWeeksInYear(), 52, '2007 has 52 iso weeks');
        assert.equal(moment([2008]).isoWeeksInYear(), 52, '2008 has 53 iso weeks');
        assert.equal(moment([2009]).isoWeeksInYear(), 53, '2009 has 53 iso weeks');
        assert.equal(moment([2010]).isoWeeksInYear(), 52, '2010 has 52 iso weeks');
        assert.equal(moment([2011]).isoWeeksInYear(), 52, '2011 has 52 iso weeks');
        assert.equal(moment([2012]).isoWeeksInYear(), 52, '2012 has 52 iso weeks');
        assert.equal(moment([2013]).isoWeeksInYear(), 52, '2013 has 52 iso weeks');
        assert.equal(moment([2014]).isoWeeksInYear(), 52, '2014 has 52 iso weeks');
        assert.equal(moment([2015]).isoWeeksInYear(), 53, '2015 has 53 iso weeks');
    });

    test('weeksInYear doy/dow = 1/4', function (assert) {
        moment.locale('1/4', {week: {dow: 1, doy: 4}});

        assert.equal(moment([2004]).weeksInYear(), 53, '2004 has 53 weeks');
        assert.equal(moment([2005]).weeksInYear(), 52, '2005 has 53 weeks');
        assert.equal(moment([2006]).weeksInYear(), 52, '2006 has 53 weeks');
        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');
        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');
        assert.equal(moment([2009]).weeksInYear(), 53, '2009 has 53 weeks');
        assert.equal(moment([2010]).weeksInYear(), 52, '2010 has 52 weeks');
        assert.equal(moment([2011]).weeksInYear(), 52, '2011 has 52 weeks');
        assert.equal(moment([2012]).weeksInYear(), 52, '2012 has 52 weeks');
        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');
        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');
        assert.equal(moment([2015]).weeksInYear(), 53, '2015 has 53 weeks');
    });

    test('weeksInYear doy/dow = 6/12', function (assert) {
        moment.locale('6/12', {week: {dow: 6, doy: 12}});

        assert.equal(moment([2004]).weeksInYear(), 53, '2004 has 53 weeks');
        assert.equal(moment([2005]).weeksInYear(), 52, '2005 has 53 weeks');
        assert.equal(moment([2006]).weeksInYear(), 52, '2006 has 53 weeks');
        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');
        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');
        assert.equal(moment([2009]).weeksInYear(), 52, '2009 has 53 weeks');
        assert.equal(moment([2010]).weeksInYear(), 53, '2010 has 52 weeks');
        assert.equal(moment([2011]).weeksInYear(), 52, '2011 has 52 weeks');
        assert.equal(moment([2012]).weeksInYear(), 52, '2012 has 52 weeks');
        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');
        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');
        assert.equal(moment([2015]).weeksInYear(), 52, '2015 has 53 weeks');
    });

    test('weeksInYear doy/dow = 1/7', function (assert) {
        moment.locale('1/7', {week: {dow: 1, doy: 7}});

        assert.equal(moment([2004]).weeksInYear(), 52, '2004 has 53 weeks');
        assert.equal(moment([2005]).weeksInYear(), 52, '2005 has 53 weeks');
        assert.equal(moment([2006]).weeksInYear(), 53, '2006 has 53 weeks');
        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');
        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');
        assert.equal(moment([2009]).weeksInYear(), 52, '2009 has 53 weeks');
        assert.equal(moment([2010]).weeksInYear(), 52, '2010 has 52 weeks');
        assert.equal(moment([2011]).weeksInYear(), 52, '2011 has 52 weeks');
        assert.equal(moment([2012]).weeksInYear(), 53, '2012 has 52 weeks');
        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');
        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');
        assert.equal(moment([2015]).weeksInYear(), 52, '2015 has 53 weeks');
    });

    test('weeksInYear doy/dow = 0/6', function (assert) {
        moment.locale('0/6', {week: {dow: 0, doy: 6}});

        assert.equal(moment([2004]).weeksInYear(), 52, '2004 has 53 weeks');
        assert.equal(moment([2005]).weeksInYear(), 53, '2005 has 53 weeks');
        assert.equal(moment([2006]).weeksInYear(), 52, '2006 has 53 weeks');
        assert.equal(moment([2007]).weeksInYear(), 52, '2007 has 52 weeks');
        assert.equal(moment([2008]).weeksInYear(), 52, '2008 has 53 weeks');
        assert.equal(moment([2009]).weeksInYear(), 52, '2009 has 53 weeks');
        assert.equal(moment([2010]).weeksInYear(), 52, '2010 has 52 weeks');
        assert.equal(moment([2011]).weeksInYear(), 53, '2011 has 52 weeks');
        assert.equal(moment([2012]).weeksInYear(), 52, '2012 has 52 weeks');
        assert.equal(moment([2013]).weeksInYear(), 52, '2013 has 52 weeks');
        assert.equal(moment([2014]).weeksInYear(), 52, '2014 has 52 weeks');
        assert.equal(moment([2015]).weeksInYear(), 52, '2015 has 53 weeks');
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('zone switching');

    test('local to utc, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss';
        assert.equal(m.clone().utc(true).format(fmt), m.format(fmt), 'local to utc failed to keep local time');
    });

    test('local to utc, keepLocalTime = false', function (assert) {
        var m = moment();
        assert.equal(m.clone().utc().valueOf(), m.valueOf(), 'local to utc failed to keep utc time (implicit)');
        assert.equal(m.clone().utc(false).valueOf(), m.valueOf(), 'local to utc failed to keep utc time (explicit)');
    });

    test('local to zone, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss',
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            assert.equal(m.clone().zone(z * 60, true).format(fmt), m.format(fmt),
                    'local to zone(' + z + ':00) failed to keep local time');
        }
    });

    test('local to zone, keepLocalTime = false', function (assert) {
        var m = moment(),
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            assert.equal(m.clone().zone(z * 60).valueOf(), m.valueOf(),
                    'local to zone(' + z + ':00) failed to keep utc time (implicit)');
            assert.equal(m.clone().zone(z * 60, false).valueOf(), m.valueOf(),
                    'local to zone(' + z + ':00) failed to keep utc time (explicit)');
        }
    });

    test('utc to local, keepLocalTime = true', function (assert) {
        var um = moment.utc(),
            fmt = 'YYYY-DD-MM HH:mm:ss';

        assert.equal(um.clone().local(true).format(fmt), um.format(fmt), 'utc to local failed to keep local time');
    });

    test('utc to local, keepLocalTime = false', function (assert) {
        var um = moment.utc();
        assert.equal(um.clone().local().valueOf(), um.valueOf(), 'utc to local failed to keep utc time (implicit)');
        assert.equal(um.clone().local(false).valueOf(), um.valueOf(), 'utc to local failed to keep utc time (explicit)');
    });

    test('zone to local, keepLocalTime = true', function (assert) {
        var m = moment(),
            fmt = 'YYYY-DD-MM HH:mm:ss',
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            m.zone(z * 60);

            assert.equal(m.clone().local(true).format(fmt), m.format(fmt),
                    'zone(' + z + ':00) to local failed to keep local time');
        }
    });

    test('zone to local, keepLocalTime = false', function (assert) {
        var m = moment(),
            z;

        // Apparently there is -12:00 and +14:00
        // http://en.wikipedia.org/wiki/UTC+14:00
        // http://en.wikipedia.org/wiki/UTC-12:00
        for (z = -12; z <= 14; ++z) {
            m.zone(z * 60);

            assert.equal(m.clone().local(false).valueOf(), m.valueOf(),
                    'zone(' + z + ':00) to local failed to keep utc time (explicit)');
            assert.equal(m.clone().local().valueOf(), m.valueOf(),
                    'zone(' + z + ':00) to local failed to keep utc time (implicit)');
        }
    });

}));

(function (global, factory) {
   typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('../../moment')) :
   typeof define === 'function' && define.amd ? define(['../../moment'], factory) :
   factory(global.moment)
}(this, function (moment) { 'use strict';

    /*global QUnit:false*/

    var test = QUnit.test;

    function module (name, lifecycle) {
        QUnit.module(name, {
            setup : function () {
                moment.locale('en');
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    function localeModule (name, lifecycle) {
        QUnit.module('locale:' + name, {
            setup : function () {
                moment.locale(name);
                moment.createFromInputFallback = function () {
                    throw new Error('input not handled by moment');
                };
                if (lifecycle && lifecycle.setup) {
                    lifecycle.setup();
                }
            },
            teardown : function () {
                moment.locale('en');
                if (lifecycle && lifecycle.teardown) {
                    lifecycle.teardown();
                }
            }
        });
    }

    module('zones');

    test('set zone', function (assert) {
        var zone = moment();

        zone.zone(0);
        assert.equal(zone.zone(), 0, 'should be able to set the zone to 0');

        zone.zone(60);
        assert.equal(zone.zone(), 60, 'should be able to set the zone to 60');

        zone.zone(-60);
        assert.equal(zone.zone(), -60, 'should be able to set the zone to -60');
    });

    test('set zone shorthand', function (assert) {
        var zone = moment();

        zone.zone(1);
        assert.equal(zone.zone(), 60, 'setting the zone to 1 should imply hours and convert to 60');

        zone.zone(-1);
        assert.equal(zone.zone(), -60, 'setting the zone to -1 should imply hours and convert to -60');

        zone.zone(15);
        assert.equal(zone.zone(), 900, 'setting the zone to 15 should imply hours and convert to 900');

        zone.zone(-15);
        assert.equal(zone.zone(), -900, 'setting the zone to -15 should imply hours and convert to -900');

        zone.zone(16);
        assert.equal(zone.zone(), 16, 'setting the zone to 16 should imply minutes');

        zone.zone(-16);
        assert.equal(zone.zone(), -16, 'setting the zone to -16 should imply minutes');
    });

    test('set zone with string', function (assert) {
        var zone = moment();

        zone.zone('+00:00');
        assert.equal(zone.zone(), 0, 'set the zone with a timezone string');

        zone.zone('2013-03-07T07:00:00-08:00');
        assert.equal(zone.zone(), 480, 'set the zone with a string that does not begin with the timezone');

        zone.zone('2013-03-07T07:00:00+0100');
        assert.equal(zone.zone(), -60, 'set the zone with a string that uses the +0000 syntax');

        zone.zone('03-07-2013T07:00:00-08:00');
        assert.equal(zone.zone(), 480, 'set the zone with a string with a non-ISO 8601 date');
    });

    test('change hours when changing the zone', function (assert) {
        var zone = moment.utc([2000, 0, 1, 6]);

        zone.zone(0);
        assert.equal(zone.hour(), 6, 'UTC 6AM should be 6AM at +0000');

        zone.zone(60);
        assert.equal(zone.hour(), 5, 'UTC 6AM should be 5AM at -0100');

        zone.zone(-60);
        assert.equal(zone.hour(), 7, 'UTC 6AM should be 7AM at +0100');
    });

    test('change minutes when changing the zone', function (assert) {
        var zone = moment.utc([2000, 0, 1, 6, 31]);

        zone.zone(0);
        assert.equal(zone.format('HH:mm'), '06:31', 'UTC 6:31AM should be 6:31AM at +0000');

        zone.zone(30);
        assert.equal(zone.format('HH:mm'), '06:01', 'UTC 6:31AM should be 6:01AM at -0030');

        zone.zone(-30);
        assert.equal(zone.format('HH:mm'), '07:01', 'UTC 6:31AM should be 7:01AM at +0030');

        zone.zone(1380);
        assert.equal(zone.format('HH:mm'), '07:31', 'UTC 6:31AM should be 7:31AM at +1380');
    });

    test('distance from the unix epoch', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA),
            zoneC = moment(zoneA),
            zoneD = moment(zoneA),
            zoneE = moment(zoneA);

        zoneB.utc();
        assert.equal(+zoneA, +zoneB, 'moment should equal moment.utc');

        zoneC.zone(-60);
        assert.equal(+zoneA, +zoneC, 'moment should equal moment.zone(-60)');

        zoneD.zone(480);
        assert.equal(+zoneA, +zoneD, 'moment should equal moment.zone(480)');

        zoneE.zone(1000);
        assert.equal(+zoneA, +zoneE, 'moment should equal moment.zone(1000)');
    });

    test('update offset after changing any values', function (assert) {
        var oldOffset = moment.updateOffset,
            m = moment.utc([2000, 6, 1]);

        moment.updateOffset = function (mom, keepTime) {
            if (mom.__doChange) {
                if (+mom > 962409600000) {
                    mom.zone(120, keepTime);
                } else {
                    mom.zone(60, keepTime);
                }
            }
        };

        assert.equal(m.format('ZZ'), '+0000', 'should be at +0000');
        assert.equal(m.format('HH:mm'), '00:00', 'should start 12AM at +0000 timezone');

        m.__doChange = true;
        m.add(1, 'h');

        assert.equal(m.format('ZZ'), '-0200', 'should be at -0200');
        assert.equal(m.format('HH:mm'), '23:00', '1AM at +0000 should be 11PM at -0200 timezone');

        m.subtract(1, 'h');

        assert.equal(m.format('ZZ'), '-0100', 'should be at -0100');
        assert.equal(m.format('HH:mm'), '23:00', '12AM at +0000 should be 11PM at -0100 timezone');

        moment.updateOffset = oldOffset;
    });

    test('getters and setters', function (assert) {
        var a = moment([2011, 5, 20]);

        assert.equal(a.clone().zone(120).year(2012).year(), 2012, 'should get and set year correctly');
        assert.equal(a.clone().zone(120).month(1).month(), 1, 'should get and set month correctly');
        assert.equal(a.clone().zone(120).date(2).date(), 2, 'should get and set date correctly');
        assert.equal(a.clone().zone(120).day(1).day(), 1, 'should get and set day correctly');
        assert.equal(a.clone().zone(120).hour(1).hour(), 1, 'should get and set hour correctly');
        assert.equal(a.clone().zone(120).minute(1).minute(), 1, 'should get and set minute correctly');
    });

    test('getters', function (assert) {
        var a = moment.utc([2012, 0, 1, 0, 0, 0]);

        assert.equal(a.clone().zone(120).year(),  2011, 'should get year correctly');
        assert.equal(a.clone().zone(120).month(),   11, 'should get month correctly');
        assert.equal(a.clone().zone(120).date(),    31, 'should get date correctly');
        assert.equal(a.clone().zone(120).hour(),    22, 'should get hour correctly');
        assert.equal(a.clone().zone(120).minute(),   0, 'should get minute correctly');

        assert.equal(a.clone().zone(-120).year(),  2012, 'should get year correctly');
        assert.equal(a.clone().zone(-120).month(),    0, 'should get month correctly');
        assert.equal(a.clone().zone(-120).date(),     1, 'should get date correctly');
        assert.equal(a.clone().zone(-120).hour(),     2, 'should get hour correctly');
        assert.equal(a.clone().zone(-120).minute(),   0, 'should get minute correctly');

        assert.equal(a.clone().zone(-90).year(),  2012, 'should get year correctly');
        assert.equal(a.clone().zone(-90).month(),    0, 'should get month correctly');
        assert.equal(a.clone().zone(-90).date(),     1, 'should get date correctly');
        assert.equal(a.clone().zone(-90).hour(),     1, 'should get hour correctly');
        assert.equal(a.clone().zone(-90).minute(),  30, 'should get minute correctly');
    });

    test('from', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).zone(720),
            zoneC = moment(zoneA).zone(360),
            zoneD = moment(zoneA).zone(-690),
            other = moment(zoneA).add(35, 'm');

        assert.equal(zoneA.from(other), zoneB.from(other), 'moment#from should be the same in all zones');
        assert.equal(zoneA.from(other), zoneC.from(other), 'moment#from should be the same in all zones');
        assert.equal(zoneA.from(other), zoneD.from(other), 'moment#from should be the same in all zones');
    });

    test('diff', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).zone(720),
            zoneC = moment(zoneA).zone(360),
            zoneD = moment(zoneA).zone(-690),
            other = moment(zoneA).add(35, 'm');

        assert.equal(zoneA.diff(other), zoneB.diff(other), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other), zoneC.diff(other), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other), zoneD.diff(other), 'moment#diff should be the same in all zones');

        assert.equal(zoneA.diff(other, 'minute', true), zoneB.diff(other, 'minute', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'minute', true), zoneC.diff(other, 'minute', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'minute', true), zoneD.diff(other, 'minute', true), 'moment#diff should be the same in all zones');

        assert.equal(zoneA.diff(other, 'hour', true), zoneB.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'hour', true), zoneC.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
        assert.equal(zoneA.diff(other, 'hour', true), zoneD.diff(other, 'hour', true), 'moment#diff should be the same in all zones');
    });

    test('unix offset and timestamp', function (assert) {
        var zoneA = moment(),
            zoneB = moment(zoneA).zone(720),
            zoneC = moment(zoneA).zone(360),
            zoneD = moment(zoneA).zone(-690);

        assert.equal(zoneA.unix(), zoneB.unix(), 'moment#unix should be the same in all zones');
        assert.equal(zoneA.unix(), zoneC.unix(), 'moment#unix should be the same in all zones');
        assert.equal(zoneA.unix(), zoneD.unix(), 'moment#unix should be the same in all zones');

        assert.equal(+zoneA, +zoneB, 'moment#valueOf should be the same in all zones');
        assert.equal(+zoneA, +zoneC, 'moment#valueOf should be the same in all zones');
        assert.equal(+zoneA, +zoneD, 'moment#valueOf should be the same in all zones');
    });

    test('cloning', function (assert) {
        assert.equal(moment().zone(120).clone().zone(),   120, 'explicit cloning should retain the zone');
        assert.equal(moment().zone(-120).clone().zone(), -120, 'explicit cloning should retain the zone');
        assert.equal(moment(moment().zone(120)).zone(),   120, 'implicit cloning should retain the zone');
        assert.equal(moment(moment().zone(-120)).zone(), -120, 'implicit cloning should retain the zone');
    });

    test('start of / end of', function (assert) {
        var a = moment.utc([2010, 1, 2, 0, 0, 0]).zone(450);

        assert.equal(a.clone().startOf('day').hour(), 0, 'start of day should work on moments with a zone');
        assert.equal(a.clone().startOf('day').minute(), 0, 'start of day should work on moments with a zone');
        assert.equal(a.clone().startOf('hour').minute(), 0, 'start of hour should work on moments with a zone');

        assert.equal(a.clone().endOf('day').hour(), 23, 'end of day should work on moments with a zone');
        assert.equal(a.clone().endOf('day').minute(), 59, 'end of day should work on moments with a zone');
        assert.equal(a.clone().endOf('hour').minute(), 59, 'end of hour should work on moments with a zone');
    });

    test('reset zone with moment#utc', function (assert) {
        var a = moment.utc([2012]).zone(480);

        assert.equal(a.clone().hour(),      16, 'different zone should have different hour');
        assert.equal(a.clone().utc().hour(), 0, 'calling moment#utc should reset the offset');
    });

    test('reset zone with moment#local', function (assert) {
        var a = moment([2012]).zone(480);

        assert.equal(a.clone().local().hour(), 0, 'calling moment#local should reset the offset');
    });

    test('toDate', function (assert) {
        var zoneA = new Date(),
            zoneB = moment(zoneA).zone(720).toDate(),
            zoneC = moment(zoneA).zone(360).toDate(),
            zoneD = moment(zoneA).zone(-690).toDate();

        assert.equal(+zoneA, +zoneB, 'moment#toDate should output a date with the right unix timestamp');
        assert.equal(+zoneA, +zoneC, 'moment#toDate should output a date with the right unix timestamp');
        assert.equal(+zoneA, +zoneD, 'moment#toDate should output a date with the right unix timestamp');
    });

    test('same / before / after', function (assert) {
        var zoneA = moment().utc(),
            zoneB = moment(zoneA).zone(120),
            zoneC = moment(zoneA).zone(-120);

        assert.ok(zoneA.isSame(zoneB), 'two moments with different offsets should be the same');
        assert.ok(zoneA.isSame(zoneC), 'two moments with different offsets should be the same');

        assert.ok(zoneA.isSame(zoneB, 'hour'), 'two moments with different offsets should be the same hour');
        assert.ok(zoneA.isSame(zoneC, 'hour'), 'two moments with different offsets should be the same hour');

        zoneA.add(1, 'hour');

        assert.ok(zoneA.isAfter(zoneB), 'isAfter should work with two moments with different offsets');
        assert.ok(zoneA.isAfter(zoneC), 'isAfter should work with two moments with different offsets');

        assert.ok(zoneA.isAfter(zoneB, 'hour'), 'isAfter:hour should work with two moments with different offsets');
        assert.ok(zoneA.isAfter(zoneC, 'hour'), 'isAfter:hour should work with two moments with different offsets');

        zoneA.subtract(2, 'hour');

        assert.ok(zoneA.isBefore(zoneB), 'isBefore should work with two moments with different offsets');
        assert.ok(zoneA.isBefore(zoneC), 'isBefore should work with two moments with different offsets');

        assert.ok(zoneA.isBefore(zoneB, 'hour'), 'isBefore:hour should work with two moments with different offsets');
        assert.ok(zoneA.isBefore(zoneC, 'hour'), 'isBefore:hour should work with two moments with different offsets');
    });

    test('add / subtract over dst', function (assert) {
        var oldOffset = moment.updateOffset,
            m = moment.utc([2000, 2, 31, 3]);

        moment.updateOffset = function (mom, keepTime) {
            if (mom.clone().utc().month() > 2) {
                mom.zone(-60, keepTime);
            } else {
                mom.zone(0, keepTime);
            }
        };

        assert.equal(m.hour(), 3, 'should start at 00:00');

        m.add(24, 'hour');

        assert.equal(m.hour(), 4, 'adding 24 hours should disregard dst');

        m.subtract(24, 'hour');

        assert.equal(m.hour(), 3, 'subtracting 24 hours should disregard dst');

        m.add(1, 'day');

        assert.equal(m.hour(), 3, 'adding 1 day should have the same hour');

        m.subtract(1, 'day');

        assert.equal(m.hour(), 3, 'subtracting 1 day should have the same hour');

        m.add(1, 'month');

        assert.equal(m.hour(), 3, 'adding 1 month should have the same hour');

        m.subtract(1, 'month');

        assert.equal(m.hour(), 3, 'subtracting 1 month should have the same hour');

        moment.updateOffset = oldOffset;
    });

    test('isDST', function (assert) {
        var oldOffset = moment.updateOffset;

        moment.updateOffset = function (mom, keepTime) {
            if (mom.month() > 2 && mom.month() < 9) {
                mom.zone(-60, keepTime);
            } else {
                mom.zone(0, keepTime);
            }
        };

        assert.ok(!moment().month(0).isDST(),  'Jan should not be summer dst');
        assert.ok(moment().month(6).isDST(),   'Jul should be summer dst');
        assert.ok(!moment().month(11).isDST(), 'Dec should not be summer dst');

        moment.updateOffset = function (mom) {
            if (mom.month() > 2 && mom.month() < 9) {
                mom.zone(0);
            } else {
                mom.zone(-60);
            }
        };

        assert.ok(moment().month(0).isDST(),  'Jan should be winter dst');
        assert.ok(!moment().month(6).isDST(), 'Jul should not be winter dst');
        assert.ok(moment().month(11).isDST(), 'Dec should be winter dst');

        moment.updateOffset = oldOffset;
    });

    test('zone names', function (assert) {
        assert.equal(moment().zoneAbbr(),   '', 'Local zone abbr should be empty');
        assert.equal(moment().format('z'),  '', 'Local zone formatted abbr should be empty');
        assert.equal(moment().zoneName(),   '', 'Local zone name should be empty');
        assert.equal(moment().format('zz'), '', 'Local zone formatted name should be empty');

        assert.equal(moment.utc().zoneAbbr(),   'UTC', 'UTC zone abbr should be UTC');
        assert.equal(moment.utc().format('z'),  'UTC', 'UTC zone formatted abbr should be UTC');
        assert.equal(moment.utc().zoneName(),   'Coordinated Universal Time', 'UTC zone abbr should be Coordinated Universal Time');
        assert.equal(moment.utc().format('zz'), 'Coordinated Universal Time', 'UTC zone formatted abbr should be Coordinated Universal Time');
    });

    test('hours alignment with UTC', function (assert) {
        assert.equal(moment().zone(120).hasAlignedHourOffset(), true);
        assert.equal(moment().zone(-180).hasAlignedHourOffset(), true);
        assert.equal(moment().zone(90).hasAlignedHourOffset(), false);
        assert.equal(moment().zone(-90).hasAlignedHourOffset(), false);
    });

    test('hours alignment with other zone', function (assert) {
        var m = moment().zone(120);

        assert.equal(m.hasAlignedHourOffset(moment().zone(180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(90)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-90)), false);

        m = moment().zone(90);

        assert.equal(m.hasAlignedHourOffset(moment().zone(180)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-180)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(30)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-30)), true);

        m = moment().zone(-60);

        assert.equal(m.hasAlignedHourOffset(moment().zone(180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-180)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(90)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-90)), false);

        m = moment().zone(25);

        assert.equal(m.hasAlignedHourOffset(moment().zone(-35)), true);
        assert.equal(m.hasAlignedHourOffset(moment().zone(85)), true);

        assert.equal(m.hasAlignedHourOffset(moment().zone(35)), false);
        assert.equal(m.hasAlignedHourOffset(moment().zone(-85)), false);
    });

    test('parse zone', function (assert) {
        var m = moment('2013-01-01T00:00:00-13:00').parseZone();
        assert.equal(m.zone(), 13 * 60);
        assert.equal(m.hours(), 0);
    });

    test('parse zone static', function (assert) {
        var m = moment.parseZone('2013-01-01T00:00:00-13:00');
        assert.equal(m.zone(), 13 * 60);
        assert.equal(m.hours(), 0);
    });

    test('parse zone with more arguments', function (assert) {
        var m;
        m = moment.parseZone('2013 01 01 05 -13:00', 'YYYY MM DD HH ZZ');
        assert.equal(m.format(), '2013-01-01T05:00:00-13:00', 'accept input and format');
        m = moment.parseZone('2013-01-01-13:00', 'YYYY MM DD ZZ', true);
        assert.equal(m.isValid(), false, 'accept input, format and strict flag');
        m = moment.parseZone('2013-01-01-13:00', ['DD MM YYYY ZZ', 'YYYY MM DD ZZ']);
        assert.equal(m.format(), '2013-01-01T00:00:00-13:00', 'accept input and array of formats');
    });

    test('parse zone with a timezone from the format string', function (assert) {
        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY ZZ #####').parseZone();

        assert.equal(m.zone(), 4 * 60);
    });

    test('parse zone without a timezone included in the format string', function (assert) {
        var m = moment('11-12-2013 -0400 +1100', 'DD-MM-YYYY').parseZone();

        assert.equal(m.zone(), -11 * 60);
    });

    test('timezone format', function (assert) {
        assert.equal(moment().zone(-60).format('ZZ'), '+0100', '-60 -> +0100');
        assert.equal(moment().zone(-90).format('ZZ'), '+0130', '-90 -> +0130');
        assert.equal(moment().zone(-120).format('ZZ'), '+0200', '-120 -> +0200');

        assert.equal(moment().zone(+60).format('ZZ'), '-0100', '+60 -> -0100');
        assert.equal(moment().zone(+90).format('ZZ'), '-0130', '+90 -> -0130');
        assert.equal(moment().zone(+120).format('ZZ'), '-0200', '+120 -> -0200');
    });

}));
